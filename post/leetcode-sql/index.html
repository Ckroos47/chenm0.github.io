<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="个人博客">
<meta name="description" content="&lt;a href=&#34;https://https://github.com/chenm0/&#34; target=&#34;_blank&#34;&gt;code blog&lt;/a&gt;">
<meta name="theme-color" content="#000">
<title>Leetcode sql题个人题解方案 | 草庐破剑与酒壶</title>
<link rel="shortcut icon" href="/favicon.ico?v=1638153273144">
<link rel="stylesheet" href="/media/css/pisces.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/default.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">

<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>





  <meta name="description" content="Leetcode sql题个人题解方案" />
  <meta name="keywords" content="Leecode,SQL" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="pisces">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>草庐破剑与酒壶</span>
            </a>  
          
        </div>
        
          <p class="subtitle">我的程序人生路</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/archives/" target="_self">
                  <i class="fa fa-archive"></i> 归档
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tags/" target="_self">
                  <i class="fa fa-tags"></i> 标签
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/post/about/" target="_self">
                  <i class="fa fa-user"></i> 关于
                </a>
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-address-book"></i> 友情链接
                  
                </a>
              </li>
            
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout pisces ">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active language" data-lan="index">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item language" data-lan="preview">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body pisces" id="sidebar_body">
        
          
            <div class="post-side-meta" id="post_side_meta">
              
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">陈陌</p>
    
    <div class="site-description right-motion">
      
        <p id="binft">派大星我们去抓水母吧！！</p>
      
    </div>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">27</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">13</span>
        <span class="site-item-stat-name language" data-lan="category">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">13</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
    
      <div class="sidebar-item">
        <span class="site-item-rss">
            <i class="fa fa-rss"></i>
            <a href="https://https://chenm0.github.io//atom.xml" target="_blank">RSS</a>
        </span>
      </div>
    
  
  



  <div style="width: 100%; position: relative;">
    <canvas id="canvasDiyBlock" style="width:100%;">当前浏览器不支持canvas，请更换浏览器后再试</canvas>
    <script src="/media/js/magic/clock.js"></script>
  </div>

</div>
            </div>
            <div class="post-toc sidebar-body-active" id="post_toc" style="opacity: 1;">
              <div class="toc-box right-motion">
  <div class="toc-wrapper auto-number auto"
    id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#1-%E7%BB%84%E5%90%88%E4%B8%A4%E4%B8%AA%E8%A1%A8">1. 组合两个表</a>
<ul>
<li><a href="#%E8%A7%A3%E7%AD%94">解答</a><br>
*
<ul>
<li><a href="#%E6%80%9D%E8%B7%AF">思路:</a></li>
<li><a href="#%E7%AD%94%E6%A1%88">答案：</a></li>
<li><a href="#%E9%87%8D%E7%82%B9"><strong>重点：</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2%E7%AC%AC%E4%BA%8C%E9%AB%98%E7%9A%84%E8%96%AA%E6%B0%B4">2.第二高的薪水</a>
<ul>
<li><a href="#%E8%A7%A3%E7%AD%94-2">解答</a><br>
*
<ul>
<li><a href="#%E6%80%9D%E8%B7%AF-2">思路：</a></li>
<li><a href="#%E7%AD%94%E6%A1%88-2">答案：</a></li>
<li><a href="#%E9%87%8D%E7%82%B9-2"><strong>重点</strong>：</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3%E7%AC%ACn%E9%AB%98%E7%9A%84%E8%96%AA%E6%B0%B4">3.第N高的薪水</a>
<ul>
<li><a href="#%E8%A7%A3%E7%AD%94-3"><strong>解答</strong></a><br>
*
<ul>
<li><a href="#%E6%80%9D%E8%B7%AF-3"><strong>思路:</strong></a></li>
<li><a href="#%E7%AD%94%E6%A1%88-3"><strong>答案：</strong></a></li>
<li><a href="#%E9%87%8D%E7%82%B9-3"><strong>重点：</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4%E5%88%86%E6%95%B0%E6%8E%92%E5%90%8D">4.分数排名</a>
<ul>
<li><a href="#%E8%A7%A3%E7%AD%94-4"><strong>解答</strong></a><br>
*
<ul>
<li><a href="#%E6%80%9D%E8%B7%AF-4"><strong>思路:</strong></a></li>
<li><a href="#%E7%AD%94%E6%A1%88-4"><strong>答案:</strong></a></li>
<li><a href="#%E9%87%8D%E7%82%B9-4"><strong>重点:</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5%E8%BF%9E%E7%BB%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%95%B0%E5%AD%97">5.连续出现的数字</a>
<ul>
<li><a href="#%E8%A7%A3%E7%AD%94-5"><strong>解答</strong></a><br>
*
<ul>
<li><a href="#%E6%80%9D%E8%B7%AF-5"><strong>思路:</strong></a></li>
<li><a href="#%E7%AD%94%E6%A1%88-5"><strong>答案:</strong></a></li>
<li><a href="#%E9%87%8D%E7%82%B9-5"><strong>重点:</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#6%E8%B6%85%E8%BF%87%E7%BB%8F%E7%90%86%E6%94%B6%E5%85%A5%E7%9A%84%E5%91%98%E5%B7%A5">6.超过经理收入的员工</a>
<ul>
<li><a href="#%E8%A7%A3%E7%AD%94-6"><strong>解答</strong></a><br>
*
<ul>
<li><a href="#%E6%80%9D%E8%B7%AF-6"><strong>思路:</strong></a></li>
<li><a href="#%E7%AD%94%E6%A1%88-6"><strong>答案：</strong></a></li>
<li><a href="#%E9%87%8D%E7%82%B9-6"><strong>重点：</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#7%E6%9F%A5%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E7%AE%B1">7.查找重复的电子邮箱</a>
<ul>
<li><a href="#%E8%A7%A3%E7%AD%94-7"><strong>解答</strong></a><br>
*
<ul>
<li><a href="#%E6%80%9D%E8%B7%AF-7"><strong>思路:</strong></a></li>
<li><a href="#%E7%AD%94%E6%A1%88-7"><strong>答案:</strong></a></li>
<li><a href="#%E9%87%8D%E7%82%B9-7"><strong>重点:</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#8%E4%BB%8E%E4%B8%8D%E8%AE%A2%E8%B4%AD%E7%9A%84%E5%AE%A2%E6%88%B7">8.从不订购的客户</a>
<ul>
<li><a href="#%E8%A7%A3%E7%AD%94-8"><strong>解答</strong></a><br>
*
<ul>
<li><a href="#%E6%80%9D%E8%B7%AF-8"><strong>思路:</strong></a></li>
<li><a href="#%E7%AD%94%E6%A1%88-8"><strong>答案:</strong></a></li>
<li><a href="#%E9%87%8D%E7%82%B9-8"><strong>重点:</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#9%E9%83%A8%E9%97%A8%E5%B7%A5%E8%B5%84%E6%9C%80%E9%AB%98%E7%9A%84%E5%91%98%E5%B7%A5">9.部门工资最高的员工</a>
<ul>
<li><a href="#%E8%A7%A3%E7%AD%94-9"><strong>解答</strong></a><br>
*
<ul>
<li><a href="#%E6%80%9D%E8%B7%AF-9"><strong>思路:</strong></a></li>
<li><a href="#%E7%AD%94%E6%A1%88-9"><strong>答案:</strong></a></li>
<li><a href="#%E9%87%8D%E7%82%B9-9"><strong>重点:</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#10%E9%83%A8%E9%97%A8%E5%B7%A5%E8%B5%84%E5%89%8D%E4%B8%89%E9%AB%98%E7%9A%84%E6%89%80%E6%9C%89%E5%91%98%E5%B7%A5">10.部门工资前三高的所有员工</a>
<ul>
<li><a href="#%E8%A7%A3%E7%AD%94-10"><strong>解答</strong></a><br>
*
<ul>
<li><a href="#%E6%80%9D%E8%B7%AF-10"><strong>思路:</strong></a></li>
<li><a href="#%E7%AD%94%E6%A1%88-10"><strong>答案:</strong></a></li>
<li><a href="#%E9%87%8D%E7%82%B9-10"><strong>重点:</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#11-%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E7%AE%B1">11. 删除重复的电子邮箱</a>
<ul>
<li><a href="#%E8%A7%A3%E7%AD%94-11"><strong>解答</strong></a><br>
*
<ul>
<li><a href="#%E6%80%9D%E8%B7%AF-11"><strong>思路:</strong></a></li>
<li><a href="#%E7%AD%94%E6%A1%88-11"><strong>答案:</strong></a></li>
<li><a href="#%E9%87%8D%E7%82%B9-11"><strong>重点:</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#12%E4%B8%8A%E5%8D%87%E7%9A%84%E6%B8%A9%E5%BA%A6">12.上升的温度</a>
<ul>
<li><a href="#%E8%A7%A3%E7%AD%94-12"><strong>解答</strong></a><br>
*
<ul>
<li><a href="#%E6%80%9D%E8%B7%AF-12"><strong>思路:</strong></a></li>
<li><a href="#%E7%AD%94%E6%A1%88-12"><strong>答案:</strong></a></li>
<li><a href="#%E9%87%8D%E7%82%B9-12"><strong>重点:</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#13%E5%A4%A7%E7%9A%84%E5%9B%BD%E5%AE%B6">13.大的国家</a>
<ul>
<li><a href="#%E8%A7%A3%E7%AD%94-13"><strong>解答</strong></a><br>
*
<ul>
<li><a href="#%E6%80%9D%E8%B7%AF-13"><strong>思路:</strong></a></li>
<li><a href="#%E7%AD%94%E6%A1%88-13"><strong>答案:</strong></a></li>
<li><a href="#%E9%87%8D%E7%82%B9-13"><strong>重点:</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#14-%E8%B6%85%E8%BF%875%E5%90%8D%E5%AD%A6%E7%94%9F%E7%9A%84%E8%AF%BE">14. 超过5名学生的课</a>
<ul>
<li><a href="#%E8%A7%A3%E7%AD%94-14"><strong>解答</strong></a><br>
*
<ul>
<li><a href="#%E6%80%9D%E8%B7%AF-14"><strong>思路:</strong></a></li>
<li><a href="#%E7%AD%94%E6%A1%88-14"><strong>答案:</strong></a></li>
<li><a href="#%E9%87%8D%E7%82%B9-14"><strong>重点:</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#15-%E6%9C%89%E8%B6%A3%E7%9A%84%E7%94%B5%E5%BD%B1">15. 有趣的电影</a>
<ul>
<li><a href="#%E8%A7%A3%E7%AD%94-15"><strong>解答</strong></a><br>
*
<ul>
<li><a href="#%E6%80%9D%E8%B7%AF-15"><strong>思路:</strong></a></li>
<li><a href="#%E7%AD%94%E6%A1%88-15"><strong>答案:</strong></a></li>
<li><a href="#%E9%87%8D%E7%82%B9-15"><strong>重点:</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#16-%E6%8D%A2%E5%BA%A7%E4%BD%8D">16. 换座位</a>
<ul>
<li><a href="#%E8%A7%A3%E7%AD%94-16"><strong>解答</strong></a><br>
*
<ul>
<li><a href="#%E6%80%9D%E8%B7%AF-16"><strong>思路:</strong></a></li>
<li><a href="#%E7%AD%94%E6%A1%88-16"><strong>答案:</strong></a></li>
<li><a href="#%E9%87%8D%E7%82%B9-16"><strong>重点:</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#17-%E5%8F%98%E6%9B%B4%E6%80%A7%E5%88%AB">17. 变更性别</a>
<ul>
<li><a href="#%E8%A7%A3%E7%AD%94-17"><strong>解答</strong></a><br>
*
<ul>
<li><a href="#%E6%80%9D%E8%B7%AF-17"><strong>思路:</strong></a></li>
<li><a href="#%E7%AD%94%E6%A1%88-17"><strong>答案:</strong></a></li>
<li><a href="#%E9%87%8D%E7%82%B9-17"><strong>重点:</strong></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
</div>

<script>

  let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1;
  let active = 'active-show', activeClass = 'active-current';
  let tocWrapper = document.querySelector('#toc_wrapper');
  let tocContent = tocWrapper.children[0];
  let autoNumber = tocWrapper && tocWrapper.classList.contains('auto-number');

  function addTocNumber(elem, deep) {
    if (!elem) {
      return;
    }
    let prop = elem.__proto__;

    if (prop === HTMLUListElement.prototype) {
      for (let i = 0; i < elem.children.length; i++) {
        addTocNumber(elem.children[i], deep + (i + 1) + '.');
      }
    } else if (prop === HTMLLIElement.prototype) {
      // 保存li元素
      if (elem.children[0] && elem.children[0].__proto__ === HTMLAnchorElement.prototype) {
        lList.push(elem);
      }
      for (let i = 0; i < elem.children.length; i++) {
        let cur = elem.children[i];
        if (cur.__proto__ === HTMLAnchorElement.prototype) {
          if (autoNumber) {
            cur.text = deep + ' ' + cur.text;
          }
        } else if (cur.__proto__ === HTMLUListElement.prototype) {
          addTocNumber(cur, deep);
        }
      }
    }
  }

  function removeParentActiveClass() {
    let parents = tocContent.querySelectorAll('.' + active)
    parents.forEach(function (elem) {
      elem.classList.remove(active);
    });
  }

  function addActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.add(activeClass);
    }
  }

  function removeActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.remove(activeClass);
    }
  }

  function addActiveLiElemment(elem, parent) {
    if (!elem || elem === parent) {
      return;
    } else {
      if (elem.__proto__ === HTMLLIElement.prototype) {
        elem.classList.add(active);
      }
      addActiveLiElemment(elem.parentElement, parent);
    }
  }

  function showToc() {
    if (tocWrapper) {
      postBody = document.querySelector('#post_body');
      for (let i = 0; i < postBody.children.length; i++) {
        if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
          hList.push(postBody.children[i]);
        }
      }
      if (tocWrapper.classList.contains('compress')) {
        tocContent.classList.add('closed');
      } else if (tocWrapper.classList.contains('no_compress')) {
        tocContent.classList.add('expanded');
      } else {
        if (hList.length > 10) {
          active = 'active-hidden'
          tocContent.classList.add('closed');
        } else {
          tocContent.classList.add('expanded');
        }
      }
    }
  }

  (function () {
    // 处理不是从#一级标题开始目录
    if (tocContent.children.length === 1 && tocContent.children[0].__proto__ === HTMLLIElement.prototype) {
      let con = tocContent.children[0].children[0];
      tocContent.innerHTML = con.innerHTML;
    }
    let markdownItTOC = document.querySelector('.markdownIt-TOC');
    let innerHeight = window.innerHeight;
    markdownItTOC.style = `max-height: ${innerHeight - 80 > 0 ? innerHeight - 80 : innerHeight}px`
    addTocNumber(tocContent, '');
  })();

  document.addEventListener('scroll', function (e) {
    if (lList.length <= 0) {
      return;
    }
    let scrollTop = document.scrollingElement.scrollTop + 10;
    let dir;

    if (lastTop - scrollTop > 0) {
      dir = 'up';
    } else {
      dir = 'down';
    }

    lastTop = scrollTop;
    if (scrollTop <= 0) {
      if (lastIndex >= 0 && lastIndex < hList.length) {
        lList[lastIndex].classList.remove(activeClass);
      }
      return;
    }

    let current = 0, hasFind = false;
    for (let i = 0; i < hList.length; i++) {
      if (hList[i].offsetTop > scrollTop) {
        current = i;
        hasFind = true;
        break;
      }
    }
    if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
      current = hList.length - 1;
    } else {
      current--;
    }
    if (dir === 'down') {
      if (current > lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex)
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    } else {
      if (current < lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex);
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    }
  });


  window.addEventListener('load', function () {
    showToc();
    document.querySelector('#sidebar').style = 'display: block;';
    tocWrapper.classList.add('toc-active');
    setTimeout(function () {
      if ("createEvent" in document) {
        let evt = document.createEvent("HTMLEvents");
        evt.initEvent("scroll", false, true);
        document.dispatchEvent(evt);
      }
      else {
        document.fireEvent("scroll");
      }
    }, 500)
  })

</script>
            </div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    window.Velocity(hideElement, 'stop');
    window.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        window.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <section class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://https://chenm0.github.io/post/leetcode-sql/">
      Leetcode sql题个人题解方案
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
      <span class="publish-time" data-t="2021-08-26 08:03:11">2021-08-26</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show language" data-lan="category-in">分类于</span>
      
      
      <a href="https://https://chenm0.github.io/tag/kzg0vA2rw/">
        <span>Leecode</span>
      </a>、
      
      
      
      <a href="https://https://chenm0.github.io/tag/IfLrIeyl1/">
        <span>SQL</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>18<span class="language" data-lan="minute">分钟</span></span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>4209<span class="pc-show language" data-lan="words">字数</span></span>
    </span>
    
    
    
    <span id="//chenm0.github.io/post/leetcode-sql/" data-flag-title="Leetcode sql题个人题解方案" class="meta-item pc-show leancloud_visitors">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-eye"></i>
      <span><span class="language" data-lan="view">浏览量</span>：<span class="leancloud-visitors-count"></span></span>
    </span>
    
  </div>
</section>
            <div class="post-body next-md-body" id="post_body">
              <h2 id="1-组合两个表">1. 组合两个表</h2>
<p>表1: Person</p>
<pre><code>+-------------+---------+

| 列名         | 类型     |

+-------------+---------+

| PersonId    | int     |

| FirstName   | varchar |

| LastName    | varchar |

+-------------+---------+

PersonId 是上表主键
</code></pre>
<p>表2: <code>Address</code></p>
<pre><code>+-------------+---------+
| 列名         | 类型    |
+-------------+---------+
| AddressId   | int     |
| PersonId    | int     |
| City        | varchar |
| State       | varchar |
+-------------+---------+
AddressId 是上表主键
</code></pre>
<p>编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息：</p>
<pre><code>FirstName, LastName, City, State
</code></pre>
<h3 id="解答">解答</h3>
<h5 id="思路">思路:</h5>
<p>根据题目要求得知,需要查询的为Person表的FirstName,LastName和Address表的City,State字段,以Person表为主表,Address表的PersonId为外键进行查询,可保证无论Address表中是否有关联的值,Person表都能展示其信息。</p>
<h5 id="答案">答案：</h5>
<p>SELECT p.FirstName,p.LastName,a.City,a.State FROM Person p left join Address a  on  p.PersonId = a.PersonId</p>
<h5 id="重点"><strong>重点：</strong></h5>
<p>连表查询中，主表的内容都会被展示</p>
<h2 id="2第二高的薪水">2.第二高的薪水</h2>
<p>编写一个 SQL 查询，获取 <code>Employee</code> 表中第二高的薪水（Salary） 。</p>
<pre><code>+----+--------+
| Id | Salary |
+----+--------+
| 1  | 100    |
| 2  | 200    |
| 3  | 300    |
+----+--------+
</code></pre>
<p>例如上述 <code>Employee</code> 表，SQL查询应该返回 <code>200</code> 作为第二高的薪水。如果不存在第二高的薪水，那么查询应返回 <code>null</code>。</p>
<pre><code>+---------------------+
| SecondHighestSalary |
+---------------------+
| 200                 |
+---------------------+
</code></pre>
<h3 id="解答-2">解答</h3>
<h5 id="思路-2">思路：</h5>
<p>审题发现几个本题重要的考点：</p>
<p>1.获取第二高的薪水，需要掌握orderby和limit的使用，‘第二高’ 是降序的排序方式，所以需要使用order by  。。 desc。</p>
<pre><code> 			limit y 分句表示: 读取 y 条数据
	  	limit x, y 分句表示: 跳过 x 条数据，读取 y 条数据
      limit y offset x 分句表示: 跳过 x 条数据，读取 y 条数据
      limit n 等价于 limit 0,n
</code></pre>
<p>2.其次需要考虑特殊情况，首先需要去重同样的salary，其次就是如果不存在第二高的薪水，结果应为null，可以有两种解决方式：一种是用临时表，还有一种就是使用IFNULL函数。</p>
<h5 id="答案-2">答案：</h5>
<p>select IFNULL((select distinct Salary from Employee order by Salary desc limit 1,1),null) as SecondHighestSalary;</p>
<h5 id="重点-2"><strong>重点</strong>：</h5>
<p>1.limit的使用</p>
<pre><code>	  	limit y 分句表示: 读取 y 条数据
	  	limit x, y 分句表示: 跳过 x 条数据，读取 y 条数据
      limit y offset x 分句表示: 跳过 x 条数据，读取 y 条数据
      limit n 等价于 limit 0,n
</code></pre>
<p>2.IFNULL和临时表判空的方式</p>
<h2 id="3第n高的薪水">3.第N高的薪水</h2>
<p>编写一个 SQL 查询，获取 <code>Employee</code> 表中第 <em>n</em> 高的薪水（Salary）。</p>
<pre><code>+----+--------+
| Id | Salary |
+----+--------+
| 1  | 100    |
| 2  | 200    |
| 3  | 300    |
+----+--------+
</code></pre>
<p>例如上述 <code>Employee</code> 表，<em>n = 2</em> 时，应返回第二高的薪水 <code>200</code>。如果不存在第 <em>n</em> 高的薪水，那么查询应返回 <code>null</code>。</p>
<pre><code>+------------------------+
| getNthHighestSalary(2) |
+------------------------+
| 200                    |
+------------------------+
</code></pre>
<h3 id="解答-3"><strong>解答</strong></h3>
<h5 id="思路-3"><strong>思路:</strong></h5>
<p>首先对存储过程的语法进行了基本的了解，题目的要求和上一题基本相同，但需要查的位置变成了变量，所以需要在limit后用变量选择跳过的个数</p>
<h5 id="答案-3"><strong>答案：</strong></h5>
<pre><code>CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT

BEGIN

  set N = N - 1;

  RETURN (

​      \# Write your MySQL query statement below.

​      SELECT IFNULl((SELECT distinct Salary from Employee order by Salary desc limit N,1),null)

  );

END
</code></pre>
<h5 id="重点-3"><strong>重点：</strong></h5>
<p>1.存储结构的基础语法</p>
<pre><code>create procedure sp_name()
begin
.........
end
</code></pre>
<p>2.limit后不能进行运算，所以应该在begin前就将需要跳过的数算好，这里需要跳过的数应为需要查到的位数-1</p>
<h2 id="4分数排名">4.分数排名</h2>
<p>编写一个 SQL 查询来实现分数排名。</p>
<p>如果两个分数相同，则两个分数排名（Rank）相同。请注意，平分后的下一个名次应该是下一个连续的整数值。换句话说，名次之间不应该有“间隔”。</p>
<pre><code>+----+-------+
| Id | Score |
+----+-------+
| 1  | 3.50  |
| 2  | 3.65  |
| 3  | 4.00  |
| 4  | 3.85  |
| 5  | 4.00  |
| 6  | 3.65  |
+----+-------+
</code></pre>
<p>例如，根据上述给定的 <code>Scores</code> 表，你的查询应该返回（按分数从高到低排列）：</p>
<pre><code>+-------+------+
| Score | Rank |
+-------+------+
| 4.00  | 1    |
| 4.00  | 1    |
| 3.85  | 2    |
| 3.65  | 3    |
| 3.65  | 3    |
| 3.50  | 4    |
+-------+------+
</code></pre>
<h3 id="解答-4"><strong>解答</strong></h3>
<h5 id="思路-4"><strong>思路:</strong></h5>
<p>回答此题的前提是需要了解sql的四大排名函数，审题得知，我们需要根据分数的大小降序排列后，对分数进行排名且名次之间无间隔，所以在四大排名函数中应选择<strong>DENSE_RANK()</strong>。</p>
<h5 id="答案-4"><strong>答案:</strong></h5>
<p>select Score,DENSE_RANK() over (order by Score DESC) 'Rank' from Scores;</p>
<h5 id="重点-4"><strong>重点:</strong></h5>
<p>1.sql的四大排名函数：</p>
<ul>
<li>​    ROW_NUMBER()      ----- 每条数据加一个序号，不适合排名，更加适合分页功能</li>
<li>​    RANK()              ---- 排名序号可重复，之后按总数算</li>
<li>​    DENSE_RANK()        ---- 排名序号可重复，之后按序号的后一个继续</li>
<li>​    NTILE()       ----将有序分区中的行分发到指定数目的组中，各个组有编号，分为几个区，一个区会有多少个。<br>
​    所以，按照题目要求，应采取DENSE_RANK()无间隔的排名函数<br>
2.对于 MySQL 解决方案，如果要转义用作列名的保留字，可以在关键字之前和之后使用撇号。例如 <code>Rank</code></li>
</ul>
<h2 id="5连续出现的数字">5.连续出现的数字</h2>
<p>表：<code>Logs</code></p>
<pre><code>+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| id          | int     |
| num         | varchar |
+-------------+---------+
id 是这个表的主键。
</code></pre>
<p>编写一个 SQL 查询，查找所有至少连续出现三次的数字。</p>
<p>返回的结果表中的数据可以按 <strong>任意顺序</strong> 排列。</p>
<p>查询结果格式如下面的例子所示：</p>
<pre><code>Logs 表：
+----+-----+
| Id | Num |
+----+-----+
| 1  | 1   |
| 2  | 1   |
| 3  | 1   |
| 4  | 2   |
| 5  | 1   |
| 6  | 2   |
| 7  | 2   |
+----+-----+

Result 表：
+-----------------+
| ConsecutiveNums |
+-----------------+
| 1               |
+-----------------+
1 是唯一连续出现至少三次的数字。


</code></pre>
<h3 id="解答-5"><strong>解答</strong></h3>
<h5 id="思路-5"><strong>思路:</strong></h5>
<p>本题根据题目要求，需查询出连续出现至少三次的同一个数字，所以distinct函数是一定需要使用的；三次同一个数字的id分别为id，id+1，id+2，而num是相同的，所以需要两个子查询作为筛选条件</p>
<h5 id="答案-5"><strong>答案:</strong></h5>
<pre><code>select distinct Num as ConsecutiveNums from Logs where (Id+1,Num) in (select * from Logs) and (Id+2,Num) in (select * from Logs)
</code></pre>
<h5 id="重点-5"><strong>重点:</strong></h5>
<p>活用子查询</p>
<h2 id="6超过经理收入的员工">6.超过经理收入的员工</h2>
<p><code>Employee</code> 表包含所有员工，他们的经理也属于员工。每个员工都有一个 Id，此外还有一列对应员工的经理的 Id。</p>
<pre><code>+----+-------+--------+-----------+
| Id | Name  | Salary | ManagerId |
+----+-------+--------+-----------+
| 1  | Joe   | 70000  | 3         |
| 2  | Henry | 80000  | 4         |
| 3  | Sam   | 60000  | NULL      |
| 4  | Max   | 90000  | NULL      |
+----+-------+--------+-----------+
</code></pre>
<p>给定 <code>Employee</code> 表，编写一个 SQL 查询，该查询可以获取收入超过他们经理的员工的姓名。在上面的表格中，Joe 是唯一一个收入超过他的经理的员工。</p>
<pre><code>+----------+
| Employee |
+----------+
| Joe      |
+----------+
</code></pre>
<h3 id="解答-6"><strong>解答</strong></h3>
<h5 id="思路-6"><strong>思路:</strong></h5>
<p>本题需要使用子链接或自链接</p>
<h5 id="答案-6"><strong>答案：</strong></h5>
<p>子链接：</p>
<pre><code>select a.Name as Employee from Employee a where a.Salary &gt; 

(select b.Salary from Employee b where b.Id = a.ManagerId) 
</code></pre>
<p>自链接：</p>
<pre><code>select a.Name as Employee from Employee a join Employee b where b.id = a.ManagerId and b.Salary &lt; a.Salary
</code></pre>
<h5 id="重点-6"><strong>重点：</strong></h5>
<p>加强自链接和子链接的使用</p>
<h2 id="7查找重复的电子邮箱">7.查找重复的电子邮箱</h2>
<p>编写一个 SQL 查询，查找 <code>Person</code> 表中所有重复的电子邮箱。</p>
<p><strong>示例：</strong></p>
<pre><code>+----+---------+
| Id | Email   |
+----+---------+
| 1  | a@b.com |
| 2  | c@d.com |
| 3  | a@b.com |
+----+---------+
</code></pre>
<p>根据以上输入，你的查询应返回以下结果：</p>
<pre><code>+---------+
| Email   |
+---------+
| a@b.com |
+---------+
</code></pre>
<p>**说明：**所有电子邮箱都是小写字母。</p>
<h3 id="解答-7"><strong>解答</strong></h3>
<h5 id="思路-7"><strong>思路:</strong></h5>
<p>需要使用group by将结果集归类，然后使用count函数判断是否重复</p>
<h5 id="答案-7"><strong>答案:</strong></h5>
<pre><code>select Email from Person group by Email having count(Email) &gt; 1
</code></pre>
<h5 id="重点-7"><strong>重点:</strong></h5>
<p>group by...having和计数函数的使用</p>
<h2 id="8从不订购的客户">8.从不订购的客户</h2>
<p>某网站包含两个表，Customers 表和 Orders 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。</p>
<p><code>Customers</code> 表：</p>
<pre><code>+----+-------+
| Id | Name  |
+----+-------+
| 1  | Joe   |
| 2  | Henry |
| 3  | Sam   |
| 4  | Max   |
+----+-------+
</code></pre>
<p><code>Orders</code> 表：</p>
<pre><code>+----+------------+
| Id | CustomerId |
+----+------------+
| 1  | 3          |
| 2  | 1          |
+----+------------+
</code></pre>
<p>例如给定上述表格，你的查询应返回：</p>
<pre><code>+-----------+
| Customers |
+-----------+
| Henry     |
| Max       |
+-----------+
</code></pre>
<h3 id="解答-8"><strong>解答</strong></h3>
<h5 id="思路-8"><strong>思路:</strong></h5>
<p>首先需要连表进行查询，然后需要使用子查询筛选结果</p>
<h5 id="答案-8"><strong>答案:</strong></h5>
<pre><code>select c.Name as Customers from Orders o right join Customers c on c.id = o.CustomerId where c.Id not in (select CustomerId from Orders)
</code></pre>
<h5 id="重点-8"><strong>重点:</strong></h5>
<p>注意关联查询配合子查询</p>
<h2 id="9部门工资最高的员工">9.部门工资最高的员工</h2>
<p><code>Employee</code> 表包含所有员工信息，每个员工有其对应的 Id, salary 和 department Id。</p>
<pre><code>+----+-------+--------+--------------+
| Id | Name  | Salary | DepartmentId |
+----+-------+--------+--------------+
| 1  | Joe   | 70000  | 1            |
| 2  | Jim   | 90000  | 1            |
| 3  | Henry | 80000  | 2            |
| 4  | Sam   | 60000  | 2            |
| 5  | Max   | 90000  | 1            |
+----+-------+--------+--------------+
</code></pre>
<p><code>Department</code> 表包含公司所有部门的信息。</p>
<pre><code>+----+----------+
| Id | Name     |
+----+----------+
| 1  | IT       |
| 2  | Sales    |
+----+----------+

</code></pre>
<p>编写一个 SQL 查询，找出每个部门工资最高的员工。对于上述表，您的 SQL 查询应返回以下行（行的顺序无关紧要）。</p>
<pre><code>+------------+----------+--------+
| Department | Employee | Salary |
+------------+----------+--------+
| IT         | Max      | 90000  |
| IT         | Jim      | 90000  |
| Sales      | Henry    | 80000  |
+------------+----------+--------+
</code></pre>
<p><strong>解释：</strong></p>
<p>Max 和 Jim 在 IT 部门的工资都是最高的，Henry 在销售部的工资最高。</p>
<h3 id="解答-9"><strong>解答</strong></h3>
<h5 id="思路-9"><strong>思路:</strong></h5>
<p>需要应用子查询构建一个临时表，临时表中使用分区和**DENSE_RANK()**函数（因为有并列的情况）进行排序，然后在外层根据排序的序号查询排名第一的结果</p>
<h5 id="答案-9"><strong>答案:</strong></h5>
<pre><code>SELECT s.Department,s.Employee,s.Salary from 
(SELECT
    d.Name as Department,e.Name as Employee,e.Salary as Salary, DENSE_RANK() over (Partition by DepartmentID order by Salary DESC) as rn
    FROM
        Employee e join Department d on e.DepartmentID = d.Id) s
where s.rn = 1
</code></pre>
<h5 id="重点-9"><strong>重点:</strong></h5>
<p>1.Partition by 和 group by的区别<br>
1. group by是分组函数，partition by是分析函数（然后像sum()等是聚合函数）；<br>
2. 在执行顺序上，<br>
以下是常用sql关键字的优先级<br>
<mark>from &gt; where &gt; group by &gt; having &gt; order by</mark><br>
而partition by应用在以上关键字之后，实际上就是在执行完select之后，在所得结果集之上进行partition。<br>
3. partition by相比较于group by，能够在保留全部数据的基础上，只对其中某些字段做分组排序（类似excel中的操作），而group by则只保留参与分组的字段和聚合函数的结果（类似excel中的pivot）<br>
4. 如果在partition结果上聚合，千万注意聚合函数是逐条累计运行结果的！而在group by后的结果集上使用聚合函数，会作用在分组下的所有记录上。<br>
2.活用自查询</p>
<h2 id="10部门工资前三高的所有员工">10.部门工资前三高的所有员工</h2>
<p><code>Employee</code> 表包含所有员工信息，每个员工有其对应的工号 <code>Id</code>，姓名 <code>Name</code>，工资 <code>Salary</code> 和部门编号 <code>DepartmentId</code> 。</p>
<pre><code>+----+-------+--------+--------------+
| Id | Name  | Salary | DepartmentId |
+----+-------+--------+--------------+
| 1  | Joe   | 85000  | 1            |
| 2  | Henry | 80000  | 2            |
| 3  | Sam   | 60000  | 2            |
| 4  | Max   | 90000  | 1            |
| 5  | Janet | 69000  | 1            |
| 6  | Randy | 85000  | 1            |
| 7  | Will  | 70000  | 1            |
+----+-------+--------+--------------+
</code></pre>
<p><code>Department</code> 表包含公司所有部门的信息。</p>
<pre><code>+----+----------+
| Id | Name     |
+----+----------+
| 1  | IT       |
| 2  | Sales    |
+----+----------+
</code></pre>
<p>编写一个 SQL 查询，找出每个部门获得前三高工资的所有员工。例如，根据上述给定的表，查询结果应返回：</p>
<pre><code>+------------+----------+--------+
| Department | Employee | Salary |
+------------+----------+--------+
| IT         | Max      | 90000  |
| IT         | Randy    | 85000  |
| IT         | Joe      | 85000  |
| IT         | Will     | 70000  |
| Sales      | Henry    | 80000  |
| Sales      | Sam      | 60000  |
+------------+----------+--------+
</code></pre>
<p><strong>解释：</strong></p>
<p>IT 部门中，Max 获得了最高的工资，Randy 和 Joe 都拿到了第二高的工资，Will 的工资排第三。销售部门（Sales）只有两名员工，Henry 的工资最高，Sam 的工资排第二。</p>
<h3 id="解答-10"><strong>解答</strong></h3>
<h5 id="思路-10"><strong>思路:</strong></h5>
<p>根据上题的一道扩展问题，可延续上题思路，更改排序的筛选条件</p>
<h5 id="答案-10"><strong>答案:</strong></h5>
<pre><code>SELECT s.Department,s.Employee,S.Salary from 

(SELECT

​    d.Name as Department,e.Name as Employee,e.Salary as Salary, e.DepartmentId as did,DENSE_RANK() over (Partition by DepartmentID order by Salary DESC) as rn

​    FROM

​        Employee e join Department d on e.DepartmentID = d.Id) s

where s.rn &lt;= 3 order by s.did asc,S.Salary DESC
</code></pre>
<h5 id="重点-10"><strong>重点:</strong></h5>
<p>主要思路延续上一题</p>
<h2 id="11-删除重复的电子邮箱">11. 删除重复的电子邮箱</h2>
<p>编写一个 SQL 查询，来删除 Person 表中所有重复的电子邮箱，重复的邮箱里只保留 Id 最小 的那个。</p>
<pre><code>+----+------------------+
| Id | Email            |
+----+------------------+
| 1  | john@example.com |
| 2  | bob@example.com  |
| 3  | john@example.com |
+----+------------------+
Id 是这个表的主键。
</code></pre>
<p>例如，在运行你的查询语句之后，上面的 Person 表应返回以下几行:</p>
<pre><code>+----+------------------+
| Id | Email            |
+----+------------------+
| 1  | john@example.com |
| 2  | bob@example.com  |
+----+------------------+
</code></pre>
<p>提示：</p>
<ul>
<li>执行 SQL 之后，输出是整个 Person 表。</li>
<li>使用 delete 语句。</li>
</ul>
<h3 id="解答-11"><strong>解答</strong></h3>
<h5 id="思路-11"><strong>思路:</strong></h5>
<p>使用自链接筛选比较结果进行删除</p>
<h5 id="答案-11"><strong>答案:</strong></h5>
<pre><code>delete p1 from Person p1 join Person p2 on p1.Email = p2.Email where p1.Id &gt; p2.Id
</code></pre>
<h5 id="重点-11"><strong>重点:</strong></h5>
<p>活用自链接</p>
<h2 id="12上升的温度">12.上升的温度</h2>
<p>表 Weather</p>
<pre><code>+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| id            | int     |
| recordDate    | date    |
| temperature   | int     |
+---------------+---------+
id 是这个表的主键
该表包含特定日期的温度信息
</code></pre>
<p>编写一个 SQL 查询，来查找与之前（昨天的）日期相比温度更高的所有日期的 id 。<br>
返回结果 不要求顺序 。<br>
查询结果格式如下例：</p>
<pre><code>Weather
+----+------------+-------------+
| id | recordDate | Temperature |
+----+------------+-------------+
| 1  | 2015-01-01 | 10          |
| 2  | 2015-01-02 | 25          |
| 3  | 2015-01-03 | 20          |
| 4  | 2015-01-04 | 30          |
+----+------------+-------------+

Result table:
+----+
| id |
+----+
| 2  |
| 4  |
+----+
2015-01-02 的温度比前一天高（10 -&gt; 25）
2015-01-04 的温度比前一天高（20 -&gt; 30）
</code></pre>
<h3 id="解答-12"><strong>解答</strong></h3>
<h5 id="思路-12"><strong>思路:</strong></h5>
<p>这里需要使用datediff函数来判断前一天，== datediff(日期1, 日期2)： 得到的结果是日期1与日期2相差的天数。 如果日期1比日期2大，结果为正；如果日期1比日期2小，结果为负。==</p>
<h5 id="答案-12"><strong>答案:</strong></h5>
<pre><code>select w1.id from Weather w1,Weather w2 where w1.Temperature &gt; w2.Temperature and datediff(w1.recordDate,w2.recordDate) = 1
</code></pre>
<h5 id="重点-12"><strong>重点:</strong></h5>
<p>== datediff(日期1, 日期2)： 得到的结果是日期1与日期2相差的天数。 如果日期1比日期2大，结果为正；如果日期1比日期2小，结果为负。==</p>
<h2 id="13大的国家">13.大的国家</h2>
<p>这里有张 World 表</p>
<pre><code>+-----------------+------------+------------+--------------+---------------+
| name            | continent  | area       | population   | gdp           |
+-----------------+------------+------------+--------------+---------------+
| Afghanistan     | Asia       | 652230     | 25500100     | 20343000      |
| Albania         | Europe     | 28748      | 2831741      | 12960000      |
| Algeria         | Africa     | 2381741    | 37100000     | 188681000     |
| Andorra         | Europe     | 468        | 78115        | 3712000       |
| Angola          | Africa     | 1246700    | 20609294     | 100990000     |
+-----------------+------------+------------+--------------+---------------+
</code></pre>
<p>如果一个国家的面积超过 300 万平方公里，或者人口超过 2500 万，那么这个国家就是大国家。<br>
编写一个 SQL 查询，输出表中所有大国家的名称、人口和面积。<br>
例如，根据上表，我们应该输出:</p>
<pre><code>+--------------+-------------+--------------+
| name         | population  | area         |
+--------------+-------------+--------------+
| Afghanistan  | 25500100    | 652230       |
| Algeria      | 37100000    | 2381741      |
+--------------+-------------+--------------+
</code></pre>
<h3 id="解答-13"><strong>解答</strong></h3>
<h5 id="思路-13"><strong>思路:</strong></h5>
<p>此题比较简单，使用or进行筛选即可</p>
<h5 id="答案-13"><strong>答案:</strong></h5>
<pre><code>select name,population,area from World where area &gt; 3000000 or population &gt; 25000000
</code></pre>
<h5 id="重点-13"><strong>重点:</strong></h5>
<p>or的使用方式</p>
<h2 id="14-超过5名学生的课">14. 超过5名学生的课</h2>
<p>有一个courses 表 ，有: student (学生) 和 class (课程)。<br>
请列出所有超过或等于5名学生的课。<br>
例如，表：</p>
<pre><code>+---------+------------+
| student | class      |
+---------+------------+
| A       | Math       |
| B       | English    |
| C       | Math       |
| D       | Biology    |
| E       | Math       |
| F       | Computer   |
| G       | Math       |
| H       | Math       |
| I       | Math       |
+---------+------------+
</code></pre>
<p>应该输出:</p>
<pre><code>+---------+
| class   |
+---------+
| Math    |
+---------+
</code></pre>
<p>提示：</p>
<ul>
<li>学生在每个课中不应被重复计算。</li>
</ul>
<h3 id="解答-14"><strong>解答</strong></h3>
<h5 id="思路-14"><strong>思路:</strong></h5>
<p>可使用子查询进行分组之后利用count筛选结果</p>
<h5 id="答案-14"><strong>答案:</strong></h5>
<pre><code>select c.class from (select distinct * from courses) c group by c.class having count(c.class) &gt;=5 
</code></pre>
<h5 id="重点-14"><strong>重点:</strong></h5>
<p>注意提示，需要进行去重操作</p>
<h2 id="15-有趣的电影">15. 有趣的电影</h2>
<p>某城市开了一家新的电影院，吸引了很多人过来看电影。该电影院特别注意用户体验，专门有个 LED显示板做电影推荐，上面公布着影评和相关电影描述。<br>
作为该电影院的信息部主管，您需要编写一个 SQL查询，找出所有影片描述为非 boring (不无聊) 的并且 id 为奇数 的影片，结果请按等级 rating 排列。<br>
例如，下表 cinema:</p>
<pre><code>+---------+-----------+--------------+-----------+
|   id    | movie     |  description |  rating   |
+---------+-----------+--------------+-----------+
|   1     | War       |   great 3D   |   8.9     |
|   2     | Science   |   fiction    |   8.5     |
|   3     | irish     |   boring     |   6.2     |
|   4     | Ice song  |   Fantacy    |   8.6     |
|   5     | House card|   Interesting|   9.1     |
+---------+-----------+--------------+-----------+
</code></pre>
<p>对于上面的例子，则正确的输出是为：</p>
<pre><code>+---------+-----------+--------------+-----------+
|   id    | movie     |  description |  rating   |
+---------+-----------+--------------+-----------+
|   5     | House card|   Interesting|   9.1     |
|   1     | War       |   great 3D   |   8.9     |
+---------+-----------+--------------+-----------+
</code></pre>
<h3 id="解答-15"><strong>解答</strong></h3>
<h5 id="思路-15"><strong>思路:</strong></h5>
<p>奇数可以用取余不等于0的方式计算，“&lt;&gt;”代表的是不等于</p>
<h5 id="答案-15"><strong>答案:</strong></h5>
<pre><code>select id,movie,description,rating from cinema where id % 2 &lt;&gt; 0 and description &lt;&gt; 'boring' order by rating desc
</code></pre>
<h5 id="重点-15"><strong>重点:</strong></h5>
<p>奇数的算法和不等于符号</p>
<h2 id="16-换座位">16. 换座位</h2>
<p>小美是一所中学的信息科技老师，她有一张 seat 座位表，平时用来储存学生名字和与他们相对应的座位 id。<br>
其中纵列的 id 是连续递增的<br>
小美想改变相邻俩学生的座位。<br>
你能不能帮她写一个 SQL query 来输出小美想要的结果呢？<br>
示例：</p>
<pre><code>+---------+---------+
|    id   | student |
+---------+---------+
|    1    | Abbot   |
|    2    | Doris   |
|    3    | Emerson |
|    4    | Green   |
|    5    | Jeames  |
+---------+---------+
</code></pre>
<p>假如数据输入的是上表，则输出结果如下：</p>
<pre><code>+---------+---------+
|    id   | student |
+---------+---------+
|    1    | Doris   |
|    2    | Abbot   |
|    3    | Green   |
|    4    | Emerson |
|    5    | Jeames  |
+---------+---------+
</code></pre>
<p>注意：<br>
如果学生人数是奇数，则不需要改变最后一个同学的座位。</p>
<h3 id="解答-16"><strong>解答</strong></h3>
<h5 id="思路-16"><strong>思路:</strong></h5>
<p>此题涉及到异或运算符的使用，需要对异或运算符有所了解</p>
<h5 id="答案-16"><strong>答案:</strong></h5>
<pre><code>select rank() over (order by ((id-1)^1)) as id,student from seat
</code></pre>
<h5 id="重点-16"><strong>重点:</strong></h5>
<p>^(位异或)的使用方式：<br>
上下运算,按照与的运算规则：0&amp;0=0 ；0&amp;1=1；1&amp;1=0</p>
<h2 id="17-变更性别">17. 变更性别</h2>
<p>给定一个 salary 表，如下所示，有 m = 男性 和 f = 女性 的值。交换所有的 f 和 m 值（例如，将所有 f 值更改为 m，反之亦然）。要求只使用一个更新（Update）语句，并且没有中间的临时表。</p>
<p>注意，您必只能写一个 Update 语句，请不要编写任何 Select 语句。<br>
例如：</p>
<pre><code>| id | name | sex | salary |
|----|------|-----|--------|
| 1  | A    | m   | 2500   |
| 2  | B    | f   | 1500   |
| 3  | C    | m   | 5500   |
| 4  | D    | f   | 500    |
</code></pre>
<p>运行你所编写的更新语句之后，将会得到以下表:</p>
<pre><code>| id | name | sex | salary |
|----|------|-----|--------|
| 1  | A    | f   | 2500   |
| 2  | B    | m   | 1500   |
| 3  | C    | f   | 5500   |
| 4  | D    | m   | 500    |
</code></pre>
<h3 id="解答-17"><strong>解答</strong></h3>
<h5 id="思路-17"><strong>思路:</strong></h5>
<p>此题涉及到sql语句中的if用法</p>
<h5 id="答案-17"><strong>答案:</strong></h5>
<pre><code>update salary set sex = if(sex = 'f','m','f')
</code></pre>
<h5 id="重点-17"><strong>重点:</strong></h5>
<p>在sql的update语句中，if语句类似于三目运算符的作用</p>

            </div>
            
            
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong class="language" data-lan="author">本文作者：</strong>
      陈陌
    </li>
    <li class="post-copyright-link">
      <strong class="language" data-lan="link">本文链接：</strong>
      <a href="https://https://chenm0.github.io/post/leetcode-sql/" title="Leetcode sql题个人题解方案">https://https://chenm0.github.io/post/leetcode-sql/</a>
    </li>
    <li class="post-copyright-license">
      <strong class="language" data-lan="copyright">版权声明： </strong>
      本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
      <a href="https://https://chenm0.github.io/tag/kzg0vA2rw/"># Leecode</a>
    
      <a href="https://https://chenm0.github.io/tag/IfLrIeyl1/"># SQL</a>
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="Mybatis动态SQL" href="https://https://chenm0.github.io/post/mybatis-sql/">Mybatis动态SQL</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="Mybatis动态SQL" href="https://https://chenm0.github.io/post/mybatis-sql/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="Maven setting" href="https://https://chenm0.github.io/post/maven-setting/">Maven setting</a>
        <a class="nav-mobile-next" title="Maven setting" href="https://https://chenm0.github.io/post/maven-setting/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
            
            
  

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <div class="poweredby">
      Powered by <a href="https://github.com/chenm0" target="_blank">ChenMo</a>
    </div>
  </footer>
  
  
  <div class="pisces back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
  
  
<link rel="stylesheet" href="/media/live2d/css/live2d.css" />
<div class="box-scale">
  <div id="landlord" style="left: 5px;bottom: px;"
    data-key="">
    <canvas id="live2d" width="500" height="560" class="live2d"></canvas>
    

      <div class="message" style="opacity:0"></div>
      <div class="live_talk_input_body">
        <div class="live_talk_input_name_body">
          <input name="name" type="text" class="live_talk_name white_input" id="AIuserName" autocomplete="off"
            placeholder="你的名字" />
        </div>
        <div class="live_talk_input_text_body">
          <input name="talk" type="text" class="live_talk_talk white_input" id="AIuserText" autocomplete="off"
            placeholder="要和我聊什么呀？" />
          <button type="button" class="live_talk_send_btn" id="talk_send">发送</button>
        </div>
      </div>
      <input name="live_talk" id="live_talk" value="1" type="hidden" />
      <div class="live_ico_box">
        <div class="live_ico_item type_info" id="showInfoBtn"></div>
        <div class="live_ico_item type_talk" id="showTalkBtn"></div>
        
        <div class="live_ico_item type_youdu" id="youduButton"></div>
        <div class="live_ico_item type_quit" id="hideButton"></div>
        <input name="live_statu_val" id="live_statu_val" value="0" type="hidden" />
        <audio src="" style="display:none;" id="live2d_bgm" data-bgm="0" preload="none"></audio>
        <input id="duType" value="douqilai" type="hidden">
        
      </div>
    
  </div>
</div>
<div id="open_live2d">召唤看板娘</div>
<script src="https://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>
<script>
  var message_Path = 'https://cdn.jsdelivr.net/gh/hsxyhao/live2d.github.io@master/';
  let landlord = document.querySelector('#landlord');
  var apiKey = landlord.dataset.key;
</script>
<script type="text/javascript" src="/media/live2d/js/live2d.js"></script>
<script>
	var home_Path = document.location.protocol + '//' + window.document.location.hostname + ":" + window.document.location.port + '/';
	var userAgent = window.navigator.userAgent.toLowerCase();
	var norunAI = ["android", "iphone", "ipod", "ipad", "windows phone", "mqqbrowser", "msie", "trident/7.0"];
	var norunFlag = false;

	for (var i = 0; i < norunAI.length; i++) {
		if (userAgent.indexOf(norunAI[i]) > -1) {
			norunFlag = true;
			break;
		}
	}

	if (!window.WebGLRenderingContext) {
		norunFlag = true;
	}

	if (!norunFlag) {
		var hitFlag = false;
		var AIFadeFlag = false;
		var liveTlakTimer = null;
		var sleepTimer_ = null;
		var AITalkFlag = false;
		var talkNum = 0;
		(function () {
			function renderTip(template, context) {
				var tokenReg = /(\\)?\{([^\{\}\\]+)(\\)?\}/g;
				return template.replace(tokenReg, function (word, slash1, token, slash2) {
					if (slash1 || slash2) {
						return word.replace('\\', '');
					}
					var variables = token.replace(/\s/g, '').split('.');
					var currentObject = context;
					var i, length, variable;
					for (i = 0, length = variables.length; i < length; ++i) {
						variable = variables[i];
						currentObject = currentObject[variable];
						if (currentObject === undefined || currentObject === null) return '';
					}
					return currentObject;
				});
			}

			String.prototype.renderTip = function (context) {
				return renderTip(this, context);
			};

			var re = /x/;
			re.toString = function () {
				showMessage('哈哈，你打开了控制台，是想要看看我的秘密吗？', 5000);
				return '';
			};

			$(document).on('copy', function () {
				showMessage('你都复制了些什么呀，转载要记得加上出处哦~~', 5000);
			});

			function initTips() {
				$.ajax({
					cache: true,
					url: message_Path + 'message.json',
					dataType: "json",
					success: function (result) {
						$.each(result.mouseover, function (index, tips) {
							$(tips.selector).mouseover(function () {
								var text = tips.text;
								if (Array.isArray(tips.text)) text = tips.text[Math.floor(Math.random() * tips.text.length + 1) - 1];
								text = text.renderTip({ text: $(this).text() });
								showMessage(text, 3000);
								talkValTimer();
								clearInterval(liveTlakTimer);
								liveTlakTimer = null;
							});
							$(tips.selector).mouseout(function () {
								showHitokoto();
								if (liveTlakTimer == null) {
									liveTlakTimer = window.setInterval(function () {
										showHitokoto();
									}, 15000);
								};
							});
						});
						$.each(result.click, function (index, tips) {
							$(tips.selector).click(function () {
								if (hitFlag) {
									return false
								}
								hitFlag = true;
								setTimeout(function () {
									hitFlag = false;
								}, 8000);
								var text = tips.text;
								if (Array.isArray(tips.text)) text = tips.text[Math.floor(Math.random() * tips.text.length + 1) - 1];
								text = text.renderTip({ text: $(this).text() });
								showMessage(text, 3000);
							});
							clearInterval(liveTlakTimer);
							liveTlakTimer = null;
							if (liveTlakTimer == null) {
								liveTlakTimer = window.setInterval(function () {
									showHitokoto();
								}, 15000);
							};
						});
					}
				});
			}
			initTips();

			var text;
			if (document.referrer !== '') {
				var referrer = document.createElement('a');
				referrer.href = document.referrer;
				text = '嗨！来自 <span style="color:#0099cc;">' + referrer.hostname + '</span> 的朋友！';
				var domain = referrer.hostname.split('.')[1];
				if (domain == 'baidu') {
					text = '嗨！ 来自 百度搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				} else if (domain == 'so') {
					text = '嗨！ 来自 360搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				} else if (domain == 'google') {
					text = '嗨！ 来自 谷歌搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				}
			} else {
				if (window.location.href == home_Path) { //主页URL判断，需要斜杠结尾
					var now = (new Date()).getHours();
					if (now > 23 || now <= 5) {
						text = '你是夜猫子呀？这么晚还不睡觉，明天起的来嘛？';
					} else if (now > 5 && now <= 7) {
						text = '早上好！一日之计在于晨，美好的一天就要开始了！';
					} else if (now > 7 && now <= 11) {
						text = '上午好！工作顺利嘛，不要久坐，多起来走动走动哦！';
					} else if (now > 11 && now <= 14) {
						text = '中午了，工作了一个上午，现在是午餐时间！';
					} else if (now > 14 && now <= 17) {
						text = '午后很容易犯困呢，今天的运动目标完成了吗？';
					} else if (now > 17 && now <= 19) {
						text = '傍晚了！窗外夕阳的景色很美丽呢，最美不过夕阳红~~';
					} else if (now > 19 && now <= 21) {
						text = '晚上好，今天过得怎么样？';
					} else if (now > 21 && now <= 23) {
						text = '已经这么晚了呀，早点休息吧，晚安~~';
					} else {
						text = '嗨~ 快来逗我玩吧！';
					}
				} else {
					text = '欢迎阅读<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				}
			}
			showMessage(text, 12000);
		})();

		liveTlakTimer = setInterval(function () {
			showHitokoto();
		}, 15000);

		function showHitokoto() {
			if (sessionStorage.getItem("Sleepy") !== "1") {
				if (!AITalkFlag) {
					$.getJSON('https://v1.hitokoto.cn/', function (result) {
						talkValTimer();
						showMessage(result.hitokoto, 0);
					});
				}
			} else {
				hideMessage(0);
				if (sleepTimer_ == null) {
					sleepTimer_ = setInterval(function () {
						checkSleep();
					}, 200);
				}
			}
		}

		function checkSleep() {
			var sleepStatu = sessionStorage.getItem("Sleepy");
			if (sleepStatu !== '1') {
				talkValTimer();
				showMessage('你回来啦~', 0);
				clearInterval(sleepTimer_);
				sleepTimer_ = null;
			}
		}

		function showMessage(text, timeout) {
			if (Array.isArray(text)) text = text[Math.floor(Math.random() * text.length + 1) - 1];
			$('.message').stop();
			$('.message').html(text);
			$('.message').fadeTo(200, 1);
			//if (timeout === null) timeout = 5000;
			//hideMessage(timeout);
		}
		function talkValTimer() {
			$('#live_talk').val('1');
		}

		function hideMessage(timeout) {
			//$('.message').stop().css('opacity',1);
			if (timeout === null) timeout = 5000;
			$('.message').delay(timeout).fadeTo(200, 0);
		}

		function initLive2d() {
			$('#hideButton').on('click', function () {
				if (AIFadeFlag) {
					return false;
				} else {
					AIFadeFlag = true;
					localStorage.setItem("live2dhidden", "0");
					$('#landlord').fadeOut(200);
					$('#open_live2d').delay(200).fadeIn(200);
					setTimeout(function () {
						AIFadeFlag = false;
					}, 300);
				}
			});
			$('#open_live2d').on('click', function () {
				if (AIFadeFlag) {
					return false;
				} else {
					AIFadeFlag = true;
					localStorage.setItem("live2dhidden", "1");
					$('#open_live2d').fadeOut(200);
					$('#landlord').delay(200).fadeIn(200);
					setTimeout(function () {
						AIFadeFlag = false;
					}, 300);
				}
			});
			$('#youduButton').on('click', function () {
				if ($('#youduButton').hasClass('doudong')) {
					var typeIs = $('#youduButton').attr('data-type');
					$('#youduButton').removeClass('doudong');
					$('body').removeClass(typeIs);
					$('#youduButton').attr('data-type', '');
				} else {
					var duType = $('#duType').val();
					var duArr = duType.split(",");
					var dataType = duArr[Math.floor(Math.random() * duArr.length)];

					$('#youduButton').addClass('doudong');
					$('#youduButton').attr('data-type', dataType);
					$('body').addClass(dataType);
				}
			});
			if (apiKey) {
				$('#showInfoBtn').on('click', function () {
					var live_statu = $('#live_statu_val').val();
					if (live_statu == "0") {
						return
					} else {
						$('#live_statu_val').val("0");
						$('.live_talk_input_body').fadeOut(500);
						AITalkFlag = false;
						showHitokoto();
						$('#showTalkBtn').show();
						$('#showInfoBtn').hide();
					}
				});
				$('#showTalkBtn').on('click', function () {
					var live_statu = $('#live_statu_val').val();
					if (live_statu == "1") {
						return
					} else {
						$('#live_statu_val').val("1");
						$('.live_talk_input_body').fadeIn(500);
						AITalkFlag = true;
						$('#showTalkBtn').hide();
						$('#showInfoBtn').show();

					}
				});
				$('#talk_send').on('click', function () {
					var info_ = $('#AIuserText').val();
					var userid_ = $('#AIuserName').val();
					if (info_ == "") {
						showMessage('写点什么吧！', 0);
						return;
					}
					if (userid_ == "") {
						showMessage('聊之前请告诉我你的名字吧！', 0);
						return;
					}
					showMessage('思考中~', 0);
					let protocol = window.location.protocol.indexOf("s") > 0 ? "https" : "http";
					$.ajax({
						type: "get",
						url: `${protocol}://www.tuling123.com/openapi/api?key=${apiKey}&info=${info_}`,
						dataType: "json",
						success: function (res) {
							talkValTimer();
							showMessage(res.text, 0);
							$('#AIuserText').val("");
							sessionStorage.setItem("live2duser", userid_);
						},
						error: function (e) {
							talkValTimer();
							showMessage('似乎有什么错误，请和站长联系！', 0);
						}
					});
				});
			} else {
				$('#showInfoBtn').hide();
				$('#showTalkBtn').hide();
			}
			//获取音乐信息初始化
			var bgmListInfo = $('input[name=live2dBGM]');
			if (bgmListInfo.length == 0) {
				$('#musicButton').hide();
			} else {
				var bgmPlayNow = parseInt($('#live2d_bgm').attr('data-bgm'));
				var bgmPlayTime = 0;
				var live2dBGM_Num = sessionStorage.getItem("live2dBGM_Num");
				var live2dBGM_PlayTime = sessionStorage.getItem("live2dBGM_PlayTime");
				if (live2dBGM_Num) {
					if (live2dBGM_Num <= $('input[name=live2dBGM]').length - 1) {
						bgmPlayNow = parseInt(live2dBGM_Num);
					}
				}
				if (live2dBGM_PlayTime) {
					bgmPlayTime = parseInt(live2dBGM_PlayTime);
				}
				var live2dBGMSrc = bgmListInfo.eq(bgmPlayNow).val();
				$('#live2d_bgm').attr('data-bgm', bgmPlayNow);
				$('#live2d_bgm').attr('src', live2dBGMSrc);
				$('#live2d_bgm')[0].currentTime = bgmPlayTime;
				$('#live2d_bgm')[0].volume = 0.5;
				var live2dBGM_IsPlay = sessionStorage.getItem("live2dBGM_IsPlay");
				var live2dBGM_WindowClose = sessionStorage.getItem("live2dBGM_WindowClose");
				if (live2dBGM_IsPlay == '0' && live2dBGM_WindowClose == '0') {
					$('#live2d_bgm')[0].play();
					$('#musicButton').addClass('play');
				}
				sessionStorage.setItem("live2dBGM_WindowClose", '1');
				$('#musicButton').on('click', function () {
					if ($('#musicButton').hasClass('play')) {
						$('#live2d_bgm')[0].pause();
						$('#musicButton').removeClass('play');
						sessionStorage.setItem("live2dBGM_IsPlay", '1');
					} else {
						$('#live2d_bgm')[0].play();
						$('#musicButton').addClass('play');
						sessionStorage.setItem("live2dBGM_IsPlay", '0');
					}
				});
				window.onbeforeunload = function () {
					sessionStorage.setItem("live2dBGM_WindowClose", '0');
					if ($('#musicButton').hasClass('play')) {
						sessionStorage.setItem("live2dBGM_IsPlay", '0');
					}
				}
				document.getElementById('live2d_bgm').addEventListener("timeupdate", function () {
					var live2dBgmPlayTimeNow = document.getElementById('live2d_bgm').currentTime;
					sessionStorage.setItem("live2dBGM_PlayTime", live2dBgmPlayTimeNow);
				});
				document.getElementById('live2d_bgm').addEventListener("ended", function () {
					var listNow = parseInt($('#live2d_bgm').attr('data-bgm'));
					listNow++;
					if (listNow > $('input[name=live2dBGM]').length - 1) {
						listNow = 0;
					}
					var listNewSrc = $('input[name=live2dBGM]').eq(listNow).val();
					sessionStorage.setItem("live2dBGM_Num", listNow);
					$('#live2d_bgm').attr('src', listNewSrc);
					$('#live2d_bgm')[0].play();
					$('#live2d_bgm').attr('data-bgm', listNow);
				});
				document.getElementById('live2d_bgm').addEventListener("error", function () {
					$('#live2d_bgm')[0].pause();
					$('#musicButton').removeClass('play');
					showMessage('音乐似乎加载不出来了呢！', 0);
				});
			}
			//获取用户名
			var live2dUser = sessionStorage.getItem("live2duser");
			if (live2dUser !== null) {
				$('#AIuserName').val(live2dUser);
			}
			//获取位置
			var landL = sessionStorage.getItem("historywidth");
			var landB = sessionStorage.getItem("historyheight");
			if (landL == null || landB == null) {
				landL = '5px'
				landB = '0px'
			}
			$('#landlord').css('left', landL + 'px');
			$('#landlord').css('bottom', landB + 'px');
			//移动
			function getEvent() {
				return window.event || arguments.callee.caller.arguments[0];
			}
			var smcc = document.getElementById("landlord");
			var moveX = 0;
			var moveY = 0;
			var moveBottom = 0;
			var moveLeft = 0;
			var moveable = false;
			var docMouseMoveEvent = document.onmousemove;
			var docMouseUpEvent = document.onmouseup;
			smcc.onmousedown = function () {
				var ent = getEvent();
				moveable = true;
				moveX = ent.clientX;
				moveY = ent.clientY;
				var obj = smcc;
				moveBottom = parseInt(obj.style.bottom);
				moveLeft = parseInt(obj.style.left);
				if (isFirefox = navigator.userAgent.indexOf("Firefox") > 0) {
					window.getSelection().removeAllRanges();
				}
				document.onmousemove = function () {
					if (moveable) {
						var ent = getEvent();
						var x = moveLeft + ent.clientX - moveX;
						var y = moveBottom + (moveY - ent.clientY);
						obj.style.left = x + "px";
						obj.style.bottom = y + "px";
					}
				};
				document.onmouseup = function () {
					if (moveable) {
						var historywidth = obj.style.left;
						var historyheight = obj.style.bottom;
						historywidth = historywidth.replace('px', '');
						historyheight = historyheight.replace('px', '');
						sessionStorage.setItem("historywidth", historywidth);
						sessionStorage.setItem("historyheight", historyheight);
						document.onmousemove = docMouseMoveEvent;
						document.onmouseup = docMouseUpEvent;
						moveable = false;
						moveX = 0;
						moveY = 0;
						moveBottom = 0;
						moveLeft = 0;
					}
				};
			};
		}
		$(document).ready(function () {
			var AIimgSrc = [];
			let chooseLive2d = 'hijiki'
			if (chooseLive2d === 'histoire') {
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_00.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_01.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_02.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_03.png");
			} else if (chooseLive2d === 'rem') {
				AIimgSrc.push(message_Path + "model/rem/remu2048/texture_00.png");
			} else if (chooseLive2d === 'aoba') {
				AIimgSrc.push(message_Path + "model/aoba/textures/texture_00.png");
			} else if (chooseLive2d === 'hijiki') {
				AIimgSrc.push(message_Path + "model/hijiki/moc/hijiki.2048/texture_00.png");
			} else if (chooseLive2d === 'tororo') {
				AIimgSrc.push(message_Path + "model/tororo/moc/tororo.2048/texture_00.png");
			}
			var images = [];
			var imgLength = AIimgSrc.length;
			var loadingNum = 0;
			for (var i = 0; i < imgLength; i++) {
				images[i] = new Image();
				images[i].src = AIimgSrc[i];
				images[i].onload = function () {
					loadingNum++;
					if (loadingNum === imgLength) {
						var live2dhidden = localStorage.getItem("live2dhidden");
						if (live2dhidden === "0") {
							setTimeout(function () {
								$('#open_live2d').fadeIn(200);
							}, 1300);
						} else {
							setTimeout(function () {
								$('#landlord').fadeIn(200);
							}, 1300);
						}
						let model = '';
						if (chooseLive2d === 'histoire') {
							model = message_Path + "model/histoire/model.json";
						} else if (chooseLive2d === 'rem') {
							model = message_Path + "model/rem/model.json";
						} else if (chooseLive2d === 'aoba') {
							model = message_Path + "model/aoba/model.json";
						} else if (chooseLive2d === 'hijiki') {
							model = message_Path + "model/hijiki/hijiki.model.json";
						} else if (chooseLive2d === 'tororo') {
							model = message_Path + "model/tororo/tororo.model.json";
						}
						setTimeout(function () {
							loadlive2d("live2d", model);
						}, 1000);
						initLive2d();
						images = null;
					}
				}
			}
		});
	}
</script>
  
  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
    back2TopText = document.querySelector('#back_to_top_text'),
    drawerBox = document.querySelector('#drawer_box'),
    rightSideBar = document.querySelector('.sidebar'),
    viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {

    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener('scroll', function (e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });


  let hasCacu = false;
  window.onresize = function () {
    calcuHeight();
  }

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      window.Velocity(rightSideBar, 'stop');
      window.Velocity(viewport, 'stop');
      window.Velocity(rightMotions, 'stop');
      if (open) {
        window.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function () {
            window.Velocity(rightMotions, transitionDir, {});
          }
        })
        window.Velocity(viewport, openProp, {
          duration: MOTION_TIME
        });
      } else {
        window.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function () {
            window.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        window.Velocity(viewport, closeProp, {
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 链接跳转
  let newWindow = 'false'
  if (newWindow === 'true') {
    let links = document.querySelectorAll('.post-body a')
    links.forEach(item => {
      if (!item.classList.contains('btn')) {
        item.setAttribute("target", "_blank");
      }
    })
  }

  let faSearch = document.querySelector('#fa_search');
  faSearch.addEventListener('click', function () {
    document.querySelector('#search_mask').style = ''
  })

  // 代码高亮
  hljs.initHighlightingOnLoad();
  
  // 离开当前页title变化
  var leaveTitle = "";
  if (leaveTitle) {
    document.addEventListener('visibilitychange', function () {
      if (document.visibilityState == 'hidden') {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }

</script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

<script>
  let images = document.querySelectorAll('.section img');
  console.log(images);
  images.forEach(image => {
    var parent = image.parentElement;
    var next = image.nextElementSibling;
    parent.removeChild(image);
    var aelem = document.createElement('a');
    aelem.href = image.src;
    aelem.dataset['fancybox'] = 'images';
    aelem.dataset['rel'] = 'fancybox-button';
    aelem.classList.add('fancybox');
    aelem.appendChild(image);
    parent.insertBefore(aelem, next);
  })
</script>

    <div class="reward-mask" style="display: none;">
  <div class="reward-relative">
    <span class="close" aria-hidden="true">x</span>
    <div class="reward-body">
      <h2>感谢您的支持，我会继续努力的!</h2>
      <div class="reward-img-box">
        <div style="position: relative; width: 140px; height: 140px;">
          
          
          
        </div>
      </div>
      <p class="reward-word">扫码打赏，你说多少就多少</p>
      <p class="reward-tip">打开微信扫一扫，即可进行扫码打赏哦</p>
    </div>
    <div class="bottom">
      
      
    </div>
  </div>
</div>
<style>
  .reward-mask {
    position: fixed;
    z-index: 99999;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    background-color: #00000054;
  }

  .reward-relative {
    position: relative;
    width: 480px;
    text-align: center;
    margin: 0 auto;
    border-radius: 5px;
    background-color: #fff;
    top: 50%;
    margin-top: -205px;
  }

  .reward-relative .close {
    position: absolute;
    right: 10px;
    font-weight: normal;
    font-size: 16px;
    color: #929292;
  }

  .reward-body {
    padding: 40px 20px 20px;
  }

  .bottom {
    display: flex;
  }

  .reward-btn {
    text-align: center;
  }

  .reward-btn-text {
    display: inline-block;
    cursor: pointer;
    width: 60px;
    height: 60px;
    line-height: 60px;
    border-radius: 50%;
    background-color: #ff9734;
    color: #FFF;
    margin-top: 20px;
  }

  .pay-text {
    margin-top: 10px;
    padding: 10px;
    flex: 1;
    transition: all .2s linear;
  }

  .pay-text:hover {
    background-color: #a5a5a536;
  }

  .reward-body h2 {
    padding-top: 10px;
    text-align: center;
    color: #a3a3a3;
    font-size: 16px;
    font-weight: normal;
    margin: 0 0 20px;
  }

  .reward-body h2:after,
  .reward-body h2:before {
    font-family: Arial, Helvetica, sans-serif;
    background: 0 0;
    width: 0;
    height: 0;
    font-style: normal;
    color: #eee;
    font-size: 80px;
    position: absolute;
    top: 20px;
  }

  .reward-body h2:before {
    content: '\201c';
    left: 50px;
  }

  .reward-body h2:after {
    content: '\201d';
    right: 80px;
  }

  .reward-img-box {
    display: inline-block;
    padding: 10px;
    border: 6px solid #ea5f00;
    margin: 0 auto;
    border-radius: 3px;
    position: relative;
  }

  .reward-img {
    position: absolute;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
  }

  @media (max-width: 767px) {
    .reward-relative {
      height: 100%;
      top: 0px;
      margin-top: 0;
      width: auto;
    }

    .reward-relative .bottom {
      flex-direction: column;
    }

    .reward-relative .pay-text {
      width: 80%;
      margin: 5px auto;
      border: 1px solid silver;
      padding: 6px;
      border-radius: 4px;
    }

    .reward-body h2:after {
      right: 40px;
    }

    .reward-body h2:after,
    .reward-body h2:before {
      font-size: 60px;
    }

    .reward-body h2:before {
      left: 20px;
    }
  }
</style>
<script>
  !function () {
    var mask = document.querySelector('.reward-mask');
    let close = document.querySelector('.reward-relative .close');
    let rewardBtn = document.querySelector('.reward-btn');

    let zfb = document.querySelector('#zfb'),
      wx = document.querySelector('#wx'),
      zfbBtn = document.querySelector('#zfbBtn'),
      wxBtn = document.querySelector('#wxBtn');

    if (zfbBtn && wxBtn) {
      zfbBtn.addEventListener('click', () => {
        window.Velocity(zfb, 'transition.slideLeftIn', {
          duration: 400
        });
        window.Velocity(wx, 'transition.slideRightOut', {
          display: 'none',
          duration: 400
        });
      });

      wxBtn.addEventListener('click', () => {
        window.Velocity(wx, 'transition.slideRightIn', {
          duration: 400
        });
        window.Velocity(zfb, 'transition.slideLeftOut', {
          display: 'none',
          duration: 400
        });
      });
    }

    rewardBtn.addEventListener('click', (e) => {
      window.Velocity(mask, 'transition.slideDownIn', {
        duration: 400
      })
    });

    close.addEventListener('click', (e) => {
      e.preventDefault();
      window.Velocity(mask, 'transition.slideUpOut', {
        duration: 400
      })
    })
  }()
</script>

  </div>
</body>

<div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://https://chenm0.github.io/post/volatile/"" data-c="
          &lt;pre&gt;&lt;code&gt;由于volatile关键字是与java的内存模型有关的，所以需要对内存模型相关的概念和知识有所了解。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;内存模型的相关概念&#34;&gt;内存模型的相关概念&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;计算机在执行程序时，每条指令都是在CPU中执行的，而在执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了&amp;lt;B&amp;gt;高速缓存&amp;lt;/B&amp;gt;。
也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码：
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;i = i + 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。
这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。
比如同时有2个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。但是事实会是这样吗？
可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。
最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。
也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。
为了解决缓存不一致性问题，通常来说有以下2种解决方法：
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;通过在总线加LOCK#锁的方式&lt;/li&gt;
&lt;li&gt;通过缓存一致性协议&lt;br&gt;
这2种方式都是硬件层面上提供的方式。&lt;br&gt;
在早期的CPU当中，是通过在总线上加LOCK#锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。&lt;br&gt;
但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。&lt;br&gt;
所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。&lt;br&gt;
&lt;img src=&#34;https://https://chenm0.github.io//post-images/1637826258727.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;并发编程中的三个概念&#34;&gt;并发编程中的三个概念&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;在并发编程中，通常会遇到以下三个问题：原子性问题，可见性问题，有序性问题。
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;原子性&lt;br&gt;
即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。&lt;br&gt;
&lt;u&gt;一个很经典的例子就是银行账户转账问题：&lt;/u&gt;&lt;br&gt;
比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元&lt;br&gt;
试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。&lt;br&gt;
所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。&lt;/li&gt;
&lt;li&gt;可见性&lt;br&gt;
可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。&lt;br&gt;
举个简单的例子：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;   //线程1执行的代码
int i = 0;
i = 10;
 
//线程2执行的代码
j = i;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。
此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.
这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;有序性&lt;br&gt;
即程序执行的顺序按照代码的先后顺序执行：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;int i = 0;              
boolean flag = false;
i = 1;                //语句1  
flag = true;  
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。
下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。
比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。
虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。
虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;//线程1:
context = loadContext();   //语句1
inited = true;             //语句2
 
//线程2:
while(!inited ){
  sleep()
}
doSomethingwithconfig(context);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。

从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。
也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;java内存模型&#34;&gt;JAVA内存模型&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;下面研究一下JAVA内存模型提供了哪些保证以及在java中提供了哪些方法和机制保证了多线程编程时的程序执行正确性。
在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。那么Java内存模型规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。
Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。
那么Java语言 本身对 原子性、可见性以及有序性提供了哪些保证呢？
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;原子性&lt;br&gt;
在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;x = 10;         //语句1
y = x;         //语句2
x++;           //语句3
x = x + 1;     //语句4
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;上述代码的操作只有语句1是原子性操作，其他三个语句都不是原子性操作。

语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。
语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。
同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。

所以上面4个语句只有语句1的操作具备原子性。也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。
不过这里有一点需要注意：在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的JDK中，JVM已经保证对64位数据的读取和赋值也是原子性操作了。
从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可见性&lt;br&gt;
对于可见性，Java提供了volatile关键字来保证可见性。&lt;br&gt;
当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。&lt;br&gt;
而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。&lt;br&gt;
另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有序性&lt;br&gt;
在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。&lt;br&gt;
在Java里面，可以通过volatile关键字来保证一定的“有序性”。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。&lt;br&gt;
另外， &lt;em&gt;&lt;strong&gt;Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;
happens-before原则（先行发生原则)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作&lt;/li&gt;
&lt;li&gt;锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作&lt;/li&gt;
&lt;li&gt;volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作&lt;/li&gt;
&lt;li&gt;传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C&lt;/li&gt;
&lt;li&gt;线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作&lt;/li&gt;
&lt;li&gt;线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生&lt;/li&gt;
&lt;li&gt;线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行&lt;/li&gt;
&lt;li&gt;对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始&lt;br&gt;
前4条规则是比较重要的，后4条规则都是显而易见的。&lt;br&gt;
第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果出于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。&lt;br&gt;
第三条规则是一条比较重要的规则，也是后文将要重点讲述的内容。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。&lt;br&gt;
第四条规则实际上就是体现happens-before原则具备传递性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
">Volatile关键字解析</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://https://chenm0.github.io/post/maven-assembly-plugin-cha-jian/"" data-c="
          &lt;h3 id=&#34;一-assembly-是什么意思&#34;&gt;一. Assembly 是什么意思？&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://https://chenm0.github.io//post-images/1636076532479.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;二-maven-assembly-plugin是什么&#34;&gt;二. maven-assembly-plugin是什么？&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;它是maven中针对打包任务而提供的标准插件。&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;三-maven-assembly-plugin插件的作用&#34;&gt;三. maven-assembly-plugin插件的作用？&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;摘自官网：&lt;/strong&gt; http://maven.apache.org/plugins/maven-assembly-plugin/&lt;br&gt;
&lt;strong&gt;英文原文：&lt;/strong&gt; The Assembly Plugin for Maven is primarily intended to allow users to aggregate the project output along with its dependencies, modules, site documentation, and other files into a single distributable archive.&lt;br&gt;
&lt;strong&gt;中文翻译：&lt;/strong&gt; Assembly 插件的主要作用是，允许用户将项目输出与它的依赖项、模块、站点文档、和其他文件一起组装成一个可分发的归档文件。&lt;/p&gt;
&lt;h3 id=&#34;四maven-assembly-plugin插件在maven项目中如何使用即使用步骤&#34;&gt;四.maven-assembly-plugin插件在maven项目中如何使用（即使用步骤）？&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;需要指定一个Assembly描述符文件。该文件指定了打包格式，包含的文件/过滤的文件等信息，可以同时指定多个描述符文件，打包成不同的格式。&lt;/li&gt;
&lt;li&gt;在Maven工程的pom.xml文件里配置maven-assembly-plugin插件，引入Assembly描述符文件。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;五-maven项目中assembly描述符文件详解&#34;&gt;五. maven项目中Assembly描述符文件详解&lt;/h3&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&amp;lt;assembly
​    xmlns=&amp;quot;http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.2&amp;quot;
​    xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
​    xsi:schemaLocation=&amp;quot;http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.2 http://maven.apache.org/xsd/assembly-1.1.2.xsd&amp;quot;&amp;gt;

​    &amp;lt;!-- id 标识符，添加到生成文件名称的后缀符。如果指定 id 的话（这里指定的是项目的版本），目标文件则是 ${artifactId}-${id}.jar。【如terminal-dispatch-5.0.0.0.jar】 --&amp;gt;
​    &amp;lt;id&amp;gt;${project.version}&amp;lt;/id&amp;gt;

​    &amp;lt;!-- 指定打包格式。maven-assembly-plugin插件支持的打包格式有zip、tar、tar.gz (or tgz)、tar.bz2 (or tbz2)、jar、dir、war，可以同时指定多个打包格式 --&amp;gt;
​    &amp;lt;formats&amp;gt;
​        &amp;lt;format&amp;gt;jar&amp;lt;/format&amp;gt;
​    &amp;lt;/formats&amp;gt;
​    
​    &amp;lt;!-- 指定打的包是否包含打包层目录（比如finalName是terminal-dispatch，当值为true，所有文件被放在包内的terminal-dispatch目录下，否则直接放在包的根目录下）--&amp;gt;
​    &amp;lt;includeBaseDirectory&amp;gt;true&amp;lt;/includeBaseDirectory&amp;gt;

​    &amp;lt;!-- 指定将工程依赖的包打到包里的指定目录下 --&amp;gt;
​    &amp;lt;dependencySets&amp;gt;
​        &amp;lt;dependencySet&amp;gt;
​            &amp;lt;useProjectArtifact&amp;gt;true&amp;lt;/useProjectArtifact&amp;gt; &amp;lt;!-- 指定打包时是否包含工程自身生成的jar包 --&amp;gt;
​            &amp;lt;outputDirectory&amp;gt;lib&amp;lt;/outputDirectory&amp;gt; &amp;lt;!-- 指定将这些依赖包打到包里lib目录下 --&amp;gt;
​            &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt; &amp;lt;!-- 用于管理依赖的部署，runtime表示只在运行时使用 --&amp;gt;
​        &amp;lt;/dependencySet&amp;gt;
​    &amp;lt;/dependencySets&amp;gt;

​    &amp;lt;!-- 指定要包含的文件集，可以定义多个fileSet --&amp;gt;
​    &amp;lt;fileSets&amp;gt;
​        &amp;lt;fileSet&amp;gt;
​            &amp;lt;directory&amp;gt;src/main/script/linux/bin&amp;lt;/directory&amp;gt; &amp;lt;!-- 指定归档文件（要打的jar包）要包含的目录（下的文件及文件夹） --&amp;gt;
​            &amp;lt;outputDirectory&amp;gt;bin&amp;lt;/outputDirectory&amp;gt; &amp;lt;!-- 指定要将当前目录（&amp;lt;directory&amp;gt;标签中的目录放在归档文件（要打的jar包）bin目录下） --&amp;gt;
​            &amp;lt;includes&amp;gt;
​                &amp;lt;include&amp;gt;terminal-dispatch&amp;lt;/include&amp;gt; &amp;lt;!-- 精确控制要包含的文件，&amp;lt;exclude&amp;gt;用于精确控制要排除的文件  --&amp;gt;
​                &amp;lt;include&amp;gt;server&amp;lt;/include&amp;gt;
​            &amp;lt;/includes&amp;gt;
​            &amp;lt;fileMode&amp;gt;0755&amp;lt;/fileMode&amp;gt; &amp;lt;!-- 设置文件 UNIX 属性，是一种读写权限 --&amp;gt;
​       &amp;lt;/fileSet&amp;gt;        
​        &amp;lt;fileSet&amp;gt;
​            &amp;lt;directory&amp;gt;src/main/resources&amp;lt;/directory&amp;gt;
​            &amp;lt;outputDirectory&amp;gt;conf&amp;lt;/outputDirectory&amp;gt;
​            &amp;lt;includes&amp;gt;
​                &amp;lt;include&amp;gt;config.properties&amp;lt;/include&amp;gt;
​                &amp;lt;include&amp;gt;logback.xml&amp;lt;/include&amp;gt;
​            &amp;lt;/includes&amp;gt;
​            &amp;lt;fileMode&amp;gt;0644&amp;lt;/fileMode&amp;gt;
​        &amp;lt;/fileSet&amp;gt;
​        &amp;lt;fileSet&amp;gt;
​            &amp;lt;directory&amp;gt;src/main/script/conf&amp;lt;/directory&amp;gt;
​            &amp;lt;outputDirectory&amp;gt;conf&amp;lt;/outputDirectory&amp;gt;
​            &amp;lt;includes&amp;gt;
​                &amp;lt;include&amp;gt;wrapper.conf&amp;lt;/include&amp;gt;
​            &amp;lt;/includes&amp;gt;
​            &amp;lt;fileMode&amp;gt;0644&amp;lt;/fileMode&amp;gt;
​        &amp;lt;/fileSet&amp;gt;
​        &amp;lt;fileSet&amp;gt;
​            &amp;lt;directory&amp;gt;src/main/script/linux/lib&amp;lt;/directory&amp;gt;
​            &amp;lt;outputDirectory&amp;gt;lib&amp;lt;/outputDirectory&amp;gt;
​            &amp;lt;includes&amp;gt;
​                &amp;lt;include&amp;gt;libwrapper.so&amp;lt;/include&amp;gt;
​                &amp;lt;include&amp;gt;wrapper.jar&amp;lt;/include&amp;gt;
​            &amp;lt;/includes&amp;gt;
​            &amp;lt;fileMode&amp;gt;0755&amp;lt;/fileMode&amp;gt;
​        &amp;lt;/fileSet&amp;gt;
​    &amp;lt;/fileSets&amp;gt;
&amp;lt;/assembly&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;&lt;includeBaseDirectory&gt;true&lt;/includeBaseDirectory&gt;标签作用？&lt;br&gt;
指定打的包是否包含打包层目录，比如finalName是terminal-dispatch，当值为true，所有文件被放在包内的terminal-dispatch目录下，否则直接放在包的根目录下&lt;/li&gt;
&lt;li&gt;&lt;fileMode&gt;0755&lt;/fileMode&gt;标签作用？&lt;br&gt;
设置文件的unix属性，好像是一种读写权限的设定，linux的内容，我没有深究，不是特别懂，暂时不多说。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;1&lt;br&gt;
compile&lt;br&gt;
缺省值，适用于所有阶段，会随着项目一起发布&lt;/p&gt;
&lt;p&gt;2&lt;br&gt;
provided&lt;br&gt;
类似compile，期望JDK、容器或使用者会提供这个依赖。如servlet.jar&lt;/p&gt;
&lt;p&gt;3&lt;br&gt;
runtime&lt;br&gt;
只在运行时使用，如JDBC驱动，适用运行和测试阶段&lt;/p&gt;
&lt;p&gt;4&lt;br&gt;
test&lt;br&gt;
只在测试时使用，用于编译和运行测试代码。不会随项目发布&lt;/p&gt;
&lt;p&gt;5&lt;br&gt;
system&lt;br&gt;
类似provided，需要显式提供包含依赖的jar，Maven不会在Repository中查找它&lt;/p&gt;
&lt;h3 id=&#34;六-maven中的pomxml配置引入assembly描述符文件&#34;&gt;六. maven中的pom.xml配置(引入assembly描述符文件)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&amp;lt;build&amp;gt;
    &amp;lt;plugins&amp;gt;
       &amp;lt;plugin&amp;gt;
       　　&amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
　　　　　　&amp;lt;artifactId&amp;gt;maven-assembly-plugin&amp;lt;/artifactId&amp;gt;
　　　　　　&amp;lt;version&amp;gt;2.4&amp;lt;/version&amp;gt;
　　　　　　　　&amp;lt;executions&amp;gt;
　　　　　　　　　　&amp;lt;execution&amp;gt; &amp;lt;!--执行器 mvn assembly:assembly--&amp;gt;
　　　　　　　　　　　　&amp;lt;id&amp;gt;make-zip&amp;lt;/id&amp;gt; &amp;lt;!--名字任意 --&amp;gt;
　　　　　　　　　　　　&amp;lt;phase&amp;gt;package&amp;lt;/phase&amp;gt; &amp;lt;!-- 绑定到package生命周期阶段上 --&amp;gt;
　　　　　　　　　　　　&amp;lt;goals&amp;gt;
　　　　　　　　　　　　　　&amp;lt;goal&amp;gt;single&amp;lt;/goal&amp;gt; &amp;lt;!-- 该打包任务只运行一次 --&amp;gt;
　　　　　　　　　　　　&amp;lt;/goals&amp;gt;
　　　　　　　　　　　　&amp;lt;configuration&amp;gt;
　　　　　　　　　　　　　　&amp;lt;descriptors
　　　　　　　　　　　　　　　　&amp;lt;descriptor&amp;gt;src/main/script/assembly.xml&amp;lt;/descriptor&amp;gt; 
　　　　　　　　　　　　　　&amp;lt;/descriptors&amp;gt;
　　　　　　　　　　&amp;lt;/configuration&amp;gt;
　　　　　　　　&amp;lt;/execution&amp;gt;
　　　　　　&amp;lt;/executions&amp;gt;
　　　　&amp;lt;/plugin&amp;gt;
    &amp;lt;plugins&amp;gt;
&amp;lt;/build&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
">maven-assembly-plugin插件</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://https://chenm0.github.io/post/computer-organization-design-note/"" data-c="
          &lt;h3 id=&#34;第1章-计算机概要与技术&#34;&gt;第1章 计算机概要与技术&lt;/h3&gt;
&lt;h5 id=&#34;英译&#34;&gt;英译：&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;World Wide Web (www)--- 万维网

Personal Computer (PC) --- 个人计算机

Embedded computer --- 嵌入式计算机

Personal Mobile Device(PMD) --- 个人移动设备

Cloud computing --- 云计算

Warehouse Scale Computer (WSC) --- 仓储规模计算机

Software as a Service (SAAS) --- 软件即服务

Multicore microprocessor --- 多核微处理器

acronym --- 首字母缩略词

Random Access Memory (RAM) --- 随机访问存储器

Central Process Unit (CPU)--- 中央处理单元

Moore&#39;s Law --- 摩尔定律

abstraction --- 抽象

common case fast --- 加速大概率事件

parallel performance --- 并行性能

pipeline --- 流水线

prediction --- 预测

hierarchy of memory --- 存储器层次

dependable --- 可靠性

system software --- 系统软件

compiler --- 编译程序

binary digit --- 二进制位

bit --- 位

Instruction --- 指令

assembler --- 汇编程序

assembly language --- 汇编语言

machine language --- 机器语言

high-level programming language --- 高级编程语言

input device --- 输入设备

output device --- 输出设备

Liquid Crystal Display (LCD) --- 液晶显示

active matrix display --- 动态矩阵显示

pixel --- 像素

bit map --- 位图

intergrated circuit --- 集成电路

chip --- 芯片

datapath --- 数据通路

control --- 控制器

Graphic Processor Unit (GPU) --- 图形处理器单元

memory --- 内存

Dynamic Random Access Memory (DRAM) --- 动态随机访问存储器

cache memory --- 缓存

Static Random Access Memory (SRAM) --- 静态随机访问存储器

instruction set architecture --- 指令集体系结构

architecture --- 体系结构

Application Binary Inteface (ABI) --- 应用二进制接口

implementation --- 实现

volatile memory --- 易失性存储器

nonvolatile memory --- 非易失性存储器

main memory 或 primary memory --- 主存储器

secondary memory --- 二级存储器

magnetic disk --- 磁盘

flash memory --- 闪存

hard disk --- 硬盘

Local Area Network (LAN) --- 局域网

Wide Area Network (WAN) --- 广域网

&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;11-引言&#34;&gt;1.1  引言&lt;/h5&gt;
&lt;p&gt;计算机主要分为以下三类应用及各自的特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;个人计算机：&lt;/strong&gt; 用于个人使用的计算机，通常包含图形显示器、键盘和鼠标等。个人计算机强调对单用户提供良好的性能，价格低廉，通常运行第三方软件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;服务器：&lt;/strong&gt; 用于位多用户运行大型程序的计算机，通常由多个用户并行使用，并且一般通过网络访问。通常情况下，当发生故障时，服务器比个人计算机恢复的代价高的多，因此服务器更加强调可靠性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;嵌入式计算机：&lt;/strong&gt; 嵌入到其他设备中的计算机，一般运行预定义的一个或者一组应用程序。嵌入式计算系统的设计目标是运行单一应用程序或者一组相关的应用程序，并且通常和硬件集成在一起以单一系统的方式一并交付用户。在面向消费者的嵌入式应用中（如数字家电）一般通过简单设计来获得可靠性——其重点在于尽可能地保证一项功能的正常运转。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;后PC时代，在硬件上，由个人移动设备和云计算分别替代了PC和传统的服务器；而通过云计算实现的软件即服务（SAAS) 是软件工业的革命：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;个人移动设备：&lt;/strong&gt; 连接到网络上的小型无线设备。PMD由电池供电，通过下载App的方式安装软件。智能手机和平板电脑是典型的PMD&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;云计算：&lt;/strong&gt; 依赖于称为仓储规模计算机（WSC）的巨型数据中心，在网络上提供服务的大服务器集群，一些运营商根据应用需求出租不同数量的服务器。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;软件即服务：&lt;/strong&gt; 在网络上以服务的方式提供软件和数据。其运行方式通常不是在本地设备上运行所有的二进制代码，而是通过诸如运行在本地客户端的浏览器等小程序登录到远程服务器上执行。典型的例子是Web搜索和社交网络。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;硬件和软件如何对程序性能造成影响：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;软件和硬件组成元素&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;该元素如何影响性能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;算法&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;决定了源码级语句的数量和I/O操作的数量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;编程语言、编译器和体系结构&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;决定了每条源码级语句对应的计算机指令数量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;处理器和存储系统&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;决定了指令的执行速度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;I/O系统（硬件和操作系统）&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;决定了I/O操作可能的执行速度&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5 id=&#34;12-计算机系统结构中的8个伟大思想&#34;&gt;1.2  计算机系统结构中的8个伟大思想&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;面向摩尔定律的设计：&lt;/strong&gt; 计算机设计者必须预测其设计完成时的工艺水平，而不是设计开始时的&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用抽象简化设计：&lt;/strong&gt; 用抽象来表示不同的设计层次提高硬件和软件生产率，在高层次中看不到的低层次的细节，只能看到一个简化的模型&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;加速大概率事件：&lt;/strong&gt; 加速大概率事件远比小概率事件更能提高性能&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;通过并行提高性能：&lt;/strong&gt; 通过并行执行操作来提高性能&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;通过流水线提高性能：&lt;/strong&gt; 流水线是特别的并行性场景，可以想象成一系列水管，其中每一块代表一个流水级&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;通过预测提高性能：&lt;/strong&gt; 在某些情况下，如果假定从误删除恢复执行代价不高并且预测的准确率相对较高，则通过猜测的方式提前开始某些操作。（预测先行）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;存储器层次：&lt;/strong&gt; 可以把存储器层次想象成一个堆叠的三角形，该形状表示速度、价格和容量；越靠近顶端，存储器速度越快、每位价格越高；底层宽度越大，存储器容量越大&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;通过冗余提高可靠性：&lt;/strong&gt; 冗余部件可以替代失效部件并可以帮助检测错误（容灾策略）&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;13-程序概念入门&#34;&gt;1.3 程序概念入门&lt;/h5&gt;
&lt;p&gt;硬件和软件层次图简化：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://https://chenm0.github.io//post-images/1631171219535.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;系统软件：&lt;/strong&gt; 提供常用服务的软件，包括操作系统、编译程序、加载程序和汇编程序等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;系统软件中，有两种是现代计算机系统中必须的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;操作系统：&lt;/strong&gt; 是用户程序与硬件之间的接口，为了使程序更好地在计算机上运行而管理计算机上运行而管理计算机资源的监控程序&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;编译程序：&lt;/strong&gt; 将高级语言翻译为计算机所能识别的机器语言的程序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于计算机来说，最简单的信号就是“通” 和 “断” ，所以计算机只用0和1两个来表示，每个0或1就是一个二进制位，使用数字既表述指令又表示数据是计算机的基础。为符合人类的思维方式，发明了助记符，随后开发了一种称为汇编程序的软件自动将助记符翻译为二进制，但仍需要写出计算机执行的每条命令，要求要像计算机一样思考，于是便出现了高级编程语言。使用高级编程语言有三点好处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可以用更自然的语言来思考&lt;/li&gt;
&lt;li&gt;简明性&lt;/li&gt;
&lt;li&gt;独立性&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;14-硬件概念入门&#34;&gt;1.4 硬件概念入门&lt;/h5&gt;
&lt;p&gt;组成计算机的5个经典组件是 &lt;mark&gt;输入、输出、存储器、数据通路（也称运算器）和控制器&lt;/mark&gt;，数据通路和控制器通常合成为处理器。其中两个关键部件是&lt;strong&gt;输入设备&lt;/strong&gt;和&lt;strong&gt;输出设备&lt;/strong&gt;，输入设备是为计算机提供信息的装置，如键盘；输出设备是将计算结果输出给用户（如显示器）或其他计算机装置。&lt;br&gt;
处理器从存储器中得到指令和数据，输入部件将数据写入存储器，输出部件从内存中读出数据，控制器向数据通路、存储器、输入和输出部件发出信号。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;液晶显示（LCD）的原理：&lt;/strong&gt;&lt;br&gt;
LCD并非光源，而是控制光的传输。通过电流控制位于两层垂直的偏光板之间的棒状液态分子团形成的转动螺旋线，来弯曲来自显示器后方的光线和少量反射光线（在不施加任何电压的情况下，液晶处于初始状态，并将入射光扭转90度，施加电压时，则不再弯曲，光线不能通过）。&lt;br&gt;
现在的大多数LCD显示器采用&lt;mark&gt;动态矩阵&lt;/mark&gt;显示技术，使用晶体管控制单个像素上光线的传输。每个像素都由晶体管精确地控制电流，使图像更清晰。还有一个红 - 绿 - 蓝屏决定三种颜色分量的强度，每个点需要3个晶体管开关。&lt;/p&gt;
&lt;p&gt;图像由像素矩阵组成，可以表示成二进制位的矩阵，称为“位图”。计算机硬件采用光栅刷新缓冲区（帧缓冲区）来保存位图以支持图像，每个像素的二进制值以刷新频率读出到显示设备。&lt;br&gt;
而后PC时代使用接触敏感的显示设备替代了键盘和鼠标，拥有良好的用户界面，用户可以直接指向感兴趣的内容。&lt;br&gt;
触摸屏的原理是电容感应。绝缘玻璃上覆盖一层透明的导体，人的手指接触到屏幕范围时，由于人是导体，将会使屏幕的电场发生变化，进而导致电容的变化。这种技术允许同时接触多个点，可提供非常好的用户界面。&lt;/p&gt;
&lt;p&gt;根据Apple iPad2平板电脑的例子，可以看出I/O是该设备的主要部分，包括一个电容性多触电的LCD、前置摄像头、后置摄像头、麦克风、耳机插孔、扬声器、加速计、陀螺仪、Wi-Fi网络和蓝牙网络。而数据通路、控制器、存储器只占一小部分。&lt;br&gt;
在Apple iPad2的逻辑主板上由下列设备构成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;集成电路&lt;/strong&gt; ：也叫芯片，一种将几十个至几百万个晶体管连接起来的设备&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;中央处理器单元（CPU）&lt;/strong&gt;：也成为处理器 ，包括数据通路和控制器
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;数据通路&lt;/em&gt;：是处理器中执行算术操作的部分&lt;/li&gt;
&lt;li&gt;&lt;em&gt;控制器&lt;/em&gt;：处理器中根据程序的指令指挥数据通路、存储器和I/O设备的部分&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;关于存储器&lt;/strong&gt;&lt;br&gt;
计算机中的存储器设计体现了八大思想中的存储器层次，分为两种类型：&lt;mark&gt;易失性存储器和非易失性存储器&lt;/mark&gt;，易失性存储器被称为主存储器，非易失性存储器被称为二级存储器。&lt;br&gt;
易失性存储器在计算机中有两种存储器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;内存&lt;/strong&gt;：程序运行时的存储空间，同时也用于保存程序运行时所需的数据。
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;DRAM&lt;/em&gt;： 动态随机访问存储器，访问时间大约为50ns，每Gib的价格大约为5～10美元&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缓存&lt;/strong&gt;：小而快的存储器，一般作为DRAM的缓冲
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;SRAM&lt;/em&gt;:  静态随机访问存储器，速度更快且不那么密集，但价格比DRAM高&lt;br&gt;
非易失性存储器在PC和个人移动设备中的使用不同，PC中磁盘占据主导地位，而闪存在个人移动设备中替代了磁盘。但闪存具有写100000～1000000次后老化或损坏的弱点，所以文件系统必须记录写操作的数目，而且具备避免存储器损坏的策略。例如：避免移动经常使用的数据。磁盘和闪存的区别如下：&lt;br&gt;
|              |     磁盘      |    闪存     |&lt;br&gt;
| :----------: | :-----------: | :---------: |&lt;br&gt;
|  &lt;strong&gt;易失性&lt;/strong&gt;  |   非易失性    |  非易失性   |&lt;br&gt;
| &lt;strong&gt;访问时间&lt;/strong&gt; |    5～20ms    |   5～50ms   |&lt;br&gt;
|   &lt;strong&gt;价格&lt;/strong&gt;   | 0.05～0.1美元 | 0.75～1美元 |&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;计算机硬件的设计也体现了八大思想中的抽象思想，硬件和底层软件之间的接口是最重要的抽象之一，被称为&lt;mark&gt;指令集体系结构&lt;/mark&gt;，这一抽象接口使得同一软件可以由成本不同、性能也不同的实现方法完成。&lt;br&gt;
提供给应用程序员的基本指令集和操作系统接口合称为&lt;mark&gt;应用二进制接口&lt;/mark&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;指令集体系结构&lt;/strong&gt;：也叫体系结构，是低层次软件和硬件之间的抽象接口，包含需要编写正确运行的机器语言程序所需要的全部信息&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用二进制接口&lt;/strong&gt;：用户部分的指令加上应用程序员调用的操作系统接口，定义了二进制层次可移植的计算机的标准&lt;/li&gt;
&lt;/ul&gt;
">《计算机组成与设计》学习笔记——第1章</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://https://chenm0.github.io/post/mybatis-sql/"" data-c="
          &lt;p&gt;动态 SQL 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦。&lt;/p&gt;
&lt;p&gt;使用动态 SQL 并非一件易事，但借助可用于任何 SQL 映射语句中的强大的动态 SQL 语言，MyBatis 显著地提升了这一特性的易用性。&lt;/p&gt;
&lt;p&gt;如果你之前用过 JSTL 或任何基于类 XML 语言的文本处理器，你对动态 SQL 元素可能会感觉似曾相识。在 MyBatis 之前的版本中，需要花时间了解大量的元素。借助功能强大的基于 OGNL 的表达式，MyBatis 3 替换了之前的大部分元素，大大精简了元素种类，现在要学习的元素种类比原来的一半还要少。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;if&lt;/li&gt;
&lt;li&gt;choose (when, otherwise)&lt;/li&gt;
&lt;li&gt;trim (where, set)&lt;/li&gt;
&lt;li&gt;foreach&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;if&#34;&gt;if&lt;/h3&gt;
&lt;p&gt;使用动态 SQL 最常见情景是根据条件包含 where 子句的一部分。比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;select id=&amp;quot;findActiveBlogWithTitleLike&amp;quot;
     resultType=&amp;quot;Blog&amp;quot;&amp;gt;
  SELECT * FROM BLOG
  WHERE state = ‘ACTIVE’
  &amp;lt;if test=&amp;quot;title != null&amp;quot;&amp;gt;
    AND title like #{title}
  &amp;lt;/if&amp;gt;
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这条语句提供了可选的查找文本功能。如果不传入 “title”，那么所有处于 “ACTIVE” 状态的 BLOG 都会返回；如果传入了 “title” 参数，那么就会对 “title” 一列进行模糊查找并返回对应的 BLOG 结果（“title” 的参数值需要包含查找掩码或通配符字符）。&lt;/p&gt;
&lt;p&gt;如果希望通过 “title” 和 “author” 两个参数进行可选搜索该怎么办呢？首先，我想先将语句名称修改成更名副其实的名称；接下来，只需要加入另一个条件即可。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;select id=&amp;quot;findActiveBlogLike&amp;quot;
     resultType=&amp;quot;Blog&amp;quot;&amp;gt;
  SELECT * FROM BLOG WHERE state = ‘ACTIVE’
  &amp;lt;if test=&amp;quot;title != null&amp;quot;&amp;gt;
    AND title like #{title}
  &amp;lt;/if&amp;gt;
  &amp;lt;if test=&amp;quot;author != null and author.name != null&amp;quot;&amp;gt;
    AND author_name like #{author.name}
  &amp;lt;/if&amp;gt;
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;choose-when-otherwise&#34;&gt;choose、when、otherwise&lt;/h3&gt;
&lt;p&gt;有时候，我们不想使用所有的条件，而只是想从多个条件中选择一个使用。针对这种情况，MyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句。&lt;/p&gt;
&lt;p&gt;还是上面的例子，但是策略变为：传入了 “title” 就按 “title” 查找，传入了 “author” 就按 “author” 查找的情形。若两者都没有传入，就返回标记为 featured 的 BLOG（这可能是管理员认为，与其返回大量的无意义随机 Blog，还不如返回一些由管理员精选的 Blog）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;select id=&amp;quot;findActiveBlogLike&amp;quot;
     resultType=&amp;quot;Blog&amp;quot;&amp;gt;
  SELECT * FROM BLOG WHERE state = ‘ACTIVE’
  &amp;lt;choose&amp;gt;
    &amp;lt;when test=&amp;quot;title != null&amp;quot;&amp;gt;
      AND title like #{title}
    &amp;lt;/when&amp;gt;
    &amp;lt;when test=&amp;quot;author != null and author.name != null&amp;quot;&amp;gt;
      AND author_name like #{author.name}
    &amp;lt;/when&amp;gt;
    &amp;lt;otherwise&amp;gt;
      AND featured = 1
    &amp;lt;/otherwise&amp;gt;
  &amp;lt;/choose&amp;gt;
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;trim-where-set&#34;&gt;trim、where、set&lt;/h3&gt;
&lt;p&gt;前面几个例子已经方便地解决了一个臭名昭著的动态 SQL 问题。现在回到之前的 “if” 示例，这次我们将 “state = ‘ACTIVE’” 设置成动态条件，看看会发生什么。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;select id=&amp;quot;findActiveBlogLike&amp;quot;
     resultType=&amp;quot;Blog&amp;quot;&amp;gt;
  SELECT * FROM BLOG
  WHERE
  &amp;lt;if test=&amp;quot;state != null&amp;quot;&amp;gt;
    state = #{state}
  &amp;lt;/if&amp;gt;
  &amp;lt;if test=&amp;quot;title != null&amp;quot;&amp;gt;
    AND title like #{title}
  &amp;lt;/if&amp;gt;
  &amp;lt;if test=&amp;quot;author != null and author.name != null&amp;quot;&amp;gt;
    AND author_name like #{author.name}
  &amp;lt;/if&amp;gt;
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果没有匹配的条件会怎么样？最终这条 SQL 会变成这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM BLOG
WHERE
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这会导致查询失败。如果匹配的只是第二个条件又会怎样？这条 SQL 会是这样:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM BLOG
WHERE
AND title like ‘someTitle’
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个查询也会失败。这个问题不能简单地用条件元素来解决。这个问题是如此的难以解决，以至于解决过的人不会再想碰到这种问题。&lt;/p&gt;
&lt;p&gt;MyBatis 有一个简单且适合大多数场景的解决办法。而在其他场景中，可以对其进行自定义以符合需求。而这，只需要一处简单的改动：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;select id=&amp;quot;findActiveBlogLike&amp;quot;
     resultType=&amp;quot;Blog&amp;quot;&amp;gt;
  SELECT * FROM BLOG
  &amp;lt;where&amp;gt;
    &amp;lt;if test=&amp;quot;state != null&amp;quot;&amp;gt;
         state = #{state}
    &amp;lt;/if&amp;gt;
    &amp;lt;if test=&amp;quot;title != null&amp;quot;&amp;gt;
        AND title like #{title}
    &amp;lt;/if&amp;gt;
    &amp;lt;if test=&amp;quot;author != null and author.name != null&amp;quot;&amp;gt;
        AND author_name like #{author.name}
    &amp;lt;/if&amp;gt;
  &amp;lt;/where&amp;gt;
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;where&lt;/em&gt; 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，&lt;em&gt;where&lt;/em&gt; 元素也会将它们去除。&lt;/p&gt;
&lt;p&gt;如果 &lt;em&gt;where&lt;/em&gt; 元素与你期望的不太一样，你也可以通过自定义 trim 元素来定制 &lt;em&gt;where&lt;/em&gt; 元素的功能。比如，和 &lt;em&gt;where&lt;/em&gt; 元素等价的自定义 trim 元素为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;trim prefix=&amp;quot;WHERE&amp;quot; prefixOverrides=&amp;quot;AND |OR &amp;quot;&amp;gt;
  ...
&amp;lt;/trim&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;prefixOverrides&lt;/em&gt; 属性会忽略通过管道符分隔的文本序列（注意此例中的空格是必要的）。上述例子会移除所有 &lt;em&gt;prefixOverrides&lt;/em&gt; 属性中指定的内容，并且插入 &lt;em&gt;prefix&lt;/em&gt; 属性中指定的内容。&lt;/p&gt;
&lt;p&gt;用于动态更新语句的类似解决方案叫做 &lt;em&gt;set&lt;/em&gt;。&lt;em&gt;set&lt;/em&gt; 元素可以用于动态包含需要更新的列，忽略其它不更新的列。比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;update id=&amp;quot;updateAuthorIfNecessary&amp;quot;&amp;gt;
  update Author
    &amp;lt;set&amp;gt;
      &amp;lt;if test=&amp;quot;username != null&amp;quot;&amp;gt;username=#{username},&amp;lt;/if&amp;gt;
      &amp;lt;if test=&amp;quot;password != null&amp;quot;&amp;gt;password=#{password},&amp;lt;/if&amp;gt;
      &amp;lt;if test=&amp;quot;email != null&amp;quot;&amp;gt;email=#{email},&amp;lt;/if&amp;gt;
      &amp;lt;if test=&amp;quot;bio != null&amp;quot;&amp;gt;bio=#{bio}&amp;lt;/if&amp;gt;
    &amp;lt;/set&amp;gt;
  where id=#{id}
&amp;lt;/update&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个例子中，&lt;em&gt;set&lt;/em&gt; 元素会动态地在行首插入 SET 关键字，并会删掉额外的逗号（这些逗号是在使用条件语句给列赋值时引入的）。&lt;/p&gt;
&lt;p&gt;来看看与 &lt;em&gt;set&lt;/em&gt; 元素等价的自定义 &lt;em&gt;trim&lt;/em&gt; 元素吧：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;trim prefix=&amp;quot;SET&amp;quot; suffixOverrides=&amp;quot;,&amp;quot;&amp;gt;
  ...
&amp;lt;/trim&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意，我们覆盖了后缀值设置，并且自定义了前缀值。&lt;/p&gt;
&lt;h3 id=&#34;foreach&#34;&gt;foreach&lt;/h3&gt;
&lt;p&gt;动态 SQL 的另一个常见使用场景是对集合进行遍历（尤其是在构建 IN 条件语句的时候）。比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;select id=&amp;quot;selectPostIn&amp;quot; resultType=&amp;quot;domain.blog.Post&amp;quot;&amp;gt;
  SELECT *
  FROM POST P
  WHERE ID in
  &amp;lt;foreach item=&amp;quot;item&amp;quot; index=&amp;quot;index&amp;quot; collection=&amp;quot;list&amp;quot;
      open=&amp;quot;(&amp;quot; separator=&amp;quot;,&amp;quot; close=&amp;quot;)&amp;quot;&amp;gt;
        #{item}
  &amp;lt;/foreach&amp;gt;
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;foreach&lt;/em&gt; 元素的功能非常强大，它允许你指定一个集合，声明可以在元素体内使用的集合项（item）和索引（index）变量。它也允许你指定开头与结尾的字符串以及集合项迭代之间的分隔符。这个元素也不会错误地添加多余的分隔符，看它多智能！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提示&lt;/strong&gt; 你可以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象作为集合参数传递给 &lt;em&gt;foreach&lt;/em&gt;。当使用可迭代对象或者数组时，index 是当前迭代的序号，item 的值是本次迭代获取到的元素。当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值。&lt;/p&gt;
&lt;p&gt;至此，我们已经完成了与 XML 配置及映射文件相关的讨论。下一章将详细探讨 Java API，以便你能充分利用已经创建的映射配置。&lt;/p&gt;
&lt;h3 id=&#34;script&#34;&gt;script&lt;/h3&gt;
&lt;p&gt;要在带注解的映射器接口类中使用动态 SQL，可以使用 &lt;em&gt;script&lt;/em&gt; 元素。比如:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    @Update({&amp;quot;&amp;lt;script&amp;gt;&amp;quot;,
      &amp;quot;update Author&amp;quot;,
      &amp;quot;  &amp;lt;set&amp;gt;&amp;quot;,
      &amp;quot;    &amp;lt;if test=&#39;username != null&#39;&amp;gt;username=#{username},&amp;lt;/if&amp;gt;&amp;quot;,
      &amp;quot;    &amp;lt;if test=&#39;password != null&#39;&amp;gt;password=#{password},&amp;lt;/if&amp;gt;&amp;quot;,
      &amp;quot;    &amp;lt;if test=&#39;email != null&#39;&amp;gt;email=#{email},&amp;lt;/if&amp;gt;&amp;quot;,
      &amp;quot;    &amp;lt;if test=&#39;bio != null&#39;&amp;gt;bio=#{bio}&amp;lt;/if&amp;gt;&amp;quot;,
      &amp;quot;  &amp;lt;/set&amp;gt;&amp;quot;,
      &amp;quot;where id=#{id}&amp;quot;,
      &amp;quot;&amp;lt;/script&amp;gt;&amp;quot;})
    void updateAuthorValues(Author author);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;bind&#34;&gt;bind&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;bind&lt;/code&gt; 元素允许你在 OGNL 表达式以外创建一个变量，并将其绑定到当前的上下文。比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;select id=&amp;quot;selectBlogsLike&amp;quot; resultType=&amp;quot;Blog&amp;quot;&amp;gt;
  &amp;lt;bind name=&amp;quot;pattern&amp;quot; value=&amp;quot;&#39;%&#39; + _parameter.getTitle() + &#39;%&#39;&amp;quot; /&amp;gt;
  SELECT * FROM BLOG
  WHERE title LIKE #{pattern}
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;多数据库支持&#34;&gt;多数据库支持&lt;/h3&gt;
&lt;p&gt;如果配置了 databaseIdProvider，你就可以在动态代码中使用名为 “_databaseId” 的变量来为不同的数据库构建特定的语句。比如下面的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;insert id=&amp;quot;insert&amp;quot;&amp;gt;
  &amp;lt;selectKey keyProperty=&amp;quot;id&amp;quot; resultType=&amp;quot;int&amp;quot; order=&amp;quot;BEFORE&amp;quot;&amp;gt;
    &amp;lt;if test=&amp;quot;_databaseId == &#39;oracle&#39;&amp;quot;&amp;gt;
      select seq_users.nextval from dual
    &amp;lt;/if&amp;gt;
    &amp;lt;if test=&amp;quot;_databaseId == &#39;db2&#39;&amp;quot;&amp;gt;
      select nextval for seq_users from sysibm.sysdummy1&amp;quot;
    &amp;lt;/if&amp;gt;
  &amp;lt;/selectKey&amp;gt;
  insert into users values (#{id}, #{name})
&amp;lt;/insert&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;动态-sql-中的插入脚本语言&#34;&gt;动态 SQL 中的插入脚本语言&lt;/h3&gt;
&lt;p&gt;MyBatis 从 3.2 版本开始支持插入脚本语言，这允许你插入一种语言驱动，并基于这种语言来编写动态 SQL 查询语句。&lt;/p&gt;
&lt;p&gt;可以通过实现以下接口来插入一种语言：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface LanguageDriver {
  ParameterHandler createParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql);
  SqlSource createSqlSource(Configuration configuration, XNode script, Class&amp;lt;?&amp;gt; parameterType);
  SqlSource createSqlSource(Configuration configuration, String script, Class&amp;lt;?&amp;gt; parameterType);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实现自定义语言驱动后，你就可以在 mybatis-config.xml 文件中将它设置为默认语言：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;typeAliases&amp;gt;
  &amp;lt;typeAlias type=&amp;quot;org.sample.MyLanguageDriver&amp;quot; alias=&amp;quot;myLanguage&amp;quot;/&amp;gt;
&amp;lt;/typeAliases&amp;gt;
&amp;lt;settings&amp;gt;
  &amp;lt;setting name=&amp;quot;defaultScriptingLanguage&amp;quot; value=&amp;quot;myLanguage&amp;quot;/&amp;gt;
&amp;lt;/settings&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者，你也可以使用 &lt;code&gt;lang&lt;/code&gt; 属性为特定的语句指定语言：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;select id=&amp;quot;selectBlog&amp;quot; lang=&amp;quot;myLanguage&amp;quot;&amp;gt;
  SELECT * FROM BLOG
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者，在你的 mapper 接口上添加 &lt;code&gt;@Lang&lt;/code&gt; 注解：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface Mapper {
  @Lang(MyLanguageDriver.class)
  @Select(&amp;quot;SELECT * FROM BLOG&amp;quot;)
  List&amp;lt;Blog&amp;gt; selectBlog();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;提示&lt;/strong&gt; 可以使用 Apache Velocity 作为动态语言，更多细节请参考 MyBatis-Velocity 项目。&lt;/p&gt;
&lt;p&gt;你前面看到的所有 xml 标签都由默认 MyBatis 语言提供，而它由语言驱动 &lt;code&gt;org.apache.ibatis.scripting.xmltags.XmlLanguageDriver&lt;/code&gt;（别名为 &lt;code&gt;xml&lt;/code&gt;）所提供。&lt;/p&gt;
">Mybatis动态SQL</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://https://chenm0.github.io/post/leetcode-sql/"" data-c="
          &lt;h2 id=&#34;1-组合两个表&#34;&gt;1. 组合两个表&lt;/h2&gt;
&lt;p&gt;表1: Person&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+-------------+---------+

| 列名         | 类型     |

+-------------+---------+

| PersonId    | int     |

| FirstName   | varchar |

| LastName    | varchar |

+-------------+---------+

PersonId 是上表主键
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;表2: &lt;code&gt;Address&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+-------------+---------+
| 列名         | 类型    |
+-------------+---------+
| AddressId   | int     |
| PersonId    | int     |
| City        | varchar |
| State       | varchar |
+-------------+---------+
AddressId 是上表主键
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FirstName, LastName, City, State
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;解答&#34;&gt;解答&lt;/h3&gt;
&lt;h5 id=&#34;思路&#34;&gt;思路:&lt;/h5&gt;
&lt;p&gt;根据题目要求得知,需要查询的为Person表的FirstName,LastName和Address表的City,State字段,以Person表为主表,Address表的PersonId为外键进行查询,可保证无论Address表中是否有关联的值,Person表都能展示其信息。&lt;/p&gt;
&lt;h5 id=&#34;答案&#34;&gt;答案：&lt;/h5&gt;
&lt;p&gt;SELECT p.FirstName,p.LastName,a.City,a.State FROM Person p left join Address a  on  p.PersonId = a.PersonId&lt;/p&gt;
&lt;h5 id=&#34;重点&#34;&gt;&lt;strong&gt;重点：&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;连表查询中，主表的内容都会被展示&lt;/p&gt;
&lt;h2 id=&#34;2第二高的薪水&#34;&gt;2.第二高的薪水&lt;/h2&gt;
&lt;p&gt;编写一个 SQL 查询，获取 &lt;code&gt;Employee&lt;/code&gt; 表中第二高的薪水（Salary） 。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+----+--------+
| Id | Salary |
+----+--------+
| 1  | 100    |
| 2  | 200    |
| 3  | 300    |
+----+--------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例如上述 &lt;code&gt;Employee&lt;/code&gt; 表，SQL查询应该返回 &lt;code&gt;200&lt;/code&gt; 作为第二高的薪水。如果不存在第二高的薪水，那么查询应返回 &lt;code&gt;null&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+---------------------+
| SecondHighestSalary |
+---------------------+
| 200                 |
+---------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;解答-2&#34;&gt;解答&lt;/h3&gt;
&lt;h5 id=&#34;思路-2&#34;&gt;思路：&lt;/h5&gt;
&lt;p&gt;审题发现几个本题重要的考点：&lt;/p&gt;
&lt;p&gt;1.获取第二高的薪水，需要掌握orderby和limit的使用，‘第二高’ 是降序的排序方式，所以需要使用order by  。。 desc。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 			limit y 分句表示: 读取 y 条数据
	  	limit x, y 分句表示: 跳过 x 条数据，读取 y 条数据
      limit y offset x 分句表示: 跳过 x 条数据，读取 y 条数据
      limit n 等价于 limit 0,n
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.其次需要考虑特殊情况，首先需要去重同样的salary，其次就是如果不存在第二高的薪水，结果应为null，可以有两种解决方式：一种是用临时表，还有一种就是使用IFNULL函数。&lt;/p&gt;
&lt;h5 id=&#34;答案-2&#34;&gt;答案：&lt;/h5&gt;
&lt;p&gt;select IFNULL((select distinct Salary from Employee order by Salary desc limit 1,1),null) as SecondHighestSalary;&lt;/p&gt;
&lt;h5 id=&#34;重点-2&#34;&gt;&lt;strong&gt;重点&lt;/strong&gt;：&lt;/h5&gt;
&lt;p&gt;1.limit的使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	  	limit y 分句表示: 读取 y 条数据
	  	limit x, y 分句表示: 跳过 x 条数据，读取 y 条数据
      limit y offset x 分句表示: 跳过 x 条数据，读取 y 条数据
      limit n 等价于 limit 0,n
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.IFNULL和临时表判空的方式&lt;/p&gt;
&lt;h2 id=&#34;3第n高的薪水&#34;&gt;3.第N高的薪水&lt;/h2&gt;
&lt;p&gt;编写一个 SQL 查询，获取 &lt;code&gt;Employee&lt;/code&gt; 表中第 &lt;em&gt;n&lt;/em&gt; 高的薪水（Salary）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+----+--------+
| Id | Salary |
+----+--------+
| 1  | 100    |
| 2  | 200    |
| 3  | 300    |
+----+--------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例如上述 &lt;code&gt;Employee&lt;/code&gt; 表，&lt;em&gt;n = 2&lt;/em&gt; 时，应返回第二高的薪水 &lt;code&gt;200&lt;/code&gt;。如果不存在第 &lt;em&gt;n&lt;/em&gt; 高的薪水，那么查询应返回 &lt;code&gt;null&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+------------------------+
| getNthHighestSalary(2) |
+------------------------+
| 200                    |
+------------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;解答-3&#34;&gt;&lt;strong&gt;解答&lt;/strong&gt;&lt;/h3&gt;
&lt;h5 id=&#34;思路-3&#34;&gt;&lt;strong&gt;思路:&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;首先对存储过程的语法进行了基本的了解，题目的要求和上一题基本相同，但需要查的位置变成了变量，所以需要在limit后用变量选择跳过的个数&lt;/p&gt;
&lt;h5 id=&#34;答案-3&#34;&gt;&lt;strong&gt;答案：&lt;/strong&gt;&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT

BEGIN

  set N = N - 1;

  RETURN (

​      \# Write your MySQL query statement below.

​      SELECT IFNULl((SELECT distinct Salary from Employee order by Salary desc limit N,1),null)

  );

END
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;重点-3&#34;&gt;&lt;strong&gt;重点：&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;1.存储结构的基础语法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create procedure sp_name()
begin
.........
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.limit后不能进行运算，所以应该在begin前就将需要跳过的数算好，这里需要跳过的数应为需要查到的位数-1&lt;/p&gt;
&lt;h2 id=&#34;4分数排名&#34;&gt;4.分数排名&lt;/h2&gt;
&lt;p&gt;编写一个 SQL 查询来实现分数排名。&lt;/p&gt;
&lt;p&gt;如果两个分数相同，则两个分数排名（Rank）相同。请注意，平分后的下一个名次应该是下一个连续的整数值。换句话说，名次之间不应该有“间隔”。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+----+-------+
| Id | Score |
+----+-------+
| 1  | 3.50  |
| 2  | 3.65  |
| 3  | 4.00  |
| 4  | 3.85  |
| 5  | 4.00  |
| 6  | 3.65  |
+----+-------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例如，根据上述给定的 &lt;code&gt;Scores&lt;/code&gt; 表，你的查询应该返回（按分数从高到低排列）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+-------+------+
| Score | Rank |
+-------+------+
| 4.00  | 1    |
| 4.00  | 1    |
| 3.85  | 2    |
| 3.65  | 3    |
| 3.65  | 3    |
| 3.50  | 4    |
+-------+------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;解答-4&#34;&gt;&lt;strong&gt;解答&lt;/strong&gt;&lt;/h3&gt;
&lt;h5 id=&#34;思路-4&#34;&gt;&lt;strong&gt;思路:&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;回答此题的前提是需要了解sql的四大排名函数，审题得知，我们需要根据分数的大小降序排列后，对分数进行排名且名次之间无间隔，所以在四大排名函数中应选择&lt;strong&gt;DENSE_RANK()&lt;/strong&gt;。&lt;/p&gt;
&lt;h5 id=&#34;答案-4&#34;&gt;&lt;strong&gt;答案:&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;select Score,DENSE_RANK() over (order by Score DESC) &#39;Rank&#39; from Scores;&lt;/p&gt;
&lt;h5 id=&#34;重点-4&#34;&gt;&lt;strong&gt;重点:&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;1.sql的四大排名函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;​    ROW_NUMBER()      ----- 每条数据加一个序号，不适合排名，更加适合分页功能&lt;/li&gt;
&lt;li&gt;​    RANK()              ---- 排名序号可重复，之后按总数算&lt;/li&gt;
&lt;li&gt;​    DENSE_RANK()        ---- 排名序号可重复，之后按序号的后一个继续&lt;/li&gt;
&lt;li&gt;​    NTILE()       ----将有序分区中的行分发到指定数目的组中，各个组有编号，分为几个区，一个区会有多少个。&lt;br&gt;
​    所以，按照题目要求，应采取DENSE_RANK()无间隔的排名函数&lt;br&gt;
2.对于 MySQL 解决方案，如果要转义用作列名的保留字，可以在关键字之前和之后使用撇号。例如 &lt;code&gt;Rank&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;5连续出现的数字&#34;&gt;5.连续出现的数字&lt;/h2&gt;
&lt;p&gt;表：&lt;code&gt;Logs&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| id          | int     |
| num         | varchar |
+-------------+---------+
id 是这个表的主键。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编写一个 SQL 查询，查找所有至少连续出现三次的数字。&lt;/p&gt;
&lt;p&gt;返回的结果表中的数据可以按 &lt;strong&gt;任意顺序&lt;/strong&gt; 排列。&lt;/p&gt;
&lt;p&gt;查询结果格式如下面的例子所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Logs 表：
+----+-----+
| Id | Num |
+----+-----+
| 1  | 1   |
| 2  | 1   |
| 3  | 1   |
| 4  | 2   |
| 5  | 1   |
| 6  | 2   |
| 7  | 2   |
+----+-----+

Result 表：
+-----------------+
| ConsecutiveNums |
+-----------------+
| 1               |
+-----------------+
1 是唯一连续出现至少三次的数字。


&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;解答-5&#34;&gt;&lt;strong&gt;解答&lt;/strong&gt;&lt;/h3&gt;
&lt;h5 id=&#34;思路-5&#34;&gt;&lt;strong&gt;思路:&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;本题根据题目要求，需查询出连续出现至少三次的同一个数字，所以distinct函数是一定需要使用的；三次同一个数字的id分别为id，id+1，id+2，而num是相同的，所以需要两个子查询作为筛选条件&lt;/p&gt;
&lt;h5 id=&#34;答案-5&#34;&gt;&lt;strong&gt;答案:&lt;/strong&gt;&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;select distinct Num as ConsecutiveNums from Logs where (Id+1,Num) in (select * from Logs) and (Id+2,Num) in (select * from Logs)
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;重点-5&#34;&gt;&lt;strong&gt;重点:&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;活用子查询&lt;/p&gt;
&lt;h2 id=&#34;6超过经理收入的员工&#34;&gt;6.超过经理收入的员工&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Employee&lt;/code&gt; 表包含所有员工，他们的经理也属于员工。每个员工都有一个 Id，此外还有一列对应员工的经理的 Id。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+----+-------+--------+-----------+
| Id | Name  | Salary | ManagerId |
+----+-------+--------+-----------+
| 1  | Joe   | 70000  | 3         |
| 2  | Henry | 80000  | 4         |
| 3  | Sam   | 60000  | NULL      |
| 4  | Max   | 90000  | NULL      |
+----+-------+--------+-----------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;给定 &lt;code&gt;Employee&lt;/code&gt; 表，编写一个 SQL 查询，该查询可以获取收入超过他们经理的员工的姓名。在上面的表格中，Joe 是唯一一个收入超过他的经理的员工。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+----------+
| Employee |
+----------+
| Joe      |
+----------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;解答-6&#34;&gt;&lt;strong&gt;解答&lt;/strong&gt;&lt;/h3&gt;
&lt;h5 id=&#34;思路-6&#34;&gt;&lt;strong&gt;思路:&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;本题需要使用子链接或自链接&lt;/p&gt;
&lt;h5 id=&#34;答案-6&#34;&gt;&lt;strong&gt;答案：&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;子链接：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select a.Name as Employee from Employee a where a.Salary &amp;gt; 

(select b.Salary from Employee b where b.Id = a.ManagerId) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;自链接：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select a.Name as Employee from Employee a join Employee b where b.id = a.ManagerId and b.Salary &amp;lt; a.Salary
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;重点-6&#34;&gt;&lt;strong&gt;重点：&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;加强自链接和子链接的使用&lt;/p&gt;
&lt;h2 id=&#34;7查找重复的电子邮箱&#34;&gt;7.查找重复的电子邮箱&lt;/h2&gt;
&lt;p&gt;编写一个 SQL 查询，查找 &lt;code&gt;Person&lt;/code&gt; 表中所有重复的电子邮箱。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+----+---------+
| Id | Email   |
+----+---------+
| 1  | a@b.com |
| 2  | c@d.com |
| 3  | a@b.com |
+----+---------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根据以上输入，你的查询应返回以下结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+---------+
| Email   |
+---------+
| a@b.com |
+---------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;**说明：**所有电子邮箱都是小写字母。&lt;/p&gt;
&lt;h3 id=&#34;解答-7&#34;&gt;&lt;strong&gt;解答&lt;/strong&gt;&lt;/h3&gt;
&lt;h5 id=&#34;思路-7&#34;&gt;&lt;strong&gt;思路:&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;需要使用group by将结果集归类，然后使用count函数判断是否重复&lt;/p&gt;
&lt;h5 id=&#34;答案-7&#34;&gt;&lt;strong&gt;答案:&lt;/strong&gt;&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;select Email from Person group by Email having count(Email) &amp;gt; 1
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;重点-7&#34;&gt;&lt;strong&gt;重点:&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;group by...having和计数函数的使用&lt;/p&gt;
&lt;h2 id=&#34;8从不订购的客户&#34;&gt;8.从不订购的客户&lt;/h2&gt;
&lt;p&gt;某网站包含两个表，Customers 表和 Orders 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Customers&lt;/code&gt; 表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+----+-------+
| Id | Name  |
+----+-------+
| 1  | Joe   |
| 2  | Henry |
| 3  | Sam   |
| 4  | Max   |
+----+-------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Orders&lt;/code&gt; 表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+----+------------+
| Id | CustomerId |
+----+------------+
| 1  | 3          |
| 2  | 1          |
+----+------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例如给定上述表格，你的查询应返回：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+-----------+
| Customers |
+-----------+
| Henry     |
| Max       |
+-----------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;解答-8&#34;&gt;&lt;strong&gt;解答&lt;/strong&gt;&lt;/h3&gt;
&lt;h5 id=&#34;思路-8&#34;&gt;&lt;strong&gt;思路:&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;首先需要连表进行查询，然后需要使用子查询筛选结果&lt;/p&gt;
&lt;h5 id=&#34;答案-8&#34;&gt;&lt;strong&gt;答案:&lt;/strong&gt;&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;select c.Name as Customers from Orders o right join Customers c on c.id = o.CustomerId where c.Id not in (select CustomerId from Orders)
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;重点-8&#34;&gt;&lt;strong&gt;重点:&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;注意关联查询配合子查询&lt;/p&gt;
&lt;h2 id=&#34;9部门工资最高的员工&#34;&gt;9.部门工资最高的员工&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Employee&lt;/code&gt; 表包含所有员工信息，每个员工有其对应的 Id, salary 和 department Id。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+----+-------+--------+--------------+
| Id | Name  | Salary | DepartmentId |
+----+-------+--------+--------------+
| 1  | Joe   | 70000  | 1            |
| 2  | Jim   | 90000  | 1            |
| 3  | Henry | 80000  | 2            |
| 4  | Sam   | 60000  | 2            |
| 5  | Max   | 90000  | 1            |
+----+-------+--------+--------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Department&lt;/code&gt; 表包含公司所有部门的信息。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+----+----------+
| Id | Name     |
+----+----------+
| 1  | IT       |
| 2  | Sales    |
+----+----------+

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编写一个 SQL 查询，找出每个部门工资最高的员工。对于上述表，您的 SQL 查询应返回以下行（行的顺序无关紧要）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+------------+----------+--------+
| Department | Employee | Salary |
+------------+----------+--------+
| IT         | Max      | 90000  |
| IT         | Jim      | 90000  |
| Sales      | Henry    | 80000  |
+------------+----------+--------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;解释：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Max 和 Jim 在 IT 部门的工资都是最高的，Henry 在销售部的工资最高。&lt;/p&gt;
&lt;h3 id=&#34;解答-9&#34;&gt;&lt;strong&gt;解答&lt;/strong&gt;&lt;/h3&gt;
&lt;h5 id=&#34;思路-9&#34;&gt;&lt;strong&gt;思路:&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;需要应用子查询构建一个临时表，临时表中使用分区和**DENSE_RANK()**函数（因为有并列的情况）进行排序，然后在外层根据排序的序号查询排名第一的结果&lt;/p&gt;
&lt;h5 id=&#34;答案-9&#34;&gt;&lt;strong&gt;答案:&lt;/strong&gt;&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;SELECT s.Department,s.Employee,s.Salary from 
(SELECT
    d.Name as Department,e.Name as Employee,e.Salary as Salary, DENSE_RANK() over (Partition by DepartmentID order by Salary DESC) as rn
    FROM
        Employee e join Department d on e.DepartmentID = d.Id) s
where s.rn = 1
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;重点-9&#34;&gt;&lt;strong&gt;重点:&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;1.Partition by 和 group by的区别&lt;br&gt;
1. group by是分组函数，partition by是分析函数（然后像sum()等是聚合函数）；&lt;br&gt;
2. 在执行顺序上，&lt;br&gt;
以下是常用sql关键字的优先级&lt;br&gt;
&lt;mark&gt;from &amp;gt; where &amp;gt; group by &amp;gt; having &amp;gt; order by&lt;/mark&gt;&lt;br&gt;
而partition by应用在以上关键字之后，实际上就是在执行完select之后，在所得结果集之上进行partition。&lt;br&gt;
3. partition by相比较于group by，能够在保留全部数据的基础上，只对其中某些字段做分组排序（类似excel中的操作），而group by则只保留参与分组的字段和聚合函数的结果（类似excel中的pivot）&lt;br&gt;
4. 如果在partition结果上聚合，千万注意聚合函数是逐条累计运行结果的！而在group by后的结果集上使用聚合函数，会作用在分组下的所有记录上。&lt;br&gt;
2.活用自查询&lt;/p&gt;
&lt;h2 id=&#34;10部门工资前三高的所有员工&#34;&gt;10.部门工资前三高的所有员工&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Employee&lt;/code&gt; 表包含所有员工信息，每个员工有其对应的工号 &lt;code&gt;Id&lt;/code&gt;，姓名 &lt;code&gt;Name&lt;/code&gt;，工资 &lt;code&gt;Salary&lt;/code&gt; 和部门编号 &lt;code&gt;DepartmentId&lt;/code&gt; 。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+----+-------+--------+--------------+
| Id | Name  | Salary | DepartmentId |
+----+-------+--------+--------------+
| 1  | Joe   | 85000  | 1            |
| 2  | Henry | 80000  | 2            |
| 3  | Sam   | 60000  | 2            |
| 4  | Max   | 90000  | 1            |
| 5  | Janet | 69000  | 1            |
| 6  | Randy | 85000  | 1            |
| 7  | Will  | 70000  | 1            |
+----+-------+--------+--------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Department&lt;/code&gt; 表包含公司所有部门的信息。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+----+----------+
| Id | Name     |
+----+----------+
| 1  | IT       |
| 2  | Sales    |
+----+----------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编写一个 SQL 查询，找出每个部门获得前三高工资的所有员工。例如，根据上述给定的表，查询结果应返回：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+------------+----------+--------+
| Department | Employee | Salary |
+------------+----------+--------+
| IT         | Max      | 90000  |
| IT         | Randy    | 85000  |
| IT         | Joe      | 85000  |
| IT         | Will     | 70000  |
| Sales      | Henry    | 80000  |
| Sales      | Sam      | 60000  |
+------------+----------+--------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;解释：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;IT 部门中，Max 获得了最高的工资，Randy 和 Joe 都拿到了第二高的工资，Will 的工资排第三。销售部门（Sales）只有两名员工，Henry 的工资最高，Sam 的工资排第二。&lt;/p&gt;
&lt;h3 id=&#34;解答-10&#34;&gt;&lt;strong&gt;解答&lt;/strong&gt;&lt;/h3&gt;
&lt;h5 id=&#34;思路-10&#34;&gt;&lt;strong&gt;思路:&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;根据上题的一道扩展问题，可延续上题思路，更改排序的筛选条件&lt;/p&gt;
&lt;h5 id=&#34;答案-10&#34;&gt;&lt;strong&gt;答案:&lt;/strong&gt;&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;SELECT s.Department,s.Employee,S.Salary from 

(SELECT

​    d.Name as Department,e.Name as Employee,e.Salary as Salary, e.DepartmentId as did,DENSE_RANK() over (Partition by DepartmentID order by Salary DESC) as rn

​    FROM

​        Employee e join Department d on e.DepartmentID = d.Id) s

where s.rn &amp;lt;= 3 order by s.did asc,S.Salary DESC
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;重点-10&#34;&gt;&lt;strong&gt;重点:&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;主要思路延续上一题&lt;/p&gt;
&lt;h2 id=&#34;11-删除重复的电子邮箱&#34;&gt;11. 删除重复的电子邮箱&lt;/h2&gt;
&lt;p&gt;编写一个 SQL 查询，来删除 Person 表中所有重复的电子邮箱，重复的邮箱里只保留 Id 最小 的那个。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+----+------------------+
| Id | Email            |
+----+------------------+
| 1  | john@example.com |
| 2  | bob@example.com  |
| 3  | john@example.com |
+----+------------------+
Id 是这个表的主键。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例如，在运行你的查询语句之后，上面的 Person 表应返回以下几行:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+----+------------------+
| Id | Email            |
+----+------------------+
| 1  | john@example.com |
| 2  | bob@example.com  |
+----+------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;执行 SQL 之后，输出是整个 Person 表。&lt;/li&gt;
&lt;li&gt;使用 delete 语句。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;解答-11&#34;&gt;&lt;strong&gt;解答&lt;/strong&gt;&lt;/h3&gt;
&lt;h5 id=&#34;思路-11&#34;&gt;&lt;strong&gt;思路:&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;使用自链接筛选比较结果进行删除&lt;/p&gt;
&lt;h5 id=&#34;答案-11&#34;&gt;&lt;strong&gt;答案:&lt;/strong&gt;&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;delete p1 from Person p1 join Person p2 on p1.Email = p2.Email where p1.Id &amp;gt; p2.Id
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;重点-11&#34;&gt;&lt;strong&gt;重点:&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;活用自链接&lt;/p&gt;
&lt;h2 id=&#34;12上升的温度&#34;&gt;12.上升的温度&lt;/h2&gt;
&lt;p&gt;表 Weather&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| id            | int     |
| recordDate    | date    |
| temperature   | int     |
+---------------+---------+
id 是这个表的主键
该表包含特定日期的温度信息
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编写一个 SQL 查询，来查找与之前（昨天的）日期相比温度更高的所有日期的 id 。&lt;br&gt;
返回结果 不要求顺序 。&lt;br&gt;
查询结果格式如下例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Weather
+----+------------+-------------+
| id | recordDate | Temperature |
+----+------------+-------------+
| 1  | 2015-01-01 | 10          |
| 2  | 2015-01-02 | 25          |
| 3  | 2015-01-03 | 20          |
| 4  | 2015-01-04 | 30          |
+----+------------+-------------+

Result table:
+----+
| id |
+----+
| 2  |
| 4  |
+----+
2015-01-02 的温度比前一天高（10 -&amp;gt; 25）
2015-01-04 的温度比前一天高（20 -&amp;gt; 30）
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;解答-12&#34;&gt;&lt;strong&gt;解答&lt;/strong&gt;&lt;/h3&gt;
&lt;h5 id=&#34;思路-12&#34;&gt;&lt;strong&gt;思路:&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;这里需要使用datediff函数来判断前一天，== datediff(日期1, 日期2)： 得到的结果是日期1与日期2相差的天数。 如果日期1比日期2大，结果为正；如果日期1比日期2小，结果为负。==&lt;/p&gt;
&lt;h5 id=&#34;答案-12&#34;&gt;&lt;strong&gt;答案:&lt;/strong&gt;&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;select w1.id from Weather w1,Weather w2 where w1.Temperature &amp;gt; w2.Temperature and datediff(w1.recordDate,w2.recordDate) = 1
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;重点-12&#34;&gt;&lt;strong&gt;重点:&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;== datediff(日期1, 日期2)： 得到的结果是日期1与日期2相差的天数。 如果日期1比日期2大，结果为正；如果日期1比日期2小，结果为负。==&lt;/p&gt;
&lt;h2 id=&#34;13大的国家&#34;&gt;13.大的国家&lt;/h2&gt;
&lt;p&gt;这里有张 World 表&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+-----------------+------------+------------+--------------+---------------+
| name            | continent  | area       | population   | gdp           |
+-----------------+------------+------------+--------------+---------------+
| Afghanistan     | Asia       | 652230     | 25500100     | 20343000      |
| Albania         | Europe     | 28748      | 2831741      | 12960000      |
| Algeria         | Africa     | 2381741    | 37100000     | 188681000     |
| Andorra         | Europe     | 468        | 78115        | 3712000       |
| Angola          | Africa     | 1246700    | 20609294     | 100990000     |
+-----------------+------------+------------+--------------+---------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果一个国家的面积超过 300 万平方公里，或者人口超过 2500 万，那么这个国家就是大国家。&lt;br&gt;
编写一个 SQL 查询，输出表中所有大国家的名称、人口和面积。&lt;br&gt;
例如，根据上表，我们应该输出:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+--------------+-------------+--------------+
| name         | population  | area         |
+--------------+-------------+--------------+
| Afghanistan  | 25500100    | 652230       |
| Algeria      | 37100000    | 2381741      |
+--------------+-------------+--------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;解答-13&#34;&gt;&lt;strong&gt;解答&lt;/strong&gt;&lt;/h3&gt;
&lt;h5 id=&#34;思路-13&#34;&gt;&lt;strong&gt;思路:&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;此题比较简单，使用or进行筛选即可&lt;/p&gt;
&lt;h5 id=&#34;答案-13&#34;&gt;&lt;strong&gt;答案:&lt;/strong&gt;&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;select name,population,area from World where area &amp;gt; 3000000 or population &amp;gt; 25000000
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;重点-13&#34;&gt;&lt;strong&gt;重点:&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;or的使用方式&lt;/p&gt;
&lt;h2 id=&#34;14-超过5名学生的课&#34;&gt;14. 超过5名学生的课&lt;/h2&gt;
&lt;p&gt;有一个courses 表 ，有: student (学生) 和 class (课程)。&lt;br&gt;
请列出所有超过或等于5名学生的课。&lt;br&gt;
例如，表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+---------+------------+
| student | class      |
+---------+------------+
| A       | Math       |
| B       | English    |
| C       | Math       |
| D       | Biology    |
| E       | Math       |
| F       | Computer   |
| G       | Math       |
| H       | Math       |
| I       | Math       |
+---------+------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;应该输出:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+---------+
| class   |
+---------+
| Math    |
+---------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;学生在每个课中不应被重复计算。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;解答-14&#34;&gt;&lt;strong&gt;解答&lt;/strong&gt;&lt;/h3&gt;
&lt;h5 id=&#34;思路-14&#34;&gt;&lt;strong&gt;思路:&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;可使用子查询进行分组之后利用count筛选结果&lt;/p&gt;
&lt;h5 id=&#34;答案-14&#34;&gt;&lt;strong&gt;答案:&lt;/strong&gt;&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;select c.class from (select distinct * from courses) c group by c.class having count(c.class) &amp;gt;=5 
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;重点-14&#34;&gt;&lt;strong&gt;重点:&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;注意提示，需要进行去重操作&lt;/p&gt;
&lt;h2 id=&#34;15-有趣的电影&#34;&gt;15. 有趣的电影&lt;/h2&gt;
&lt;p&gt;某城市开了一家新的电影院，吸引了很多人过来看电影。该电影院特别注意用户体验，专门有个 LED显示板做电影推荐，上面公布着影评和相关电影描述。&lt;br&gt;
作为该电影院的信息部主管，您需要编写一个 SQL查询，找出所有影片描述为非 boring (不无聊) 的并且 id 为奇数 的影片，结果请按等级 rating 排列。&lt;br&gt;
例如，下表 cinema:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+---------+-----------+--------------+-----------+
|   id    | movie     |  description |  rating   |
+---------+-----------+--------------+-----------+
|   1     | War       |   great 3D   |   8.9     |
|   2     | Science   |   fiction    |   8.5     |
|   3     | irish     |   boring     |   6.2     |
|   4     | Ice song  |   Fantacy    |   8.6     |
|   5     | House card|   Interesting|   9.1     |
+---------+-----------+--------------+-----------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于上面的例子，则正确的输出是为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+---------+-----------+--------------+-----------+
|   id    | movie     |  description |  rating   |
+---------+-----------+--------------+-----------+
|   5     | House card|   Interesting|   9.1     |
|   1     | War       |   great 3D   |   8.9     |
+---------+-----------+--------------+-----------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;解答-15&#34;&gt;&lt;strong&gt;解答&lt;/strong&gt;&lt;/h3&gt;
&lt;h5 id=&#34;思路-15&#34;&gt;&lt;strong&gt;思路:&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;奇数可以用取余不等于0的方式计算，“&amp;lt;&amp;gt;”代表的是不等于&lt;/p&gt;
&lt;h5 id=&#34;答案-15&#34;&gt;&lt;strong&gt;答案:&lt;/strong&gt;&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;select id,movie,description,rating from cinema where id % 2 &amp;lt;&amp;gt; 0 and description &amp;lt;&amp;gt; &#39;boring&#39; order by rating desc
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;重点-15&#34;&gt;&lt;strong&gt;重点:&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;奇数的算法和不等于符号&lt;/p&gt;
&lt;h2 id=&#34;16-换座位&#34;&gt;16. 换座位&lt;/h2&gt;
&lt;p&gt;小美是一所中学的信息科技老师，她有一张 seat 座位表，平时用来储存学生名字和与他们相对应的座位 id。&lt;br&gt;
其中纵列的 id 是连续递增的&lt;br&gt;
小美想改变相邻俩学生的座位。&lt;br&gt;
你能不能帮她写一个 SQL query 来输出小美想要的结果呢？&lt;br&gt;
示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+---------+---------+
|    id   | student |
+---------+---------+
|    1    | Abbot   |
|    2    | Doris   |
|    3    | Emerson |
|    4    | Green   |
|    5    | Jeames  |
+---------+---------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;假如数据输入的是上表，则输出结果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+---------+---------+
|    id   | student |
+---------+---------+
|    1    | Doris   |
|    2    | Abbot   |
|    3    | Green   |
|    4    | Emerson |
|    5    | Jeames  |
+---------+---------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：&lt;br&gt;
如果学生人数是奇数，则不需要改变最后一个同学的座位。&lt;/p&gt;
&lt;h3 id=&#34;解答-16&#34;&gt;&lt;strong&gt;解答&lt;/strong&gt;&lt;/h3&gt;
&lt;h5 id=&#34;思路-16&#34;&gt;&lt;strong&gt;思路:&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;此题涉及到异或运算符的使用，需要对异或运算符有所了解&lt;/p&gt;
&lt;h5 id=&#34;答案-16&#34;&gt;&lt;strong&gt;答案:&lt;/strong&gt;&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;select rank() over (order by ((id-1)^1)) as id,student from seat
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;重点-16&#34;&gt;&lt;strong&gt;重点:&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;^(位异或)的使用方式：&lt;br&gt;
上下运算,按照与的运算规则：0&amp;amp;0=0 ；0&amp;amp;1=1；1&amp;amp;1=0&lt;/p&gt;
&lt;h2 id=&#34;17-变更性别&#34;&gt;17. 变更性别&lt;/h2&gt;
&lt;p&gt;给定一个 salary 表，如下所示，有 m = 男性 和 f = 女性 的值。交换所有的 f 和 m 值（例如，将所有 f 值更改为 m，反之亦然）。要求只使用一个更新（Update）语句，并且没有中间的临时表。&lt;/p&gt;
&lt;p&gt;注意，您必只能写一个 Update 语句，请不要编写任何 Select 语句。&lt;br&gt;
例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;| id | name | sex | salary |
|----|------|-----|--------|
| 1  | A    | m   | 2500   |
| 2  | B    | f   | 1500   |
| 3  | C    | m   | 5500   |
| 4  | D    | f   | 500    |
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行你所编写的更新语句之后，将会得到以下表:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;| id | name | sex | salary |
|----|------|-----|--------|
| 1  | A    | f   | 2500   |
| 2  | B    | m   | 1500   |
| 3  | C    | f   | 5500   |
| 4  | D    | m   | 500    |
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;解答-17&#34;&gt;&lt;strong&gt;解答&lt;/strong&gt;&lt;/h3&gt;
&lt;h5 id=&#34;思路-17&#34;&gt;&lt;strong&gt;思路:&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;此题涉及到sql语句中的if用法&lt;/p&gt;
&lt;h5 id=&#34;答案-17&#34;&gt;&lt;strong&gt;答案:&lt;/strong&gt;&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;update salary set sex = if(sex = &#39;f&#39;,&#39;m&#39;,&#39;f&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;重点-17&#34;&gt;&lt;strong&gt;重点:&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;在sql的update语句中，if语句类似于三目运算符的作用&lt;/p&gt;
">Leetcode sql题个人题解方案</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://https://chenm0.github.io/post/maven-setting/"" data-c="
          &lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt; 
&lt;p&gt;&lt;settings xmlns=&#34;http://maven.apache.org/POM/4.0.0&#34; xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34; 
 xsi:schemaLocation=&#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&#34;&gt;&lt;/p&gt;
 &lt;!--本地仓库。该值表示构建系统本地仓库的路径。其默认值为~/.m2/repository。 --&gt; 
&lt;p&gt;&lt;localRepository&gt;usr/local/maven&lt;/localRepository&gt;&lt;/p&gt;
 &lt;!--Maven是否需要和用户交互以获得输入。如果Maven需要和用户交互以获得输入，则设置成true，反之则应为false。默认为true。--&gt; 
&lt;p&gt;&lt;interactiveMode&gt;true&lt;/interactiveMode&gt;&lt;/p&gt;
 &lt;!--Maven是否需要使用plugin-registry.xml文件来管理插件版本。如果需要让Maven使用文件~/.m2/plugin-registry.xml来管理插件版本，则设为true。默认为false。--&gt; 
&lt;p&gt;&lt;usePluginRegistry&gt;false&lt;/usePluginRegistry&gt;&lt;/p&gt;
 &lt;!--表示Maven是否需要在离线模式下运行。如果构建系统需要在离线模式下运行，则为true，默认为false。当由于网络设置原因或者安全因素，构建服务器不能连接远程仓库的时候，该配置就十分有用。 --&gt; 
&lt;p&gt;&lt;offline&gt;false&lt;/offline&gt;&lt;/p&gt;
 &lt;!--当插件的组织Id（groupId）没有显式提供时，供搜寻插件组织Id（groupId）的列表。该元素包含一个pluginGroup元素列表，每个子元素包含了一个组织Id（groupId）。当我们使用某个插件，并且没有在命令行为其提供组织Id（groupId）的时候，Maven就会使用该列表。默认情况下该列表包含了org.apache.maven.plugins。 --&gt; 
 &lt;pluginGroups&gt; 
 &lt;!--plugin的组织Id（groupId） --&gt; 
 &lt;pluginGroup&gt;org.codehaus.mojo&lt;/pluginGroup&gt; 
 &lt;/pluginGroups&gt; 
 &lt;!--用来配置不同的代理，多代理profiles 可以应对笔记本或移动设备的工作环境：通过简单的设置profile id就可以很容易的更换整个代理配置。 --&gt; 
 &lt;proxies&gt; 
 &lt;!--代理元素包含配置代理时需要的信息--&gt; 
 &lt;proxy&gt; 
 &lt;!--代理的唯一定义符，用来区分不同的代理元素。--&gt; 
 &lt;id&gt;myproxy&lt;/id&gt; 
 &lt;!--该代理是否是激活的那个。true则激活代理。当我们声明了一组代理，而某个时候只需要激活一个代理的时候，该元素就可以派上用处。 --&gt; 
 &lt;active&gt;true&lt;/active&gt; 
 &lt;!--代理的协议。 协议://主机名:端口，分隔成离散的元素以方便配置。--&gt; 
 &lt;protocol&gt;http&lt;/protocol&gt; 
 &lt;!--代理的主机名。协议://主机名:端口，分隔成离散的元素以方便配置。 --&gt; 
 &lt;host&gt;proxy.somewhere.com&lt;/host&gt; 
 &lt;!--代理的端口。协议://主机名:端口，分隔成离散的元素以方便配置。 --&gt; 
 &lt;port&gt;8080&lt;/port&gt; 
 &lt;!--代理的用户名，用户名和密码表示代理服务器认证的登录名和密码。 --&gt; 
 &lt;username&gt;proxyuser&lt;/username&gt; 
 &lt;!--代理的密码，用户名和密码表示代理服务器认证的登录名和密码。 --&gt; 
 &lt;password&gt;somepassword&lt;/password&gt; 
 &lt;!--不该被代理的主机名列表。该列表的分隔符由代理服务器指定；例子中使用了竖线分隔符，使用逗号分隔也很常见。--&gt; 
 &lt;nonProxyHosts&gt;*.google.com|ibiblio.org&lt;/nonProxyHosts&gt; 
 &lt;/proxy&gt; 
 &lt;/proxies&gt; 
 &lt;!--配置服务端的一些设置。一些设置如安全证书不应该和pom.xml一起分发。这种类型的信息应该存在于构建服务器上的settings.xml文件中。--&gt; 
 &lt;servers&gt; 
 &lt;!--服务器元素包含配置服务器时需要的信息 --&gt; 
 &lt;server&gt; 
 &lt;!--这是server的id（注意不是用户登陆的id），该id与distributionManagement中repository元素的id相匹配。--&gt; 
 &lt;id&gt;server001&lt;/id&gt; 
 &lt;!--鉴权用户名。鉴权用户名和鉴权密码表示服务器认证所需要的登录名和密码。 --&gt; 
 &lt;username&gt;my_login&lt;/username&gt; 
 &lt;!--鉴权密码 。鉴权用户名和鉴权密码表示服务器认证所需要的登录名和密码。 --&gt; 
 &lt;password&gt;my_password&lt;/password&gt; 
 &lt;!--鉴权时使用的私钥位置。和前两个元素类似，私钥位置和私钥密码指定了一个私钥的路径（默认是/home/hudson/.ssh/id_dsa）以及如果需要的话，一个密语。将来passphrase和password元素可能会被提取到外部，但目前它们必须在settings.xml文件以纯文本的形式声明。 --&gt; 
 &lt;privateKey&gt;${usr.home}/.ssh/id_dsa&lt;/privateKey&gt; 
 &lt;!--鉴权时使用的私钥密码。--&gt; 
 &lt;passphrase&gt;some_passphrase&lt;/passphrase&gt; 
 &lt;!--文件被创建时的权限。如果在部署的时候会创建一个仓库文件或者目录，这时候就可以使用权限（permission）。这两个元素合法的值是一个三位数字，其对应了unix文件系统的权限，如664，或者775。 --&gt; 
 &lt;filePermissions&gt;664&lt;/filePermissions&gt; 
 &lt;!--目录被创建时的权限。 --&gt; 
 &lt;directoryPermissions&gt;775&lt;/directoryPermissions&gt; 
 &lt;!--传输层额外的配置项 --&gt; 
 &lt;configuration&gt;&lt;/configuration&gt; 
 &lt;/server&gt; 
 &lt;/servers&gt; 
 &lt;!--为仓库列表配置的下载镜像列表。 --&gt; 
 &lt;mirrors&gt; 
 &lt;!--给定仓库的下载镜像。 --&gt; 
 &lt;mirror&gt; 
 &lt;!--该镜像的唯一标识符。id用来区分不同的mirror元素。 --&gt; 
 &lt;id&gt;planetmirror.com&lt;/id&gt; 
 &lt;!--镜像名称 --&gt; 
 &lt;name&gt;PlanetMirror Australia&lt;/name&gt; 
 &lt;!--该镜像的URL。构建系统会优先考虑使用该URL，而非使用默认的服务器URL。 --&gt; 
 &lt;url&gt;http://downloads.planetmirror.com/pub/maven2&lt;/url&gt; 
 &lt;!--被镜像的服务器的id。例如，如果我们要设置了一个Maven中央仓库（http://repo1.maven.org/maven2）的镜像，就需要将该元素设置成central。这必须和中央仓库的id central完全一致。--&gt; 
 &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; 
 &lt;/mirror&gt; 
 &lt;/mirrors&gt; 
 &lt;!--根据环境参数来调整构建配置的列表。settings.xml中的profile元素是pom.xml中profile元素的裁剪版本。它包含了id，activation, repositories, pluginRepositories和 properties元素。这里的profile元素只包含这五个子元素是因为这里只关心构建系统这个整体（这正是settings.xml文件的角色定位），而非单独的项目对象模型设置。如果一个settings中的profile被激活，它的值会覆盖任何其它定义在POM中或者profile.xml中的带有相同id的profile。 --&gt; 
 &lt;profiles&gt; 
 &lt;!--根据环境参数来调整的构件的配置--&gt; 
 &lt;profile&gt; 
 &lt;!--该配置的唯一标识符。 --&gt; 
 &lt;id&gt;test&lt;/id&gt; 
 &lt;!--自动触发profile的条件逻辑。Activation是profile的开启钥匙。如POM中的profile一样，profile的力量来自于它能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。activation元素并不是激活profile的唯一方式。settings.xml文件中的activeProfile元素可以包含profile的id。profile也可以通过在命令行，使用-P标记和逗号分隔的列表来显式的激活（如，-P test）。--&gt; 
 &lt;activation&gt; 
 &lt;!--profile默认是否激活的标识--&gt; 
 &lt;activeByDefault&gt;false&lt;/activeByDefault&gt; 
 &lt;!--当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。--&gt; 
 &lt;jdk&gt;1.5&lt;/jdk&gt; 
 &lt;!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。--&gt; 
 &lt;os&gt; 
 &lt;!--激活profile的操作系统的名字 --&gt; 
 &lt;name&gt;Windows XP&lt;/name&gt; 
 &lt;!--激活profile的操作系统所属家族(如 &#39;windows&#39;) --&gt; 
 &lt;family&gt;Windows&lt;/family&gt; 
 &lt;!--激活profile的操作系统体系结构 --&gt; 
 &lt;arch&gt;x86&lt;/arch&gt; 
 &lt;!--激活profile的操作系统版本--&gt; 
 &lt;version&gt;5.1.2600&lt;/version&gt; 
 &lt;/os&gt; 
 &lt;!--如果Maven检测到某一个属性（其值可以在POM中通过${名称}引用），其拥有对应的名称和值，Profile就会被激活。如果值字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段--&gt; 
 &lt;property&gt; 
 &lt;!--激活profile的属性的名称--&gt; 
 &lt;name&gt;mavenVersion&lt;/name&gt; 
 &lt;!--激活profile的属性的值 --&gt; 
 &lt;value&gt;2.0.3&lt;/value&gt; 
 &lt;/property&gt; 
 &lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。--&gt; 
 &lt;file&gt; 
 &lt;!--如果指定的文件存在，则激活profile。 --&gt; 
 &lt;exists&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/&lt;/exists&gt; 
 &lt;!--如果指定的文件不存在，则激活profile。--&gt; 
 &lt;missing&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/&lt;/missing&gt; 
 &lt;/file&gt; 
 &lt;/activation&gt; 
 &lt;!--对应profile的扩展属性列表。Maven属性和Ant中的属性一样，可以用来存放一些值。这些值可以在POM中的任何地方使用标记${X}来使用，这里X是指属性的名称。属性有五种不同的形式，并且都能在settings.xml文件中访问。 
 1. env.X: 在一个变量前加上&#34;env.&#34;的前缀，会返回一个shell环境变量。例如,&#34;env.PATH&#34;指代了$path环境变量（在Windows上是%PATH%）。 
 2. project.x：指代了POM中对应的元素值。 
 3. settings.x: 指代了settings.xml中对应元素的值。 
 4. Java System Properties: 所有可通过java.lang.System.getProperties()访问的属性都能在POM中使用该形式访问， 
 如/usr/lib/jvm/java-1.6.0-openjdk-1.6.0.0/jre。 
 5. x: 在&lt;properties/&gt;元素中，或者外部文件中设置，以${someVar}的形式使用。 --&gt; 
 &lt;properties&gt; 
 &lt;user.install&gt;/ebs1/build-machine/usr/local/hudson/hudson-home/jobs/maven-guide-&lt;/user.install&gt; 
 &lt;/properties&gt; 
 &lt;!--远程仓库列表，它是Maven用来填充构建系统本地仓库所使用的一组远程项目。 --&gt; 
 &lt;repositories&gt; 
 &lt;!--包含需要连接到远程仓库的信息 --&gt; 
 &lt;repository&gt; 
 &lt;!--远程仓库唯一标识--&gt; 
 &lt;id&gt;codehausSnapshots&lt;/id&gt; 
 &lt;!--远程仓库名称 --&gt; 
 &lt;name&gt;Codehaus Snapshots&lt;/name&gt; 
 &lt;!--如何处理远程仓库里发布版本的下载--&gt; 
 &lt;releases&gt; 
 &lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt; 
 &lt;enabled&gt;false&lt;/enabled&gt; 
 &lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt; 
 &lt;updatePolicy&gt;always&lt;/updatePolicy&gt; 
 &lt;!--当Maven验证构件校验文件失败时该怎么做-ignore（忽略），fail（失败），或者warn（警告）。--&gt; 
 &lt;checksumPolicy&gt;warn&lt;/checksumPolicy&gt; 
 &lt;/releases&gt; 
 &lt;!--如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素--&gt; 
 &lt;snapshots&gt; 
 &lt;enabled/&gt;&lt;updatePolicy/&gt;&lt;checksumPolicy/&gt; 
 &lt;/snapshots&gt; 
 &lt;!--远程仓库URL，按protocol://hostname/path形式 --&gt; 
 &lt;url&gt;http://snapshots.maven.codehaus.org/maven2&lt;/url&gt; 
 &lt;!--用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --&gt; 
 &lt;layout&gt;default&lt;/layout&gt; 
 &lt;/repository&gt; 
 &lt;/repositories&gt; 
 &lt;!--发现插件的远程仓库列表。仓库是两种主要构件的家。第一种构件被用作其它构件的依赖。这是中央仓库中存储的大部分构件类型。另外一种构件类型是插件。Maven插件是一种特殊类型的构件。由于这个原因，插件仓库独立于其它仓库。pluginRepositories元素的结构和repositories元素的结构类似。每个pluginRepository元素指定一个Maven可以用来寻找新插件的远程地址。--&gt; 
 &lt;pluginRepositories&gt; 
 &lt;!--包含需要连接到远程插件仓库的信息.参见profiles/profile/repositories/repository元素的说明--&gt; 
 &lt;pluginRepository&gt; 
 &lt;releases&gt; 
 &lt;enabled/&gt;&lt;updatePolicy/&gt;&lt;checksumPolicy/&gt; 
 &lt;/releases&gt; 
 &lt;snapshots&gt; 
 &lt;enabled/&gt;&lt;updatePolicy/&gt;&lt;checksumPolicy/&gt; 
 &lt;/snapshots&gt; 
 &lt;id/&gt;&lt;name/&gt;&lt;url/&gt;&lt;layout/&gt; 
 &lt;/pluginRepository&gt; 
 &lt;/pluginRepositories&gt; 
 &lt;!--手动激活profiles的列表，按照profile被应用的顺序定义activeProfile。 该元素包含了一组activeProfile元素，每个activeProfile都含有一个profile id。任何在activeProfile中定义的profile id，不论环境设置如何，其对应的 
 profile都会被激活。如果没有匹配的profile，则什么都不会发生。例如，env-test是一个activeProfile，则在pom.xml（或者profile.xml）中对应id的profile会被激活。如果运行过程中找不到这样一个profile，Maven则会像往常一样运行。 --&gt; 
 &lt;activeProfiles&gt; 
 &lt;!-- --&gt; 
 &lt;activeProfile&gt;env-test&lt;/activeProfile&gt; 
 &lt;/activeProfiles&gt; 
 &lt;/profile&gt; 
 &lt;/profiles&gt; 
&lt;/settings&gt; 
">Maven setting</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://https://chenm0.github.io/post/excel-args/"" data-c="
          &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;默认值&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;sort&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;Integer.MAX_VALUE&lt;/td&gt;
&lt;td&gt;导出时在excel中排序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;name&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;空&lt;/td&gt;
&lt;td&gt;导出到Excel中的名字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;dateFormat&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;空&lt;/td&gt;
&lt;td&gt;日期格式, 如: yyyy-MM-dd&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;dictType&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;空&lt;/td&gt;
&lt;td&gt;如果是字典类型，请设置字典的type值 (如: sys_user_sex)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;readConverterExp&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;空&lt;/td&gt;
&lt;td&gt;读取内容转表达式 (如: 0=男,1=女,2=未知)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;separator&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;,&lt;/td&gt;
&lt;td&gt;分隔符，读取字符串组内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;scale&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;-1&lt;/td&gt;
&lt;td&gt;BigDecimal 精度 默认:-1(默认不开启BigDecimal格式化)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;roundingMode&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;BigDecimal.ROUND_HALF_EVEN&lt;/td&gt;
&lt;td&gt;BigDecimal 舍入规则 默认:BigDecimal.ROUND_HALF_EVEN&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;columnType&lt;/td&gt;
&lt;td&gt;Enum&lt;/td&gt;
&lt;td&gt;Type.STRING&lt;/td&gt;
&lt;td&gt;导出类型（0数字 1字符串 2图片）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;height&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;导出时在excel中每个列的高度 单位为字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;width&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;导出时在excel中每个列的宽 单位为字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;suffix&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;空&lt;/td&gt;
&lt;td&gt;文字后缀,如% 90 变成90%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;defaultValue&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;空&lt;/td&gt;
&lt;td&gt;当值为空时,字段的默认值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;prompt&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;空&lt;/td&gt;
&lt;td&gt;提示信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;combo&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;Null&lt;/td&gt;
&lt;td&gt;设置只能选择不能输入的列内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;targetAttr&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;空&lt;/td&gt;
&lt;td&gt;另一个类中的属性名称,支持多级获取,以小数点隔开&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;isStatistics&lt;/td&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;td&gt;是否自动统计数据,在最后追加一行统计数据总和&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;type&lt;/td&gt;
&lt;td&gt;Enum&lt;/td&gt;
&lt;td&gt;Type.ALL&lt;/td&gt;
&lt;td&gt;字段类型（0：导出导入；1：仅导出；2：仅导入）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
">@Excel参数大全</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://https://chenm0.github.io/post/jpa-qa/"" data-c="
          &lt;h3 id=&#34;spring-data-jpa查询到的对象被set值后自动更新数据库&#34;&gt;Spring data JPA查询到的对象被set值后，自动更新数据库&lt;/h3&gt;
&lt;p&gt;做项目开发的时候遇到这样一个问题：数据库有临时表和正式表，数据审批通过后才会进入正式表，根据业务要求，页面的数据需要通过临时表对象来显示，当需要显示正式表数据时，先查询到临时表对象，再查询正式表对象，将正式表对象赋值给临时表对象用于页面显示，代码执行完毕后，发现数据库正式表数据覆盖了临时表数据，很纳闷，查看代码，在把正式表数据赋值给临时表对象后，并没有保存临时表对象的代码呀，数据库怎么会被更新？&lt;br&gt;
后来查看日志发现，当将正式表数据赋值给临时表时，有一条update语句执行了。查看资料后才知道，使用JPA查询后的对象处于持久态，持久态的对象属性在被set后，会自动执行update语句更新数据库。&lt;br&gt;
这才恍然大悟，基于这个原因，只要把持久态的对象转换为游离态或者是临时态，就可以解决问题。&lt;br&gt;
先理解下Hibernate 中对象的三种状态：&lt;br&gt;
(1)临时状态：通过new新建的对象，没有被持久化，也不在session缓存中&lt;br&gt;
(2)游离状态：已经被持久化，但不在session缓存中&lt;br&gt;
(3)持久状态：已经被持久化，也在session缓存中&lt;br&gt;
(持久化：数据库有这条数据)&lt;br&gt;
持久态到游离态的方法有：session.close()、session.evict(obj)、session.clear()&lt;br&gt;
close()：关闭session，整个session中的持久态对象都成为游离态&lt;br&gt;
clear()：清楚session中的所有缓存，所有持久化对象变为游离态&lt;br&gt;
evict(obj)：把某个持久化状态的对象从session中清除，该对象变为游离态&lt;/p&gt;
&lt;p&gt;根据三个方法的介绍，最好的处理方式应该选择evict(obj)方法。&lt;/p&gt;
&lt;p&gt;由于业务需求，我的解决方式是，新建一个临时态的临时表对象，将查询到的正式表对象赋值给临时态对象，这样就不会触发update语句，经测试，问题解决。&lt;/p&gt;
&lt;p&gt;`	@PersistenceContext&lt;br&gt;
private EntityManager entityManager;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Session session = entityManager.unwrap(Session.class);`&lt;/code&gt;&lt;/pre&gt;
">JPA踩坑记录</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://https://chenm0.github.io/post/springboot2-yml/"" data-c="
          &lt;p&gt;＃================================================= ==================&lt;br&gt;
＃COMMON SPRING BOOT PROPERTIES&lt;/p&gt;
&lt;h2 id=&#34;&#34;&gt;&lt;/h2&gt;
&lt;p&gt;此样本文件作为指南提供。不要将它的#complete复制&lt;br&gt;
到您自己的应用程序中。^^^&lt;br&gt;
＃============================================== =====================&lt;/p&gt;
&lt;p&gt;＃----------------------------------------&lt;br&gt;
#CORE PROPERTIES&lt;br&gt;
＃----- -----------------------------------&lt;br&gt;
debug = false ＃启用调试日志。&lt;br&gt;
trace = false ＃启用跟踪日志。&lt;/p&gt;
&lt;p&gt;#logGING&lt;br&gt;
logging.config = ＃日志配置文件的位置。例如，Logback的&lt;code&gt;classpath：logback.xml&lt;/code&gt;。&lt;br&gt;
logging.exception-conversion-word =％wEx ＃记录异常时使用的转换字。&lt;br&gt;
logging.file = ＃日志文件名（例如，&lt;code&gt;myapp.log&lt;/code&gt;）。名称可以是精确位置或相对于当前目录。&lt;br&gt;
logging.file.max-history = 0 ＃要保留的归档日志文件的最大值。仅支持默认的logback设置。&lt;br&gt;
logging.file.max-size = 10MB ＃最大日志文件大小。仅支持默认的logback设置。&lt;br&gt;
logging.group。* =＃记录组以同时快速更改多个记录器。例如，&lt;code&gt;logging.level.db = org.hibernate，org.springframework.jdbc&lt;/code&gt;。&lt;br&gt;
logging.level。* = ＃日志级别严重性映射。例如，&lt;code&gt;logging.level.org.springframework = DEBUG&lt;/code&gt;。&lt;br&gt;
logging.path = ＃日志文件的位置。例如，&lt;code&gt;/ var / log&lt;/code&gt;。&lt;br&gt;
logging.pattern.console = ＃用于输出到控制台的Appender模式。仅支持默认的Logback设置。&lt;br&gt;
logging.pattern.dateformat = yyyy-MM-dd HH：mm：ss.SSS ＃日志日期格式的Appender模式。仅支持默认的Logback设置。&lt;br&gt;
logging.pattern.file =＃用于输出到文件的Appender模式。仅支持默认的Logback设置。&lt;br&gt;
logging.pattern.level =％5p ＃日志级别的Appender模式。仅支持默认的Logback设置。&lt;br&gt;
logging.register-shutdown-hook = false ＃在日志记录系统初始化时注册一个关闭钩子。&lt;/p&gt;
&lt;p&gt;＃AOP&lt;br&gt;
spring.aop.auto =真＃添加@EnableAspectJAutoProxy。&lt;br&gt;
spring.aop.proxy-target-class = true ＃是否要创建基于子类的（CGLIB）代理（true），而不是基于标准Java接口的代理（false）。&lt;/p&gt;
&lt;p&gt;#IDENTITY （ContextIdApplicationContextInitializer）&lt;br&gt;
spring.application.name = #Application name。&lt;/p&gt;
&lt;p&gt;#DINAND （SpringApplicationAdminJmxAutoConfiguration）&lt;br&gt;
spring.application.admin.enabled = false ＃是否为应用程序启用管理功能。&lt;br&gt;
spring.application.admin.jmx-name = org.springframework.boot：type = Admin，name = SpringApplication #JMX 应用程序管理员MBean的名称。&lt;/p&gt;
&lt;p&gt;#AUTO-CONFIGURATION&lt;br&gt;
spring.autoconfigure.exclude = ＃要排除的自动配置类。&lt;/p&gt;
&lt;p&gt;＃BANNER&lt;br&gt;
spring.banner.charset = UTF-8 ＃横幅文件编码。&lt;br&gt;
spring.banner.location = classpath：banner.txt ＃横幅文本资源位置。&lt;br&gt;
spring.banner.image.location = classpath：banner.gif ＃横幅图像文件位置（也可以使用jpg或png）。&lt;br&gt;
spring.banner.image.width = 76 ＃字符中的横幅图像的宽度。&lt;br&gt;
spring.banner.image.height = #crs 中横幅图像的高度（默认基于图像高度）。&lt;br&gt;
spring.banner.image.margin = 2 ＃字符中的左手图像边距。&lt;br&gt;
spring.banner.image.invert = false ＃是否应针对暗终端主题反转图像。&lt;/p&gt;
&lt;p&gt;#SPRING CORE spring.beaninfo.ignore = true ＃是否跳过BeanInfo类的搜索。&lt;/p&gt;
&lt;p&gt;#SPRING CACHE（CacheProperties）&lt;br&gt;
spring.cache.cache-names = #Cmama 分隔的要创建的缓存名称列表（如果底层缓存管理器支持）。&lt;br&gt;
spring.cache.caffeine.spec = ＃用于创建缓存的规范。有关规格格式的更多详细信息，请参阅CaffeineSpec。&lt;br&gt;
spring.cache.couchbase.expiration = ＃条目到期。默认情况下，条目永不过期。请注意，此值最终会转换为秒。&lt;br&gt;
spring.cache.ehcache.config = ＃用于初始化EhCache的配置文件的位置。&lt;br&gt;
spring.cache.infinispan.config = ＃用于初始化Infinispan的配置文件的位置。&lt;br&gt;
spring.cache.jcache.config = ＃用于初始化缓存管理器的配置文件的位置。&lt;br&gt;
spring.cache.jcache.provider = #CachingProvider实现的完全限定名称，用于检索符合JSR-107的缓存管理器。仅当类路径上有多个JSR-107实现时才需要。&lt;br&gt;
spring.cache.redis.cache-null-values = true ＃允许缓存空值。&lt;br&gt;
spring.cache.redis.key-prefix = ＃键前缀。&lt;br&gt;
spring.cache.redis.time-to-live = ＃条目到期。默认情况下，条目永不过期。&lt;br&gt;
spring.cache.redis.use-key-prefix = true＃写入Redis时是否使用密钥前缀。&lt;br&gt;
spring.cache.type = #Cache 类型。默认情况下，根据环境自动检测。&lt;/p&gt;
&lt;p&gt;#SPRING CONFIG  - 仅使用环境属性（ConfigFileApplicationListener）&lt;br&gt;
spring.config.additional-location = ＃配置除默认值之外使用的文件位置。&lt;br&gt;
spring.config.location = ＃配置替换默认值的文件位置。&lt;br&gt;
spring.config.name = application ＃配置文件名。&lt;/p&gt;
&lt;p&gt;#HAZELCAST（HazelcastProperties）&lt;br&gt;
spring.hazelcast.config = ＃用于初始化Hazelcast的配置文件的位置。&lt;/p&gt;
&lt;p&gt;#PROJECT INFORMATION（ProjectInfoProperties）&lt;br&gt;
spring.info.build.encoding = UTF-8 ＃文件编码。&lt;br&gt;
spring.info.build.location = classpath：META-INF / build-info.properties ＃生成的build-info.properties文件的位置。&lt;br&gt;
spring.info.git.encoding = UTF-8 ＃文件编码。&lt;br&gt;
spring.info.git.location =类路径：git.properties 生成的git.properties文件＃所在。&lt;/p&gt;
&lt;p&gt;＃JMX&lt;br&gt;
spring.jmx.default域 = ＃JMX域名。&lt;br&gt;
spring.jmx.enabled = true ＃将管理bean公开给JMX域。&lt;br&gt;
spring.jmx.server = mbeanServer ＃MBeanServer bean name。&lt;br&gt;
spring.jmx.unique-names = false ＃是否应确保唯一的运行时对象名称。&lt;/p&gt;
&lt;p&gt;#Email （MailProperties）&lt;br&gt;
spring.mail.default-encoding = UTF-8 ＃默认MimeMessage编码。&lt;br&gt;
spring.mail.host = #SMTP 服务器主机。例如，&lt;code&gt;smtp.example.com&lt;/code&gt;。&lt;br&gt;
spring.mail.jndi-name = ＃会话JNDI名称。设置时，优先于其他会话设置。&lt;br&gt;
spring.mail.password = #SMTP 服务器的登录密码。&lt;br&gt;
spring.mail.port = #SMTP 服务器端口。&lt;br&gt;
spring.mail.properties。* = ＃其他JavaMail会话属性。&lt;br&gt;
spring.mail.protocol = smtp ＃SMTP服务器使用的协议。&lt;br&gt;
spring.mail.test-connection = false＃是否在启动时测试邮件服务器是否可用。&lt;br&gt;
spring.mail.username = #SMTP 服务器的登录用户。&lt;/p&gt;
&lt;p&gt;#APICING SETTINGS（SpringApplication）&lt;br&gt;
spring.main.allow-bean-definition-overriding = false ＃是否允许通过注册与现有定义同名的定义来覆盖bean定义。&lt;br&gt;
spring.main.banner-mode = console ＃模式用于在应用程序运行时显示横幅。&lt;br&gt;
spring.main.sources = 要包含在ApplicationContext中的&lt;br&gt;
#Sources （类名，包名或XML资源位置）。spring.main.web-application-type = ＃用于显式请求特定类型的Web应用程序的标志。如果未设置，则基于类路径自动检测。&lt;/p&gt;
&lt;p&gt;#FILE ENCODING（FileEncodingApplicationListener）&lt;br&gt;
spring.mandatory-file-encoding = ＃应用程序必须使用的预期字符编码。&lt;/p&gt;
&lt;p&gt;#INTERINGIZATION （MessageSourceProperties）&lt;br&gt;
spring.messages.always-use-message-format = false ＃是否始终应用MessageFormat规则，甚至解析不带参数的消息。&lt;br&gt;
spring.messages.basename = messages ＃逗号分隔的basenames列表（本质上是一个完全限定的类路径位置），每个都遵循ResourceBundle约定，轻松支持基于斜杠的位置。&lt;br&gt;
spring.messages.cache-duration = ＃加载的资源包文件缓存持续时间。未设置时，捆绑包将永久缓存。如果未指定持续时间后缀，则将使用秒。&lt;br&gt;
spring.messages.encoding = UTF-8 ＃消息包编码。&lt;br&gt;
spring.messages.fallback-to-system-locale = true ＃如果找不到特定区域设置的文件，是否回退到系统区域设置。&lt;br&gt;
spring.messages.use-code-as-default-message = false ＃是否使用消息代码作为默认消息而不是抛出“NoSuchMessageException”。仅在开发期间推荐。&lt;/p&gt;
&lt;p&gt;＃OUTPUT&lt;br&gt;
spring.output.ansi.enabled =检测＃配置的ANSI输出。&lt;/p&gt;
&lt;p&gt;#PID FILE（ApplicationPidFileWriter）&lt;br&gt;
spring.pid.fail-on-write-error = ＃如果使用ApplicationPidFileWriter但它无法写入PID文件，则失败。&lt;br&gt;
spring.pid.file = ＃要写入的PID文件的位置（如果使用ApplicationPidFileWriter）。&lt;/p&gt;
&lt;p&gt;＃PROFILES&lt;br&gt;
spring.profiles.active = ＃逗号分隔的有源配置文件列表。可以通过命令行开关覆盖。&lt;br&gt;
spring.profiles.include = ＃无条件地激活指定的逗号分隔的配置文件列表（如果使用YAML，则激活配置文件列表）。&lt;/p&gt;
&lt;p&gt;＃Quartz调度器（QuartzProperties）&lt;br&gt;
spring.quartz.auto-启动 =真＃是否自动启动初始化后的调度。&lt;br&gt;
spring.quartz.jdbc.comment-prefix =  - #SQL 初始化脚本中单行注释的前缀。&lt;br&gt;
spring.quartz.jdbc.initialize-schema = embedded ＃数据库模式初始化模式。&lt;br&gt;
spring.quartz.jdbc.schema = classpath：org / quartz / impl / jdbcjobstore / tables_ @ @ platform @@ .sql ＃用于初始化数据库模式的SQL文件的路径。&lt;br&gt;
spring.quartz.job-store-type = memory ＃Quartz作业存储类型。&lt;br&gt;
spring.quartz.overwrite-existing-jobs = false ＃配置的作业是否应覆盖现有的作业定义。&lt;br&gt;
spring.quartz.properties。* = ＃其他Quartz Scheduler属性。&lt;br&gt;
spring.quartz.scheduler-name = quartzScheduler ＃调度程序的名称。&lt;br&gt;
spring.quartz.startup-delay = 0s ＃一旦初始化完成，调度程序启动之后的延迟。&lt;br&gt;
spring.quartz.wait-for-jobs-to-complete-on-shutdown = false ＃是否等待在关闭时运行的作业完成。&lt;/p&gt;
&lt;p&gt;#REACTOR （ReactorCoreProperties）&lt;br&gt;
spring.reactor.stacktrace -mode.enabled = false #Reactor 是否应该在运行时收集堆栈跟踪信息。&lt;/p&gt;
&lt;p&gt;#SENDGRID（SendGridAutoConfiguration）&lt;br&gt;
spring.sendgrid.api-key = ＃SendGrid API密钥。&lt;br&gt;
spring.sendgrid.proxy.host = ＃SendGrid代理主机。&lt;br&gt;
spring.sendgrid.proxy.port = ＃SendGrid代理端口。&lt;/p&gt;
&lt;p&gt;#TASK EXECUTION（TaskExecutionProperties）&lt;br&gt;
spring.task.execution.pool.allow-core-thread-timeout = true ＃是否允许核心线程超时。这可以实现池的动态增长和收缩。&lt;br&gt;
spring.task.execution.pool.core-size = 8 ＃核心线程数。&lt;br&gt;
spring.task.execution.pool.keep-alive = 60s ＃终止之前线程可能保持空闲的时间限制。&lt;br&gt;
spring.task.execution.pool.max-size = ＃允许的最大线程数。如果任务正在填满队列，则池可以扩展到该大小以适应负载。如果队列无限制，则忽略。&lt;br&gt;
spring.task.execution.pool.queue-capacity =＃队列容量。无限制的容量不会增加池，因此会忽略“max-size”属性。&lt;br&gt;
spring.task.execution.thread-name-prefix = task- ＃用于新创建的线程名称的前缀。&lt;/p&gt;
&lt;p&gt;#TASK SCHEDULING（TaskSchedulingProperties）&lt;br&gt;
spring.task.scheduling.pool.size = 1 ＃允许的最大线程数。&lt;br&gt;
spring.task.scheduling.thread-name-prefix = scheduling- ＃用于新创建的线程名称的前缀。&lt;/p&gt;
&lt;p&gt;＃----------------------------------------&lt;br&gt;
＃WEB PROPERTIES&lt;br&gt;
＃----- -----------------------------------&lt;/p&gt;
&lt;p&gt;#EmbEDDED SERVER CONFIGURATION（ServerProperties）&lt;br&gt;
server.address = ＃服务器应绑定到的网络地址。&lt;br&gt;
server.compression.enabled = false ＃是否启用了响应压缩。&lt;br&gt;
server.compression.excluded-user-agents = ＃逗号分隔的用户代理列表，不应压缩响应。&lt;br&gt;
server.compression.mime-types = text / html，text / xml，text / plain，text / css，text / javascript，application / javascript，application / json，application / xml ＃逗号分隔的MIME类型列表应该是压缩。&lt;br&gt;
server.compression.min-response-size = 2KB＃执行压缩所需的最小“Content-Length”值。&lt;br&gt;
server.connection-timeout = ＃连接器在关闭连接之前等待另一个HTTP请求的时间。未设置时，将使用连接器的特定于容器的默认值。使用值-1表示没有（即无限）超时。&lt;br&gt;
server.error.include-exception = false ＃包含“exception”属性。&lt;br&gt;
server.error.include-stacktrace = never ＃何时包含“stacktrace”属性。&lt;br&gt;
server.error.path = / error ＃错误控制器的路径。&lt;br&gt;
server.error.whitelabel.enabled = true＃是否在服务器出错时启用浏览器中显示的默认错误页面。&lt;br&gt;
server.http2.enabled = false ＃是否启用HTTP / 2支持，如果当前环境支持它。&lt;br&gt;
server.jetty.acceptors = -1 ＃要使用的接受者线程数。当值为-1（默认值）时，接受器的数量是从操作环境派生的。&lt;br&gt;
server.jetty.accesslog.append = false ＃追加到日志。&lt;br&gt;
server.jetty.accesslog.date-format = dd / MMM / yyyy：HH：mm：ss Z ＃请求日志的时间戳格式。&lt;br&gt;
server.jetty.accesslog.enabled = false ＃启用访问日志。&lt;br&gt;
server.jetty.accesslog.extended-format = false＃启用扩展NCSA格式。&lt;br&gt;
server.jetty.accesslog.file-date-format = ＃日期文件名中的日期格式。&lt;br&gt;
server.jetty.accesslog.filename = ＃日志文件名。如果未指定，则日志重定向到“System.err”。&lt;br&gt;
server.jetty.accesslog.locale = ＃请求日志的区域设置。&lt;br&gt;
server.jetty.accesslog.log-cookies = false ＃启用请求cookie的记录。&lt;br&gt;
server.jetty.accesslog.log-latency = false ＃启用请求处理时间的记录。&lt;br&gt;
server.jetty.accesslog.log-server = false ＃启用请求主机名的日志记录。&lt;br&gt;
server.jetty.accesslog.retention-period = 31＃删除旋转日志文件之前的天数。&lt;br&gt;
server.jetty.accesslog.time-zone = GMT ＃请求日志的时区。&lt;br&gt;
server.jetty.max-http-post-size = 200000B #HTTP post或put内容的最大大小。&lt;br&gt;
server.jetty.selectors = -1 ＃要使用的选择器线程数。当值为-1（默认值）时，选择器的数量是从操作环境派生的。&lt;br&gt;
server.max-http-header-size = 8KB #HTTP 邮件头的最大大小。&lt;br&gt;
server.port = 8080 ＃服务器HTTP端口。&lt;br&gt;
server.server-header = ＃用于Server响应头的值（如果为空，则不发送头）。&lt;br&gt;
server.use-forward-headers = ＃是否应将X-Forwarded- &lt;em&gt;标头应用于HttpRequest。&lt;br&gt;
server.servlet.context-parameters。&lt;/em&gt; = ＃Servlet context init参数。&lt;br&gt;
server.servlet.context-path = ＃应用程序的上下文路径。&lt;br&gt;
server.servlet.application-display-name = application ＃显示&lt;br&gt;
应用程序的名称。server.servlet.jsp.class-name = org.apache.jasper.servlet.JspServlet ＃用于JSP的servlet的类名。&lt;br&gt;
server.servlet.jsp.init-parameters。* = ＃用于配置JSP servlet的Init参数。&lt;br&gt;
server.servlet.jsp.registered = true＃是否已注册JSP servlet。&lt;br&gt;
server.servlet.session.cookie.comment = ＃会话cookie的评论。&lt;br&gt;
server.servlet.session.cookie.domain = ＃会话cookie的域名。&lt;br&gt;
server.servlet.session.cookie.http-only = ＃是否对会话cookie使用“HttpOnly”cookie。&lt;br&gt;
server.servlet.session.cookie.max-age = ＃会话cookie的最大年龄。如果未指定持续时间后缀，则将使用秒。&lt;br&gt;
server.servlet.session.cookie.name = ＃会话cookie名称。&lt;br&gt;
server.servlet.session.cookie.path = ＃会话cookie的路径。&lt;br&gt;
server.servlet.session.cookie.secure =＃是否始终将会话cookie标记为安全。&lt;br&gt;
server.servlet.session.persistent = false ＃是否在重新启动之间保留会话数据。&lt;br&gt;
server.servlet.session.store-dir = ＃用于存储会话数据的目录。&lt;br&gt;
server.servlet.session.timeout = 30m ＃会话超时。如果未指定持续时间后缀，则将使用秒。&lt;br&gt;
server.servlet.session.tracking-modes = ＃会话跟踪模式。&lt;br&gt;
server.ssl.ciphers = ＃支持的SSL密码。&lt;br&gt;
server.ssl.client-auth = ＃客户端身份验证模式。&lt;br&gt;
server.ssl.enabled = true ＃是否启用SSL支持。&lt;br&gt;
server.ssl.enabled-protocols = ＃启用SSL协议。&lt;br&gt;
server.ssl.key-alias = ＃标识密钥库中密钥的别名。&lt;br&gt;
server.ssl.key-password = ＃用于访问密钥库中密钥的密码。&lt;br&gt;
server.ssl.key-store = ＃保存SSL证书的密钥库的路径（通常是jks文件）。&lt;br&gt;
server.ssl.key-store-password = ＃用于访问密钥库的密码。&lt;br&gt;
server.ssl.key-store-provider = ＃密钥库的提供者。&lt;br&gt;
server.ssl.key-store-type = ＃密钥库的类型。&lt;br&gt;
server.ssl.protocol = TLS ＃要使用的SSL协议。&lt;br&gt;
server.ssl.trust-store = ＃持有SSL证书的信任存储。&lt;br&gt;
server.ssl.trust-store-password = ＃用于访问信任库的密码。&lt;br&gt;
server.ssl.trust-store-provider = ＃信任存储的提供者。&lt;br&gt;
server.ssl.trust-store-type = ＃信任库的类型。&lt;br&gt;
server.tomcat.accept-count = 100 ＃当所有可能的请求处理线程都在使用时，传入连接请求的最大队列长度。&lt;br&gt;
server.tomcat.accesslog.buffered = true ＃是否缓冲输出，使其仅定期刷新。&lt;br&gt;
server.tomcat.accesslog.directory = logs＃创建日志文件的目录。可以绝对或相对于Tomcat基础目录。&lt;br&gt;
server.tomcat.accesslog.enabled = false ＃启用访问日志。&lt;br&gt;
server.tomcat.accesslog.file-date-format = .yyyy-MM-dd ＃要放在日志文件名中的日期格式。&lt;br&gt;
server.tomcat.accesslog.pattern = common ＃访问日志的格式模式。&lt;br&gt;
server.tomcat.accesslog.prefix = access_log ＃日志文件名前缀。&lt;br&gt;
server.tomcat.accesslog.rename-on-rotate = false ＃是否延迟在文件名中包含日期戳，直到旋转时间。&lt;br&gt;
server.tomcat.accesslog.request-attributes-enabled = false＃设置请求的IP地址，主机名，协议和端口的请求属性。&lt;br&gt;
server.tomcat.accesslog.rotate = true ＃是否启用访问日志轮换。&lt;br&gt;
server.tomcat.accesslog.suffix = .log ＃日志文件名后缀。&lt;br&gt;
server.tomcat.additional-tld-skip-patterns = ＃逗号分隔的其他模式列表，这些模式匹配要忽略的TLD扫描的jar。&lt;br&gt;
server.tomcat.background-processor-delay = 10s #backgroundProcess 方法调用之间的延迟。如果未指定持续时间后缀，则将使用秒。&lt;br&gt;
server.tomcat.basedir = #Tomcat 基目录。如果未指定，则使用临时目录。&lt;br&gt;
server.tomcat.internal-proxies = 10 \。\ d {1,3} \。\ d {1,3} \。\ d {1,3} | \&lt;br&gt;
。192 \ 168 \ d {1,3} \ d {1,3} | \&lt;br&gt;
。169 \ 254 \ d {1,3} \ d {1,3} | \&lt;br&gt;
。127 \ d {1,3} \ d {1,3} \ d {1,3} | \&lt;br&gt;
172 \ 1 [6-9] {1} \ d {1,3} \ d {1,3} |。。\&lt;br&gt;
172 \ 2 [0-9] {1} \ d {1,3} \ d {1,3} |。。\&lt;br&gt;
172 \。3 [0-1] {1} \。\ d {1,3} \。\ d {1,3} \&lt;br&gt;
0：0：0：0：0：0：0：1 \&lt;br&gt;
:: 1 ＃正则表达式匹配要信任的代理。&lt;br&gt;
server.tomcat.max-connections = 10000 ＃服务器在任何给定时间接受和处理的最大连接数。&lt;br&gt;
server.tomcat.max-http-post-size = 2MB #HTTP 帖子内容的最大大小。&lt;br&gt;
server.tomcat.max-swallow-size = 2MB ＃要吞咽的请求正文的最大数量。&lt;br&gt;
server.tomcat.max-threads = 200 ＃最大工作线程数。&lt;br&gt;
server.tomcat.min-spare-threads = 10 ＃最小工作线程数。&lt;br&gt;
server.tomcat.port-header = X-Forwarded-Port＃用于覆盖原始端口值的HTTP头的名称。&lt;br&gt;
server.tomcat.protocol-header = ＃包含传入协议的头文件，通常命名为“X-Forwarded-Proto”。&lt;br&gt;
server.tomcat.protocol-header-https-value = https ＃协议标头的值，指示传入请求是否使用SSL。&lt;br&gt;
server.tomcat.redirect-context-root = true ＃是否应通过在路径中附加/来重定向对上下文根的请求。&lt;br&gt;
server.tomcat.remote-ip-header = ＃从中提取远程IP的HTTP头的名称。例如，&lt;code&gt;X-FORWARDED-FOR&lt;/code&gt;。&lt;br&gt;
server.tomcat.resource.allow-caching = true＃是否允许此Web应用程序使用静态资源缓存。&lt;br&gt;
server.tomcat.resource.cache-ttl = ＃静态资源缓存的生存时间。&lt;br&gt;
server.tomcat.uri-encoding = UTF-8 ＃用于解码URI的字符编码。&lt;br&gt;
server.tomcat.use-relative-redirects = ＃通过调用sendRedirect生成的HTTP 1.1和更高版本的位置标头是使用相对还是绝对重定向。&lt;br&gt;
server.undertow.accesslog.dir = #Undertow 访问日志目录。&lt;br&gt;
server.undertow.accesslog.enabled = false ＃是否启用访问日志。&lt;br&gt;
server.undertow.accesslog.pattern = common ＃访问日志的格式模式。&lt;br&gt;
server.undertow.accesslog.prefix = access_log。＃日志文件名前缀。&lt;br&gt;
server.undertow.accesslog.rotate = true ＃是否启用访问日志轮换。&lt;br&gt;
server.undertow.accesslog.suffix = log ＃日志文件名后缀。&lt;br&gt;
server.undertow.buffer-size = ＃每个缓冲区的大小。&lt;br&gt;
server.undertow.direct-buffers = ＃是否在Java堆外部分配缓冲区。默认值源自JVM可用的最大内存量。&lt;br&gt;
server.undertow.eager-filter-init = true ＃是否应在启动时初始化servlet过滤器。&lt;br&gt;
server.undertow.io-threads =＃为worker创建的I / O线程数。默认值源自可用处理器的数量。&lt;br&gt;
server.undertow.max-http-post-size = -1B #HTTP 帖子内容的最大大小。当值为-1时，默认值为大小无限制。&lt;br&gt;
server.undertow.worker-threads = ＃工作线程数。默认值是I / O线程数的8倍。&lt;/p&gt;
&lt;p&gt;#FREEMARKER（FreeMarkerProperties）&lt;br&gt;
spring.freemarker.allow-request-override = false ＃是否允许HttpServletRequest属性覆盖（隐藏）控制器生成的同名模型属性。&lt;br&gt;
spring.freemarker.allow-session-override = false ＃是否允许HttpSession属性覆盖（隐藏）控制器生成的同名模型属性。&lt;br&gt;
spring.freemarker.cache = false ＃是否启用模板缓存。&lt;br&gt;
spring.freemarker.charset = UTF-8 ＃模板编码。&lt;br&gt;
spring.freemarker.check-template-location = true ＃是否检查模板位置是否存在。&lt;br&gt;
spring.freemarker.content-type = text / html ＃Content-Type value。&lt;br&gt;
spring.freemarker.enabled = true ＃是否为此技术启用MVC视图分辨率。&lt;br&gt;
spring.freemarker.expose-request-attributes = false ＃是否应在与模板合并之前将所有请求属性添加到模型中。&lt;br&gt;
spring.freemarker.expose-session-attributes = false ＃是否应在与模板合并之前将所有HttpSession属性添加到模型中。&lt;br&gt;
spring.freemarker.expose-spring-macro-helpers = true ＃是否公开一个RequestContext供Spring的宏库使用，名称为“springMacroRequestContext”。&lt;br&gt;
spring.freemarker.prefer-file-system-access = true ＃是否更喜欢文件系统访问以进行模板加载。文件系统访问可以热检测模板更改。&lt;br&gt;
spring.freemarker.prefix = ＃在构建URL时添加前缀以查看名称的前缀。&lt;br&gt;
spring.freemarker.request-context-attribute = ＃所有视图的&lt;br&gt;
RequestContext属性的名称。spring.freemarker.settings。* = ＃众所周知的FreeMarker密钥，传递给FreeMarker的配置。&lt;br&gt;
spring.freemarker.suffix = .ftl ＃在构建URL时附加到视图名称的后缀。&lt;br&gt;
spring.freemarker.template-loader-path = classpath：/ templates /＃逗号分隔的模板路径列表。&lt;br&gt;
spring.freemarker.view-names = ＃可以解析的视图名称的白名单。&lt;/p&gt;
&lt;p&gt;#GLOVY TEMPLATES（GroovyTemplateProperties）&lt;br&gt;
spring.groovy.template.allow-request-override = false ＃是否允许HttpServletRequest属性覆盖（隐藏）控制器生成的同名模型属性。&lt;br&gt;
spring.groovy.template.allow-session-override = false ＃是否允许HttpSession属性覆盖（隐藏）控制器生成的同名模型属性。&lt;br&gt;
spring.groovy.template.cache = false ＃是否启用模板缓存。&lt;br&gt;
spring.groovy.template.charset = UTF-8 ＃模板编码。&lt;br&gt;
spring.groovy.template.check-template-location = true＃是否检查模板位置是否存在。&lt;br&gt;
spring.groovy.template.configuration。* = ＃请参阅GroovyMarkupConfigurer&lt;br&gt;
spring.groovy.template.content-type = text / html ＃Content-Type value。&lt;br&gt;
spring.groovy.template.enabled = true ＃是否为此技术启用MVC视图分辨率。&lt;br&gt;
spring.groovy.template.expose-request-attributes = false ＃是否应在与模板合并之前将所有请求属性添加到模型中。&lt;br&gt;
spring.groovy.template.expose-session-attributes = false ＃在与模板合并之前是否应将所有HttpSession属性添加到模型中。&lt;br&gt;
spring.groovy.template.expose-spring-macro-helpers = true ＃是否公开一个RequestContext供Spring的宏库使用，名称为“springMacroRequestContext”。&lt;br&gt;
spring.groovy.template.prefix = ＃在构建URL时添加前缀以查看名称的前缀。&lt;br&gt;
spring.groovy.template.request-context-attribute = ＃所有视图的&lt;br&gt;
RequestContext属性的名称。spring.groovy.template.resource-loader-path = classpath：/ templates / ＃Template path。&lt;br&gt;
spring.groovy.template.suffix = .tpl ＃在构建URL时附加到视图名称的后缀。&lt;br&gt;
spring.groovy.template.view-names =＃可以解析的视图名称的白名单。&lt;/p&gt;
&lt;p&gt;#SPRING HATEOAS（HateoasProperties）&lt;br&gt;
spring.hateoas.use-hal-as-default-json-media-type = true ＃是否应将application / hal + json响应发送给接受application / json的请求。&lt;/p&gt;
&lt;p&gt;#HTTP （HttpProperties）&lt;br&gt;
spring.http.converters.preferred-json-mapper = ＃用于HTTP消息转换的首选JSON映射器。默认情况下，根据环境自动检测。&lt;br&gt;
spring.http.encoding.charset = UTF-8 #HTTP 请求和响应的字符集。如果未明确设置，则添加到“Content-Type”标头。&lt;br&gt;
spring.http.encoding.enabled = true ＃是否启用http编码支持。&lt;br&gt;
spring.http.encoding.force = ＃是否在HTTP请求和响应上强制编码到已配置的字符集。&lt;br&gt;
spring.http.encoding.force-request =＃是否在HTTP请求中强制编码到配置的字符集。如果未指定“force”，则默认为true。&lt;br&gt;
spring.http.encoding.force-response = ＃是否在HTTP响应中强制编码到配置的字符集。&lt;br&gt;
spring.http.encoding.mapping = ＃用于编码映射的Locale。&lt;br&gt;
spring.http.log-request-details = false ＃是否允许在DEBUG和TRACE级别记录（可能敏感的）请求详细信息。&lt;/p&gt;
&lt;p&gt;#MULTIPART （MultipartProperties）&lt;br&gt;
spring.servlet.multipart.enabled = true ＃是否启用分段上传支持。&lt;br&gt;
spring.servlet.multipart.file-size-threshold = 0B ＃将文件写入磁盘后的阈值。&lt;br&gt;
spring.servlet.multipart.location = ＃上传文件的中间位置。&lt;br&gt;
spring.servlet.multipart.max-file-size = 1MB ＃最大文件大小。&lt;br&gt;
spring.servlet.multipart.max-request-size = 10MB ＃最大请求大小。&lt;br&gt;
spring.servlet.multipart.resolve-lazily = false ＃是否在文件或参数访问时懒惰地解析多部分请求。&lt;/p&gt;
&lt;p&gt;#JACKSON （JacksonProperties）&lt;br&gt;
spring.jackson.date-format = ＃日期格式字符串或完全限定的日期格式类名。例如，&lt;code&gt;yyyy-MM-dd HH：mm：ss&lt;/code&gt;。&lt;br&gt;
spring.jackson.default-property-inclusion = ＃控制序列化期间包含的属性。配置了Jackson的JsonInclude.Include枚举中的一个值。&lt;br&gt;
spring.jackson.deserialization。* = #Jackson on / off功能会影响Java对象的反序列化方式。&lt;br&gt;
spring.jackson.generator。* = ＃Jackson开/关功能的发电机。&lt;br&gt;
spring.jackson.joda-date-time-format =#Joda日期时间格式字符串。如果未配置，如果使用格式字符串配置，则使用“date-format”作为后备。&lt;br&gt;
spring.jackson.locale = ＃用于格式化的区域设置。&lt;br&gt;
spring.jackson.mapper。* = #Jackson 通用开/关功能。&lt;br&gt;
spring.jackson.parser。* = ＃Jackson开启/关闭解析器的功能。&lt;br&gt;
spring.jackson.property-naming-strategy = #Jackson PropertyNamingStrategy的常数之一。也可以是PropertyNamingStrategy子类的完全限定类名。&lt;br&gt;
spring.jackson.serialization。* = #Jacker on / off功能会影响Java对象的序列化方式。&lt;br&gt;
spring.jackson.time-zone =＃格式化日期时使用的时区。例如，“America / Los_Angeles”或“GMT + 10”。&lt;br&gt;
spring.jackson.visibility。* = #Jackson 可见性阈值，可用于限制自动检测哪些方法（和字段）。&lt;/p&gt;
&lt;p&gt;#GSON（GsonProperties）&lt;br&gt;
spring.gson.date-format = ＃序列化Date对象时使用的格式。&lt;br&gt;
spring.gson.disable -html-escaping = ＃是否禁用HTML字符的转义，例如&#39;&amp;lt;&#39;，&#39;&amp;gt;&#39;等&lt;br&gt;
spring.gson.disable-inner-class-serialization = ＃是否在内容类中排除内部类序列化。&lt;br&gt;
spring.gson.enable-complex-map-key-serialization = ＃是否启用复杂映射键（即非基元）的序列化。&lt;br&gt;
spring.gson.exclude-fields-without-expose-annotation = ＃是否排除所有不考虑序列化或反序列化但没有“Expose”注释的字段。&lt;br&gt;
spring.gson.field-naming-policy = ＃在序列化和反序列化期间应该应用于对象字段的命名策略。&lt;br&gt;
spring.gson.generate-non-executable-json = ＃是否通过在输出前添加一些特殊文本来生成不可执行的JSON。&lt;br&gt;
spring.gson.lenient = ＃是否宽容解析不符合RFC 4627的&lt;br&gt;
JSON.chring.gson.long-serialization-policy = ＃长和长类型的序列化策略。&lt;br&gt;
spring.gson.pretty-printing = ＃是否输出适合页面的序列化JSON以进行漂亮的打印。&lt;br&gt;
spring.gson.serialize-nulls = ＃是否序列化空字段。&lt;/p&gt;
&lt;p&gt;#JERSEY （JerseyProperties）&lt;br&gt;
spring.jersey.application-path = ＃作为应用程序基URI的路径。如果指定，则覆盖“@ApplicationPath”的值。&lt;br&gt;
spring.jersey.filter.order = 0 ＃Jersey过滤链顺序。&lt;br&gt;
spring.jersey.init。* = ＃通过servlet或过滤器传递给Jersey的Init参数。&lt;br&gt;
spring.jersey.servlet.load-on-startup = -1 ＃加载Jersey servlet的启动优先级。&lt;br&gt;
spring.jersey.type = servlet ＃Jersey集成类型。&lt;/p&gt;
&lt;p&gt;#SPRING LDAP（LdapProperties）&lt;br&gt;
spring.ldap.anonymous-read-only = false ＃只读操作是否应使用匿名环境。&lt;br&gt;
spring.ldap.base = #Base 后缀，所有操作都应该来自该后缀。&lt;br&gt;
spring.ldap.base-environment。* = #LDAP 规范设置。&lt;br&gt;
spring.ldap.password = ＃服务器的登录密码。&lt;br&gt;
spring.ldap.urls = ＃服务器的LDAP URL。&lt;br&gt;
spring.ldap.username = ＃登录服务器的用户名。&lt;/p&gt;
&lt;p&gt;＃EMBEDDED LDAP（EmbeddedLdapProperties）&lt;br&gt;
spring.ldap.embedded.base-dn = ＃基本DN列表。&lt;br&gt;
spring.ldap.embedded.credential.username = ＃嵌入式LDAP用户名。&lt;br&gt;
spring.ldap.embedded.credential.password = ＃嵌入式LDAP密码。&lt;br&gt;
spring.ldap.embedded.ldif = classpath：schema.ldif #Schema （LDIF）脚本资源引用。&lt;br&gt;
spring.ldap.embedded.port = 0 ＃嵌入式LDAP端口。&lt;br&gt;
spring.ldap.embedded.validation.enabled = true ＃是否启用LDAP模式验证。&lt;br&gt;
spring.ldap.embedded.validation.schema = ＃自定义架构的路径。&lt;/p&gt;
&lt;p&gt;#MUSTACHE TEMPLATES（MustacheAutoConfiguration）&lt;br&gt;
spring.mustache.allow-request-override = false ＃是否允许HttpServletRequest属性覆盖（隐藏）控制器生成的同名模型属性。&lt;br&gt;
spring.mustache.allow-session-override = false ＃是否允许HttpSession属性覆盖（隐藏）控制器生成的同名模型属性。&lt;br&gt;
spring.mustache.cache = false ＃是否启用模板缓存。&lt;br&gt;
spring.mustache.charset = UTF-8 ＃模板编码。&lt;br&gt;
spring.mustache.check-template-location = true ＃是否检查模板位置是否存在。&lt;br&gt;
spring.mustache.content-type = text / html ＃Content-Type value。&lt;br&gt;
spring.mustache.enabled = true ＃是否为此技术启用MVC视图分辨率。&lt;br&gt;
spring.mustache.expose-request-attributes = false ＃在与模板合并之前是否应将所有请求属性添加到模型中。&lt;br&gt;
spring.mustache.expose-session-attributes = false ＃在与模板合并之前是否应将所有HttpSession属性添加到模型中。&lt;br&gt;
spring.mustache.expose-spring-macro-helpers = true ＃是否公开一个RequestContext供Spring的宏库使用，名称为“springMacroRequestContext”。&lt;br&gt;
spring.mustache.prefix= classpath：/ templates / ＃适用于模板名称的前缀。&lt;br&gt;
spring.mustache.request-context-attribute = ＃所有视图的&lt;br&gt;
RequestContext属性的名称。spring.mustache.suffix = .mustache ＃后缀应用于模板名称。&lt;br&gt;
spring.mustache.view-names = ＃可以解析的视图名称的白名单。&lt;/p&gt;
&lt;p&gt;#SPRING MVC（WebMvcProperties）&lt;br&gt;
spring.mvc.async.request-timeout = ＃异步请求处理&lt;br&gt;
超时之前的时间。spring.mvc.contentnegotiation.favor-parameter = false ＃是否应使用请求参数（默认为“format”）来确定请求的媒体类型。&lt;br&gt;
spring.mvc.contentnegotiation.favor-path-extension = false ＃是否应使用URL路径中的路径扩展来确定所请求的媒体类型。&lt;br&gt;
spring.mvc.contentnegotiation.media-types。* = ＃映射内容协商的媒体类型的文件扩展名。例如，yml到text / yaml。&lt;br&gt;
spring.mvc.contentnegotiation.parameter-name =＃启用“favor-parameter”时要使用的查询参数名称。&lt;br&gt;
spring.mvc.date-format = ＃要使用的日期格式。例如，&lt;code&gt;dd / MM / yyyy&lt;/code&gt;。&lt;br&gt;
spring.mvc.dispatch-trace-request = false ＃是否将TRACE请求分派给FrameworkServlet doService方法。&lt;br&gt;
spring.mvc.dispatch-options-request = true ＃是否将OPTIONS请求分派给FrameworkServlet doService方法。&lt;br&gt;
spring.mvc.favicon.enabled = true ＃是否启用favicon.ico的解析。&lt;br&gt;
spring.mvc.formcontent.filter.enabled = true ＃是否启用Spring的FormContentFilter。&lt;br&gt;
spring.mvc.hiddenmethod.filter.enabled = true＃是否启用Spring的HiddenHttpMethodFilter。&lt;br&gt;
spring.mvc.ignore-default-model-on-redirect = true ＃在重定向场景中是否应忽略“默认”模型的内容。&lt;br&gt;
spring.mvc.locale = ＃要使用的语言环境。默认情况下，“Accept-Language”标头会覆盖此区域设置。&lt;br&gt;
spring.mvc.locale-resolver = accept-header ＃定义应如何解析语言环境。&lt;br&gt;
spring.mvc.log-resolved-exception = false ＃是否启用由“HandlerExceptionResolver”解析的异常的警告日志记录，“DefaultHandlerExceptionResolver”除外。&lt;br&gt;
spring.mvc.message-codes-resolver-format =＃格式化消息代码的策略。例如，&lt;code&gt;PREFIX_ERROR_CODE&lt;/code&gt;。&lt;br&gt;
spring.mvc.pathmatch.use-registered-suffix-pattern = false ＃后缀模式匹配是否仅适用于使用“spring.mvc.contentnegotiation.media-types。&lt;em&gt;”注册的扩展。&lt;br&gt;
spring.mvc.pathmatch.use-suffix-pattern = false ＃将模式与请求匹配时是否使用后缀模式匹配（“。&lt;/em&gt;”）。&lt;br&gt;
spring.mvc.servlet.load-on-startup = -1 ＃加载调度程序servlet的启动优先级。&lt;br&gt;
spring.mvc.servlet.path = / ＃调度程序servlet的路径。&lt;br&gt;
spring.mvc.static-path-pattern = / ** ＃用于静态资源的路径模式。&lt;br&gt;
spring.mvc.throw-exception-if-no-handler-found = false ＃如果没有找到Handler来处理请求，是否应该抛出“NoHandlerFoundException”。&lt;br&gt;
spring.mvc.view.prefix = #Spring MVC视图前缀。&lt;br&gt;
spring.mvc.view.suffix = #Spring MVC视图后缀。&lt;/p&gt;
&lt;p&gt;#SPRING RESOURCES HANDLING（ResourceProperties）&lt;br&gt;
spring.resources.add-mappings = true ＃是否启用默认资源处理。&lt;br&gt;
spring.resources.cache.cachecontrol.cache-private = ＃表示响应消息仅供单个用户使用，不得由共享高速缓存存储。&lt;br&gt;
spring.resources.cache.cachecontrol.cache-public = ＃表示任何缓存都可以存储响应。&lt;br&gt;
spring.resources.cache.cachecontrol.max-age = ＃应该缓存响应的最长时间，如果未指定持续时间后缀，则以秒为单位。&lt;br&gt;
spring.resources.cache.cachecontrol.must-revalidate =＃表示一旦它变得陈旧，缓存一定不能使用响应而不用服务器重新验证它。&lt;br&gt;
spring.resources.cache.cachecontrol.no-cache = ＃表示只有在与服务器重新验证时才能重用缓存的响应。&lt;br&gt;
spring.resources.cache.cachecontrol.no-store = ＃表示在任何情况下都不缓存响应。&lt;br&gt;
spring.resources.cache.cachecontrol.no-transform = ＃表明他们不应该转换响应内容的中介（缓存和其他人）。&lt;br&gt;
spring.resources.cache.cachecontrol.proxy-revalidate = ＃与“must-revalidate”指令的含义相同，但它不适用于私有缓存。&lt;br&gt;
spring.resources.cache.cachecontrol.s-max-age = ＃共享缓存应缓存响应的最长时间，如果未指定持续时间后缀，则以秒为单位。&lt;br&gt;
spring.resources.cache.cachecontrol.stale-if-error = ＃遇到错误时可以使用响应的最长时间，如果未指定持续时间后缀，则以秒为单位。&lt;br&gt;
spring.resources.cache.cachecontrol.stale-while-revalidate = ＃响应变为失效后可以响应的最长时间，如果未指定持续时间后缀，&lt;br&gt;
则以秒为单位。spring.resources.cache.period = ＃资源处理程序所服务资源的缓存周期。如果未指定持续时间后缀，则将使用秒。&lt;br&gt;
spring.resources.chain.cache= true ＃是否在资源链中启用缓存。&lt;br&gt;
spring.resources.chain.compressed = false ＃是否启用已压缩资源的解析（gzip，brotli）。&lt;br&gt;
spring.resources.chain.enabled = ＃是否启用Spring资源处理链。默认情况下，禁用，除非至少启用了一个策略。&lt;br&gt;
spring.resources.chain.html-application-cache = false ＃是否启用HTML5应用程序缓存清单重写。&lt;br&gt;
spring.resources.chain.strategy.content.enabled = false ＃是否启用内容版本策略。&lt;br&gt;
spring.resources.chain.strategy.content.paths = / **＃逗号分隔的模式列表，应用于内容版本策略。&lt;br&gt;
spring.resources.chain.strategy.fixed.enabled = false ＃是否启用固定版本策略。&lt;br&gt;
spring.resources.chain.strategy.fixed.paths = / ** ＃以逗号分隔的模式列表应用于固定版本策略。&lt;br&gt;
spring.resources.chain.strategy.fixed.version = ＃用于固定版本策略的版本字符串。&lt;br&gt;
spring.resources.static-locations = classpath：/ META-INF / resources /，classpath：/ resources /，classpath：/ static /，classpath：/ public / ＃静态资源的位置。&lt;/p&gt;
&lt;p&gt;#SPRING SESSION（SessionProperties）&lt;br&gt;
spring.session.store-type = ＃会话存储类型。&lt;br&gt;
spring.session.timeout = ＃会话超时。如果未指定持续时间后缀，则将使用秒。&lt;br&gt;
spring.session.servlet.filter-order = -2147483598 ＃会话存储库过滤顺序。&lt;br&gt;
spring.session.servlet.filter-dispatcher-types = async，error，request ＃会话存储库过滤器调度程序类型。&lt;/p&gt;
&lt;p&gt;#SPRING SESSION HAZELCAST（HazelcastSessionProperties）&lt;br&gt;
spring.session.hazelcast.flush-mode = on-save #sessions flush mode。&lt;br&gt;
spring.session.hazelcast.map-name = spring：session：sessions ＃用于存储会话的地图的名称。&lt;/p&gt;
&lt;p&gt;#SPRING SESSION JDBC（JdbcSessionProperties）&lt;br&gt;
spring.session.jdbc.cleanup-cron = 0 * * * * * #cron 表达式用于过期的会话清理作业。&lt;br&gt;
spring.session.jdbc.initialize-schema = embedded ＃数据库模式初始化模式。&lt;br&gt;
spring.session.jdbc.schema = classpath中：组织/ springframework的/会话/ JDBC / schema- @ @ 平台@ @ .SQL ＃的路径SQL文件，以用于初始化数据库架构。&lt;br&gt;
spring.session.jdbc.table-name = SPRING_SESSION ＃用于存储会话的数据库表的名称。&lt;/p&gt;
&lt;p&gt;#SPRING SESSION MONGODB（MongoSessionProperties）&lt;br&gt;
spring.session.mongodb.collection-name = sessions ＃用于存储会话的集合名称。&lt;/p&gt;
&lt;p&gt;#SPRING SESSION REDIS（RedisSessionProperties）&lt;br&gt;
spring.session.redis.cleanup-cron = 0 * * * * * #cron 表达式用于过期的会话清理作业。&lt;br&gt;
spring.session.redis.flush-mode = on-save #sessions flush mode。&lt;br&gt;
spring.session.redis.namespace = spring：session ＃用于存储会话的密钥的命名空间。&lt;/p&gt;
&lt;p&gt;#THYMELEAF（ThymeleafAutoConfiguration）&lt;br&gt;
spring.thymeleaf.cache = true ＃是否启用模板缓存。&lt;br&gt;
spring.thymeleaf.check-template = true ＃是否在呈现模板之前检查模板是否存在。&lt;br&gt;
spring.thymeleaf.check-template-location = true ＃是否检查模板位置是否存在。&lt;br&gt;
spring.thymeleaf.enabled = true ＃是否为Web框架启用Thymeleaf视图解析。&lt;br&gt;
spring.thymeleaf.enable-spring-el-compiler = false ＃在SpringEL表达式中启用SpringEL编译器。&lt;br&gt;
spring.thymeleaf.encoding = UTF-8 ＃模板文件编码。&lt;br&gt;
spring.thymeleaf.excluded-view-names = ＃逗号分隔的视图名称列表（允许的模式）应从分辨率中排除。&lt;br&gt;
spring.thymeleaf.mode = HTML ＃要应用于模板的模板模式。另请参见Thymeleaf的TemplateMode枚举。&lt;br&gt;
spring.thymeleaf.prefix = classpath：/ templates / ＃在构建URL时添加前缀以查看名称的前缀。&lt;br&gt;
spring.thymeleaf.reactive.chunked-mode-view-names = ＃逗号分隔的视图名称列表（允许的模式），当设置了最大块大小时，它应该是在CHUNKED模式下执行的唯一列表。&lt;br&gt;
spring.thymeleaf.reactive.full-mode-view-names =＃逗号分隔的视图名称列表（允许的模式），即使设置了最大块大小，也应该在FULL模式下执行。&lt;br&gt;
spring.thymeleaf.reactive.max-chunk-size = 0B ＃用于写入响应的数据缓冲区的最大大小。&lt;br&gt;
spring.thymeleaf.reactive.media-types = ＃视图技术支持的媒体类型。&lt;br&gt;
spring.thymeleaf.render-hidden-markers-before-checkboxes = false ＃是否应在复选框元素本身之前呈现隐藏的表单输入作为复选框的标记。&lt;br&gt;
spring.thymeleaf.servlet.content-type = text / html ＃Content-Type写入HTTP响应的值。&lt;br&gt;
spring.thymeleaf.servlet.produce-partial-output-while-processing = true#Thymeleaf是否应尽快开始编写部分输出或缓冲直到模板处理完成。&lt;br&gt;
spring.thymeleaf.suffix = .html ＃在构建URL时附加到视图名称的后缀。&lt;br&gt;
spring.thymeleaf.template-resolver-order = ＃链中模板解析器的顺序。&lt;br&gt;
spring.thymeleaf.view-names = ＃逗号分隔的视图名称列表（允许的模式），可以解析。&lt;/p&gt;
&lt;p&gt;#SPRING WEBFLUX（WebFluxProperties）&lt;br&gt;
spring.webflux.date-format = ＃要使用的日期格式。例如，&lt;code&gt;dd / MM / yyyy&lt;/code&gt;。&lt;br&gt;
spring.webflux.hiddenmethod.filter.enabled = true ＃是否启用Spring的HiddenHttpMethodFilter。&lt;br&gt;
spring.webflux.static-path-pattern = / ** ＃用于静态资源的路径模式。&lt;/p&gt;
&lt;p&gt;#SPRING WEB SERVICES（WebServicesProperties）&lt;br&gt;
spring.webservices.path = / services ＃作为服务基URI的路径。&lt;br&gt;
spring.webservices.servlet.init = ＃Servlet init参数传递给Spring Web Services。&lt;br&gt;
spring.webservices.servlet.load-on-startup = -1 ＃加载Spring Web Services servlet的启动优先级。&lt;br&gt;
spring.webservices.wsdl-locations = ＃逗号分隔的WSDL位置列表以及要作为bean公开的随附XSD。&lt;/p&gt;
&lt;p&gt;＃----------------------------------------&lt;br&gt;
＃SECURITY PROPERTIES&lt;br&gt;
＃----- -----------------------------------&lt;br&gt;
＃SECURITY（SecurityProperties）&lt;br&gt;
spring.security.filter.order = -100 ＃安全过滤器链顺序。&lt;br&gt;
spring.security.filter.dispatcher-types = async，error，request ＃安全过滤器链调度程序类型。&lt;br&gt;
spring.security.user.name = user ＃默认用户名。&lt;br&gt;
spring.security.user.password = ＃默认用户名的密码。&lt;br&gt;
spring.security.user.roles = ＃授予默认用户名的角色。&lt;/p&gt;
&lt;p&gt;＃SECURITY OAUTH2 CLIENT（OAuth2ClientProperties）&lt;br&gt;
spring.security.oauth2.client.provider。* = ＃OAuth提供商详细信息。&lt;br&gt;
spring.security.oauth2.client.registration。* = ＃OAuth客户注册。&lt;/p&gt;
&lt;p&gt;＃SECURITY OAUTH2 RESOURCE SERVER（OAuth2ResourceServerProperties）&lt;br&gt;
spring.security.oauth2.resourceserver.jwt.jwk-set-uri = ＃JSON用于验证JWT令牌的Web Key URI。&lt;br&gt;
spring.security.oauth2.resourceserver.jwt.issuer-uri = OpenID Connect Provider声明为其颁发者标识符的URI。&lt;/p&gt;
&lt;p&gt;＃----------------------------------------&lt;br&gt;
＃DATA PROPERTIES&lt;br&gt;
＃----- -----------------------------------&lt;/p&gt;
&lt;p&gt;#FLYWAY （FlywayProperties）&lt;br&gt;
spring.flyway.baseline-description = &amp;lt;&amp;lt; Flyway Baseline &amp;gt;&amp;gt; ＃描述在应用基线时标记现有模式。&lt;br&gt;
spring.flyway.baseline-on-migrate = false ＃是否在迁移非空架构时自动调用基线。&lt;br&gt;
spring.flyway.baseline-version = 1 ＃用于在执行基线时标记现有模式的版本。&lt;br&gt;
spring.flyway.check-location = true ＃是否检查迁移脚本位置是否存在。&lt;br&gt;
spring.flyway.clean-disabled = false ＃是否禁用数据库清理。&lt;br&gt;
spring.flyway.clean-on-validation-error = false＃发生验证错误时是否自动调用clean。&lt;br&gt;
spring.flyway.connect-retries = 0 ＃尝试连接数据库时的最大重试次数。&lt;br&gt;
spring.flyway.enabled = true ＃是否启用flyway。&lt;br&gt;
spring.flyway.encoding = UTF-8 #SQL 迁移的编码。&lt;br&gt;
spring.flyway.group = false ＃是否在应用它们时在同一事务中将所有挂起的迁移组合在一起。&lt;br&gt;
spring.flyway.ignore-future-migrations = true ＃在读取架构历史记录表时是否忽略未来的迁移。&lt;br&gt;
spring.flyway.ignore-ignored-migrations = false＃是否在读取模式历史记录表时忽略忽略的迁移。&lt;br&gt;
spring.flyway.ignore-missing-migrations = false ＃是否在读取模式历史记录表时忽略缺少的迁移。&lt;br&gt;
spring.flyway.ignore-pending-migrations = false ＃在读取架构历史记录表时是否忽略挂起的迁移。&lt;br&gt;
spring.flyway.init-sqls = ＃在获取连接后立即执行以初始化连接的SQL语句。&lt;br&gt;
spring.flyway.installed-by = ＃用户名在架构历史记录表中记录为已应用迁移。&lt;br&gt;
spring.flyway.locations = classpath：db / migration＃迁移脚本的位置。可以包含特殊的“{vendor}”占位符以使用特定于供应商的位置。&lt;br&gt;
spring.flyway.mixed = false ＃是否允许在同一迁移中混合事务和非事务语句。&lt;br&gt;
spring.flyway.out-of-order = false ＃是否允许迁移无序运行。&lt;br&gt;
spring.flyway.password = ＃要迁移的数据库的登录密码。&lt;br&gt;
spring.flyway.placeholder-prefix = $ { ＃迁移脚本中占位符的前缀。&lt;br&gt;
spring.flyway.placeholder-replacement = true ＃在迁移脚本中执行占位符替换。&lt;br&gt;
spring.flyway.placeholder-suffix =}＃迁移脚本中占位符的后缀。&lt;br&gt;
spring.flyway.placeholders = ＃占位符及其替换应用于sql迁移脚本。&lt;br&gt;
spring.flyway.repeatable-sql-migration-prefix = R ＃可重复SQL迁移的文件名前缀。&lt;br&gt;
spring.flyway.schemas = ＃由&lt;br&gt;
Flyway 管理的方案名称（区分大小写）。spring.flyway.skip-default-callbacks = false ＃是否跳过默认回调。如果为true，则仅使用自定义回调。&lt;br&gt;
spring.flyway.skip-default-resolvers = false ＃是否跳过默认的解析器。如果为true，则仅使用自定义解析程序。&lt;br&gt;
spring.flyway.sql-migration-prefix = V.#SQL迁移的文件名前缀。&lt;br&gt;
spring.flyway.sql-migration-separator = __ #SQL迁移的文件名分隔符。&lt;br&gt;
spring.flyway.sql-migration-suffixes = .sql #SQL迁移的文件名后缀。&lt;br&gt;
spring.flyway.table = flyway_schema_history ＃&lt;br&gt;
将由 Flyway 使用的架构架构历史记录表的名称。spring.flyway.target = ＃应考虑迁移的目标版本。&lt;br&gt;
spring.flyway.url = 要迁移的数据库的JDBC url。如果未设置，则使用主要配置的数据源。&lt;br&gt;
spring.flyway.user = ＃要迁移的数据库的登录用户。&lt;br&gt;
spring.flyway.validate-on-migrate = true ＃是否在执行迁移时自动调用validate。&lt;/p&gt;
&lt;p&gt;#LIQUIBASE（LiquibaseProperties）&lt;br&gt;
spring.liquibase.change-log = classpath：/db/changelog/db.changelog-master.yaml# 更改日志配置路径。&lt;br&gt;
spring.liquibase.check-change-log-location = true ＃是否检查更改日志位置是否存在。&lt;br&gt;
spring.liquibase.contexts = ＃逗号分隔的运行时上下文列表。&lt;br&gt;
spring.liquibase.database-change-log-lock-table = DATABASECHANGELOGLOCK ＃用于跟踪并发Liquibase用法的表的名称。&lt;br&gt;
spring.liquibase.database-change-log-table = DATABASECHANGELOG ＃用于跟踪更改历史&lt;br&gt;
记录的表的名称。spring.liquibase.default-模式= ＃默认数据库架构。&lt;br&gt;
spring.liquibase.drop-first = false ＃是否首先删除数据库模式。&lt;br&gt;
spring.liquibase.enabled = true ＃是否启用Liquibase支持。&lt;br&gt;
spring.liquibase.labels = ＃逗号分隔的运行时标签列表。&lt;br&gt;
spring.liquibase.liquibase-schema = #Schema用于Liquibase对象。&lt;br&gt;
spring.liquibase.liquibase-tablespace = ＃用于Liquibase对象的表空间。&lt;br&gt;
spring.liquibase.parameters。* = ＃更改日志参数。&lt;br&gt;
spring.liquibase.password = ＃要迁移的数据库的登录密码。&lt;br&gt;
spring.liquibase.rollback-file = ＃执行更新时写入回滚SQL的文件。&lt;br&gt;
spring.liquibase.test-rollback-on-update = false ＃是否应在执行更新之前测试回滚。&lt;br&gt;
spring.liquibase.url = ＃JDBC要迁移的数据库的URL。如果未设置，则使用主要配置的数据源。&lt;br&gt;
spring.liquibase.user = ＃要迁移的数据库的登录用户。&lt;/p&gt;
&lt;p&gt;＃COUCHBASE（CouchbaseProperties）&lt;br&gt;
spring.couchbase.bootstrap-hosts = #Couchbase 节点（主机或IP地址）来自引导程序。&lt;br&gt;
spring.couchbase.bucket.name = default ＃要连接的存储桶的名称。&lt;br&gt;
spring.couchbase.bucket.password =   ＃桶的密码。&lt;br&gt;
spring.couchbase.env.endpoints.key-value = 1 ＃针对键/值服务的每个节点的套接字数。&lt;br&gt;
spring.couchbase.env.endpoints.queryservice.min-endpoints = 1 ＃每个节点的最小套接字数。&lt;br&gt;
spring.couchbase.env.endpoints.queryservice.max-endpoints = 1 ＃每个节点的最大套接字数。&lt;br&gt;
spring.couchbase.env.endpoints.viewservice.min-endpoints = 1 ＃每个节点的最小套接字数。&lt;br&gt;
spring.couchbase.env.endpoints.viewservice.max-endpoints = 1 ＃每个节点的最大套接字数。&lt;br&gt;
spring.couchbase.env.ssl.enabled = ＃是否启用SSL支持。除非另有说明，否则在提供“keyStore”时自动启用。&lt;br&gt;
spring.couchbase.env.ssl.key-store = ＃保存证书的JVM密钥库的路径。&lt;br&gt;
spring.couchbase.env.ssl.key-store-password = ＃用于访问密钥库的密码。&lt;br&gt;
spring.couchbase.env.timeouts.connect = 5000ms ＃桶连接超时。&lt;br&gt;
spring.couchbase.env.timeouts.key-value = 2500ms ＃对特定密钥超时执行的阻止操作。&lt;br&gt;
spring.couchbase.env.timeouts.query = 7500ms ＃N1QL查询操作超时。&lt;br&gt;
spring.couchbase.env.timeouts.socket-connect = 1000ms #Socket 连接超时。&lt;br&gt;
spring.couchbase.env.timeouts.view = 7500ms ＃常规和地理空间视图操作超时。&lt;/p&gt;
&lt;p&gt;#DAO （PersistenceExceptionTranslationAutoConfiguration）&lt;br&gt;
spring.dao.exceptiontranslation.enabled = true ＃是否启用PersistenceExceptionTranslationPostProcessor。&lt;/p&gt;
&lt;p&gt;#CASSANDRA （CassandraProperties）&lt;br&gt;
spring.data.cassandra.cluster-name = #Cassandra 集群的名称。&lt;br&gt;
spring.data.cassandra.compression = none ＃Cassandra二进制协议支持的压缩。&lt;br&gt;
spring.data.cassandra.connect-timeout = #Socket 选项：连接超时。&lt;br&gt;
spring.data.cassandra.consistency-level = ＃查询一致性级别。&lt;br&gt;
spring.data.cassandra.contact-points = localhost ＃群集节点地址。&lt;br&gt;
spring.data.cassandra.fetch-size = ＃查询默认提取大小。&lt;br&gt;
spring.data.cassandra.jmx-enabled = false＃是否启用JMX报告。&lt;br&gt;
spring.data.cassandra.keyspace-name = ＃要使用的Keyspace名称。&lt;br&gt;
spring.data.cassandra.port = #Cassandra 服务器的端口。&lt;br&gt;
spring.data.cassandra.password = ＃服务器的登录密码。&lt;br&gt;
spring.data.cassandra.pool.heartbeat-interval = 30s #Heartbeat interval，在此之后，在空闲连接上发送消息以确保它仍然存在。如果未指定持续时间后缀，则将使用秒。&lt;br&gt;
spring.data.cassandra.pool.idle-timeout = 120s ＃删除空闲连接之前的空闲超时。如果未指定持续时间后缀，则将使用秒。&lt;br&gt;
spring.data.cassandra.pool.max队列大小= 256 ＃如果没有可用连接，则排队的最大请求数。&lt;br&gt;
spring.data.cassandra.pool.pool-timeout = 5000ms ＃尝试从主机池获取连接时的池超时。&lt;br&gt;
spring.data.cassandra.read-timeout = #Socket 选项：读取超时。&lt;br&gt;
spring.data.cassandra.repositories.type = auto ＃要启用的Cassandra存储库的类型。&lt;br&gt;
spring.data.cassandra.serial-consistency-level = ＃查询串行一致性级别。&lt;br&gt;
spring.data.cassandra.schema-action = none ＃启动时要采取的架构操作。&lt;br&gt;
spring.data.cassandra.ssl = false ＃启用SSL支持。&lt;br&gt;
spring.data.cassandra.username = ＃服务器的登录用户。&lt;/p&gt;
&lt;p&gt;#DATA COUCHBASE（CouchbaseDataProperties）&lt;br&gt;
spring.data.couchbase.auto-index = false ＃自动创建视图和索引。&lt;br&gt;
spring.data.couchbase.consistency = read-your-own-writes ＃在生成的查询中默认应用的一致性。&lt;br&gt;
spring.data.couchbase.repositories.type = auto ＃要启用的Couchbase存储库的类型。&lt;/p&gt;
&lt;p&gt;#ELASTICSEARCH（ElasticsearchProperties）&lt;br&gt;
spring.data.elasticsearch.cluster-name = elasticsearch ＃Elasticsearch集群名称。&lt;br&gt;
spring.data.elasticsearch.cluster-nodes = ＃逗号分隔的集群节点地址列表。&lt;br&gt;
spring.data.elasticsearch.properties。* = ＃用于配置客户端的其他属性。&lt;br&gt;
spring.data.elasticsearch.repositories.enabled = true ＃是否启用Elasticsearch存储库。&lt;/p&gt;
&lt;p&gt;#DATA JDBC spring.data.jdbc.repositories.enabled = true ＃是否启用JDBC存储库。&lt;/p&gt;
&lt;p&gt;#DATA LDAP spring.data.ldap.repositories.enabled = true ＃是否启用LDAP存储库。&lt;/p&gt;
&lt;p&gt;#MONGODB（MongoProperties）&lt;br&gt;
spring.data.mongodb.authentication-database = ＃认证数据库名称。&lt;br&gt;
spring.data.mongodb.database = ＃数据库名称。&lt;br&gt;
spring.data.mongodb.field-naming-strategy = ＃要使用的FieldNamingStrategy的完全限定名称。&lt;br&gt;
spring.data.mongodb.grid-fs-database = ＃GridFS数据库名称。&lt;br&gt;
spring.data.mongodb.host = #Mongo 服务器主机。无法使用URI设置。&lt;br&gt;
spring.data.mongodb.password = #mongo 服务器的登录密码。无法使用URI设置。&lt;br&gt;
spring.data.mongodb.port = #Mongo 服务器端口。无法使用URI设置。&lt;br&gt;
spring.data.mongodb.repositories.type = auto ＃要启用的Mongo存储库的类型。&lt;br&gt;
spring.data.mongodb.uri = mongodb：// localhost / test ＃Mongo数据库URI。无法使用主机，端口和凭据进行设置。&lt;br&gt;
spring.data.mongodb.username = #mongo 服务器的登录用户。无法使用URI设置。&lt;/p&gt;
&lt;p&gt;#DATA REDIS&lt;br&gt;
spring.data.redis.repositories.enabled = true ＃是否启用Redis存储库。&lt;/p&gt;
&lt;p&gt;＃NEO4J（Neo4jProperties）&lt;br&gt;
spring.data.neo4j.auto-index = none ＃自动索引模式。&lt;br&gt;
spring.data.neo4j.embedded.enabled = true ＃如果嵌入式驱动程序可用，是否启用嵌入模式。&lt;br&gt;
spring.data.neo4j.open-in-view = true ＃注册OpenSessionInViewInterceptor。将Neo4j会话绑定到线程以进行整个请求处理。&lt;br&gt;
spring.data.neo4j.password = ＃服务器的登录密码。&lt;br&gt;
spring.data.neo4j.repositories.enabled = true ＃是否启用Neo4j存储库。&lt;br&gt;
spring.data.neo4j.uri = 驱动程序使用的#URL 。默认情况下自动检测。&lt;br&gt;
spring.data.neo4j.username = ＃服务器的登录用户。&lt;/p&gt;
&lt;p&gt;#DATA REST（RepositoryRestProperties）&lt;br&gt;
spring.data.rest.base-path = #Spring Data REST用于公开存储库资源的基本路径。&lt;br&gt;
spring.data.rest.default-media-type = ＃未指定时用作默认值的内容类型。&lt;br&gt;
spring.data.rest.default-page-size = ＃默认页面大小。&lt;br&gt;
spring.data.rest.detection-strategy = default ＃用于确定暴露哪些存储库的策略。&lt;br&gt;
spring.data.rest.enable-enum-translation = ＃是否通过Spring Data REST默认资源包启用枚举值转换。&lt;br&gt;
spring.data.rest.limit-param-name =#URL查询字符串参数的名称，指示一次返回多少结果。&lt;br&gt;
spring.data.rest.max-page-size = ＃最大页面大小。&lt;br&gt;
spring.data.rest.page-param-name = #URL 查询字符串参数的名称，指示要返回的页面。&lt;br&gt;
spring.data.rest.return-body-on-create = ＃是否在创建实体后返回响应正文。&lt;br&gt;
spring.data.rest.return-body-on-update = ＃更新实体后是否返回响应正文。&lt;br&gt;
spring.data.rest.sort-param-name = #URL 查询字符串参数的名称，指示对结果进行排序的方向。&lt;/p&gt;
&lt;p&gt;#SOLR （SolrProperties）&lt;br&gt;
spring.data.solr.host = http：//127.0.0.1：8983 / solr #Solr host。如果设置了“zk-host”，则忽略。&lt;br&gt;
spring.data.solr.repositories.enabled = true ＃是否启用Solr存储库。&lt;br&gt;
spring.data.solr.zk-host = ＃ZooKeeper主机地址，格式为HOST：PORT。&lt;/p&gt;
&lt;p&gt;＃DATA WEB（SpringDataWebProperties）&lt;br&gt;
spring.data.web.pageable.default页大小 = 20 ＃缺省页大小。&lt;br&gt;
spring.data.web.pageable.max-page-size = 2000 ＃要接受的最大页面大小。&lt;br&gt;
spring.data.web.pageable.one-indexed-parameters = false ＃是否公开和假设从1开始的页码索引。&lt;br&gt;
spring.data.web.pageable.page-parameter = page ＃页面索引参数名称。&lt;br&gt;
spring.data.web.pageable.prefix = ＃&lt;br&gt;
常用前缀，用于页码和页面大小参数。spring.data.web.pageable.qualifier-delimiter = _＃限定符与实际页码和大小属性之间使用的分隔符。&lt;br&gt;
spring.data.web.pageable.size-parameter = size ＃页面大小参数名称。&lt;br&gt;
spring.data.web.sort.sort-parameter = sort ＃排序参数名称。&lt;/p&gt;
&lt;p&gt;#DATASOURCE （DataSourceAutoConfiguration＆DataSourceProperties）&lt;br&gt;
spring.datasource.continue-on-error = false ＃初始化数据库时是否发生错误时停止。&lt;br&gt;
spring.datasource.data = #Data （DML）脚本资源引用。&lt;br&gt;
spring.datasource.data-username = ＃用于执行DML脚本的数据库&lt;br&gt;
的用户名（如果不同）。spring.datasource.data-password = ＃执行DML脚本的数据库的密码（如果不同）。&lt;br&gt;
spring.datasource.dbcp2。* = ＃Commons DBCP2特定设置&lt;br&gt;
spring.datasource.driver-class-name =#JDBC驱动程序的完全限定名称。默认情况下，基于URL自动检测。&lt;br&gt;
spring.datasource.generate-unique-name = false ＃是否生成随机数据源名称。&lt;br&gt;
spring.datasource.hikari。* = ＃Hikari特定设置&lt;br&gt;
spring.datasource.initialization-mode = embedded ＃使用可用的DDL和DML脚本初始化数据源。&lt;br&gt;
spring.datasource.jmx-enabled = false ＃是否启用JMX支持（如果由基础池提供）。&lt;br&gt;
spring.datasource.jndi-name = ＃JNDI数据源的位置。设置时将忽略类，URL，用户名和密码。&lt;br&gt;
spring.datasource.name =＃数据源的名称。使用嵌入式数据库时默认为“testdb”。&lt;br&gt;
spring.datasource.password = ＃数据库的登录密码。&lt;br&gt;
spring.datasource.platform = all ＃在DDL或DML脚本中使用的平台（例如架构 -  $ {platform} .sql或data  -  $ {platform} .sql）。&lt;br&gt;
spring.datasource.schema = #Schema （DDL）脚本资源引用。&lt;br&gt;
spring.datasource.schema-username = ＃执行DDL脚本的数据库&lt;br&gt;
的用户名（如果不同）。spring.datasource.schema-password = ＃执行DDL脚本的数据库的密码（如果不同）。&lt;br&gt;
spring.datasource.separator =;#SQL初始化脚本中的语句分隔符。&lt;br&gt;
spring.datasource.sql-script-encoding = #SQL 脚本编码。&lt;br&gt;
spring.datasource.tomcat。* = ＃Tomcat数据源特定设置&lt;br&gt;
spring.datasource.type = ＃要使用的连接池实现的完全限定名称。默认情况下，它是从类路径中自动检测到的。&lt;br&gt;
spring.datasource.url = ＃JDBC数据库的URL。&lt;br&gt;
spring.datasource.username = ＃登录数据库的用户名。&lt;br&gt;
spring.datasource.xa.data-source-class-name = #XA 数据源完全限定名称。&lt;br&gt;
spring.datasource.xa.properties =＃传递给XA数据源的属性。&lt;/p&gt;
&lt;p&gt;#JEST （Elasticsearch HTTP客户端）（JestProperties）&lt;br&gt;
spring.elasticsearch.jest.connection-timeout = 3s ＃连接超时。&lt;br&gt;
spring.elasticsearch.jest.multi-threaded = true ＃是否从多个执行线程启用连接请求。&lt;br&gt;
spring.elasticsearch.jest.password = ＃登录密码。&lt;br&gt;
spring.elasticsearch.jest.proxy.host = #HTTP 客户端应使用的代理主机。&lt;br&gt;
spring.elasticsearch.jest.proxy.port = #HTTP 客户端应使用的代理端口。&lt;br&gt;
spring.elasticsearch.jest.read-timeout = 3s ＃读取超时。&lt;br&gt;
spring.elasticsearch.jest.uris = http：// localhost：9200＃逗号分隔的Elasticsearch实例列表。&lt;br&gt;
spring.elasticsearch.jest.username = ＃登录用户名。&lt;/p&gt;
&lt;p&gt;#Elasticsearch REST客户端（RestClientProperties）&lt;br&gt;
spring.elasticsearch.rest.password = ＃凭据密码。&lt;br&gt;
spring.elasticsearch.rest.uris = http：// localhost：9200 ＃要使用的以逗号分隔的Elasticsearch实例列表。&lt;br&gt;
spring.elasticsearch.rest.username = ＃凭据用户名。&lt;/p&gt;
&lt;p&gt;＃H2 Web控制台（H2ConsoleProperties）&lt;br&gt;
spring.h2.console.enabled = false ＃是否启用控制台。&lt;br&gt;
spring.h2.console.path = / h2-console ＃控制台可用的路径。&lt;br&gt;
spring.h2.console.settings.trace = false ＃是否启用跟踪输出。&lt;br&gt;
spring.h2.console.settings.web-allow-others = false ＃是否启用远程访问。&lt;/p&gt;
&lt;p&gt;＃InfluxDB（InfluxDbProperties）&lt;br&gt;
spring.influx.password = ＃登录密码。&lt;br&gt;
spring.influx.url = 要连接的InfluxDB实例的URL。&lt;br&gt;
spring.influx.user = ＃登录用户。&lt;/p&gt;
&lt;p&gt;＃JOOQ （JooqProperties）&lt;br&gt;
spring.jooq.sql-dialect = #SQL 方言使用。默认情况下自动检测。&lt;/p&gt;
&lt;p&gt;#JDBC （JdbcProperties）&lt;br&gt;
spring.jdbc.template.fetch-size = -1 ＃需要更多行时应从数据库中提取的行数。&lt;br&gt;
spring.jdbc.template.max-rows = -1 ＃最大行数。&lt;br&gt;
spring.jdbc.template.query-timeout = ＃查询超时。默认是使用JDBC驱动程序的默认配置。如果未指定持续时间后缀，则将使用秒。&lt;/p&gt;
&lt;p&gt;＃JPA （JpaBaseConfiguration，HibernateJpaAutoConfiguration）&lt;br&gt;
spring.data.jpa.repositories.bootstrap-mode = default #JAPA 存储库的Bootstrap模式。&lt;br&gt;
spring.data.jpa.repositories.enabled = true ＃是否启用JPA存储库。&lt;br&gt;
spring.jpa.database = ＃要操作的目标数据库，默认情况下自动检测。也可以使用“databasePlatform”属性进行设置。&lt;br&gt;
spring.jpa.database-platform = ＃要操作的目标数据库的名称，默认情况下自动检测。也可以使用“Database”枚举来设置。&lt;br&gt;
spring.jpa.generate-ddl = false ＃是否在启动时初始化架构。&lt;br&gt;
spring.jpa.hibernate.ddl-auto = ＃DDL模式。这实际上是“hibernate.hbm2ddl.auto”属性的快捷方式。使用嵌入式数据库时未默认为“create-drop”，并且未检测到架构管理器。否则，默认为“none”。&lt;br&gt;
spring.jpa.hibernate.naming.implicit-strategy = ＃隐式命名策略的完全限定名称。&lt;br&gt;
spring.jpa.hibernate.naming.physical-strategy = ＃物理命名策略的完全限定名称。&lt;br&gt;
spring.jpa.hibernate.use-new-id-generator-mappings = ＃是否将Hibernate的较新的IdentifierGenerator用于AUTO，TABLE和SEQUENCE。&lt;br&gt;
spring.jpa.mapping-resources =＃Mapping资源（相当于persistence.xml中的“mapping-file”条目）。&lt;br&gt;
spring.jpa.open-in-view = true ＃注册OpenEntityManagerInViewInterceptor。将JPA EntityManager绑定到线程以进行整个请求处理。&lt;br&gt;
spring.jpa.properties。* = ＃要在JPA提供程序上设置的其他本机属性。&lt;br&gt;
spring.jpa.show -sql = false ＃是否启用SQL语句的日志记录。&lt;/p&gt;
&lt;p&gt;#JTA （JtaAutoConfiguration）&lt;br&gt;
spring.jta.enabled = true ＃是否启用JTA支持。&lt;br&gt;
spring.jta.log-dir = #Transaction logs目录。&lt;br&gt;
spring.jta.transaction-manager-id = #Transaction manager唯一标识符。&lt;/p&gt;
&lt;p&gt;#ATOMIKOS（AtomikosProperties）&lt;br&gt;
spring.jta.atomikos.connectionfactory.borrow-connection-timeout = 30 ＃从池中借用连接的超时（以秒为单位）。&lt;br&gt;
spring.jta.atomikos.connectionfactory.ignore-session-transacted-flag = true ＃是否在创建会话时忽略事务处理标志。&lt;br&gt;
spring.jta.atomikos.connectionfactory.local-transaction-mode = false ＃是否需要本地事务。&lt;br&gt;
spring.jta.atomikos.connectionfactory.maintenance-interval = 60 ＃池维护线程运行之间的时间（以秒为单位）。&lt;br&gt;
spring.jta.atomikos.connectionfactory.max-idle-time = 60＃从池中清除连接的时间（以秒为单位）。&lt;br&gt;
spring.jta.atomikos.connectionfactory.max-lifetime = 0 ＃连接在被销毁之前可以合并的时间（以秒为单位）。0表示没有限制。&lt;br&gt;
spring.jta.atomikos.connectionfactory.max-pool-size = 1 ＃池的最大大小。&lt;br&gt;
spring.jta.atomikos.connectionfactory.min-pool-size = 1 ＃池的最小大小。&lt;br&gt;
spring.jta.atomikos.connectionfactory.reap-timeout = 0 ＃借用连接的reap超时（以秒为单位）。0表示没有限制。&lt;br&gt;
spring.jta.atomikos.connectionfactory.unique-resource-name = jmsConnectionFactory＃用于在恢复期间标识资源的唯一名称。&lt;br&gt;
spring.jta.atomikos.connectionfactory.xa-connection-factory-class-name = #XAConnectionFactory的供应商特定实现。&lt;br&gt;
spring.jta.atomikos.connectionfactory.xa-properties = ＃供应商特定的XA属性。&lt;br&gt;
spring.jta.atomikos.datasource.borrow-connection-timeout = 30 ＃从池中借用连接的超时时间（秒）。&lt;br&gt;
spring.jta.atomikos.datasource.concurrent-connection-validation = ＃是否使用并发连接验证。&lt;br&gt;
spring.jta.atomikos.datasource.default-isolation-level = ＃池提供的连接的默认隔离级别。&lt;br&gt;
spring.jta.atomikos.datasource.login-timeout = ＃用于建立数据库连接的超时（以秒为单位）。&lt;br&gt;
spring.jta.atomikos.datasource.maintenance-interval = 60 ＃池维护线程运行之间的时间（以秒为单位）。&lt;br&gt;
spring.jta.atomikos.datasource.max-idle-time = 60 ＃从池中清除连接的时间（以秒为单位）。&lt;br&gt;
spring.jta.atomikos.datasource.max-lifetime = 0 ＃连接在被销毁之前可以合并的时间（以秒为单位）。0表示没有限制。&lt;br&gt;
spring.jta.atomikos.datasource.max-pool-size = 1 ＃池的最大大小。&lt;br&gt;
spring.jta.atomikos.datasource.min-pool-size = 1＃池的最小大小。&lt;br&gt;
spring.jta.atomikos.datasource.reap-timeout = 0 ＃借用连接的reap超时（以秒为单位）。0表示没有限制。&lt;br&gt;
spring.jta.atomikos.datasource.test-query = ＃用于在返回连接之前验证连接的SQL查询或语句。&lt;br&gt;
spring.jta.atomikos.datasource.unique-resource-name = dataSource ＃用于在恢复期间标识资源的唯一名称。&lt;br&gt;
spring.jta.atomikos.datasource.xa-data-source-class-name = #XAConnectionFactory的供应商特定实现。&lt;br&gt;
spring.jta.atomikos.datasource.xa-properties = ＃供应商特定的XA属性。&lt;br&gt;
spring.jta.atomikos.properties.allow-sub-transactions = true ＃指定是否允许子事务。&lt;br&gt;
spring.jta.atomikos.properties.checkpoint-interval = 500 ＃检查点之间的间隔，表示为两个检查点之间的日志写入次数。&lt;br&gt;
spring.jta.atomikos.properties.default -jta -timeout = 10000ms #JTA 事务的默认超时。&lt;br&gt;
spring.jta.atomikos.properties.default-max-wait-time-on-shutdown = 9223372036854775807 ＃正常关闭（no-force）等待事务完成的时间。&lt;br&gt;
spring.jta.atomikos.properties.enable-logging = true ＃是否启用磁盘日志记录。&lt;br&gt;
spring.jta.atomikos.properties.force-shutdown-on-vm-exit = false ＃虚拟机关闭是否应触发事务核心的强制关闭。&lt;br&gt;
spring.jta.atomikos.properties.log-base-dir = ＃应存储日志文件的目录。&lt;br&gt;
spring.jta.atomikos.properties.log-base-name = tmlog ＃Transactions日志文件基名。&lt;br&gt;
spring.jta.atomikos.properties.max-actives = 50 ＃最大活动事务数。&lt;br&gt;
spring.jta.atomikos.properties.max-timeout = 300000ms ＃事务允许的最大超时时间。&lt;br&gt;
spring.jta.atomikos.properties.recovery.delay = 10000ms ＃两次恢复扫描之间的延迟。&lt;br&gt;
spring.jta.atomikos.properties.recovery.forget- orphaned -log-entries-delay = 86400000ms ＃恢复之后的延迟可以清除挂起（&#39;孤立&#39;）日志条目。&lt;br&gt;
spring.jta.atomikos.properties.recovery.max-retries = 5 ＃在抛出异常之前提交事务的重试次数。&lt;br&gt;
spring.jta.atomikos.properties.recovery.retry-interval = 10000ms ＃重试尝试之间的延迟。&lt;br&gt;
spring.jta.atomikos.properties.serial-jta-transactions = true ＃是否应尽可能加入子事务。&lt;br&gt;
spring.jta.atomikos.properties.service = ＃应该启动的事务管理器实现。&lt;br&gt;
spring.jta.atomikos.properties.threaded-two-phase-commit = false ＃是否对参与资源使用不同（和并发）线程进行两阶段提交。&lt;br&gt;
spring.jta.atomikos.properties.transaction-manager-unique-name = ＃事务管理器的唯一名称。&lt;/p&gt;
&lt;p&gt;＃BITRONIX&lt;br&gt;
spring.jta.bitronix.connectionfactory.acquire-increment = 1 ＃在增长池时创建的连接数。&lt;br&gt;
spring.jta.bitronix.connectionfactory.acquisition-interval = 1 ＃获取无效连接后再次尝试获取连接之前等待的时间（以秒为单位）。&lt;br&gt;
spring.jta.bitronix.connectionfactory.acquisition-timeout = 30 ＃从池中获取连接的超时时间（秒）。&lt;br&gt;
spring.jta.bitronix.connectionfactory.allow-local-transactions = true ＃事务管理器是否应该允许混合XA和非XA事务。&lt;br&gt;
spring.jta.bitronix.connectionfactory.apply-transaction-timeout = false＃是否应在登记时在XAResource上设置事务超时。&lt;br&gt;
spring.jta.bitronix.connectionfactory.automatic-enlisting-enabled = true ＃是否应自动登记和退出资源。&lt;br&gt;
spring.jta.bitronix.connectionfactory.cache-producer-consumers = true ＃是否应该缓存生产者和消费者。&lt;br&gt;
spring.jta.bitronix.connectionfactory.class-name = #XA 资源的底层实现类名。&lt;br&gt;
spring.jta.bitronix.connectionfactory.defer-connection-release = true ＃提供程序是否可以在同一连接上运行多个事务并支持事务交错。&lt;br&gt;
spring.jta.bitronix.connectionfactory.disabled= ＃是否禁用此资源，这意味着暂时禁止从其池中获取连接。&lt;br&gt;
spring.jta.bitronix.connectionfactory.driver-properties = ＃应在底层实现上设置的属性。&lt;br&gt;
spring.jta.bitronix.connectionfactory.failed = ＃将此资源生成器标记为失败。&lt;br&gt;
spring.jta.bitronix.connectionfactory.ignore-recovery-failures = false ＃是否应忽略恢复失败。&lt;br&gt;
spring.jta.bitronix.connectionfactory.max-idle-time = 60 ＃从池中清除连接的时间（以秒为单位）。&lt;br&gt;
spring.jta.bitronix.connectionfactory.max-pool-size = 10＃池的最大大小。0表示没有限制。&lt;br&gt;
spring.jta.bitronix.connectionfactory.min-pool-size = 0 ＃池的最小大小。&lt;br&gt;
spring.jta.bitronix.connectionfactory.password = ＃用于连接JMS提供程序的密码。&lt;br&gt;
spring.jta.bitronix.connectionfactory.share-transaction-connections = false ＃是否可以在事务上下文中共享处于ACCESSIBLE状态的连接。&lt;br&gt;
spring.jta.bitronix.connectionfactory.test-connections = true ＃从池中获取时是否应测试连接。&lt;br&gt;
spring.jta.bitronix.connectionfactory.two-pc-ordering-position = 1＃在两阶段提交期间此资源应采取的位置（始终是第一个是Integer.MIN_VALUE，总是最后一个是Integer.MAX_VALUE）。&lt;br&gt;
spring.jta.bitronix.connectionfactory.unique-name = jmsConnectionFactory ＃用于在恢复期间标识资源的唯一名称。&lt;br&gt;
spring.jta.bitronix.connectionfactory.use -tm&lt;br&gt;
-join = true ＃启动XAResources时是否应该使用TMJOIN。spring.jta.bitronix.connectionfactory.user = ＃用于连接到JMS提供程序的用户。&lt;br&gt;
spring.jta.bitronix.datasource.acquire-increment = 1 ＃在增长池时创建的连接数。&lt;br&gt;
spring.jta.bitronix.datasource.acquisition-interval = 1＃在获取无效连接后再次尝试获取连接之前等待的时间（以秒为单位）。&lt;br&gt;
spring.jta.bitronix.datasource.acquisition-timeout = 30 ＃从池中获取连接的超时时间（秒）。&lt;br&gt;
spring.jta.bitronix.datasource.allow-local-transactions = true ＃事务管理器是否应该允许混合XA和非XA事务。&lt;br&gt;
spring.jta.bitronix.datasource.apply-transaction-timeout = false ＃是否应在XAResource登记时设置事务超时。&lt;br&gt;
spring.jta.bitronix.datasource.automatic-enlisting-enabled = true ＃是否应自动登记和退出资源。&lt;br&gt;
spring.jta.bitronix.datasource.class-name = #XA 资源的底层实现类名。&lt;br&gt;
spring.jta.bitronix.datasource.cursor-holdability = ＃连接的默认光标可保持性。&lt;br&gt;
spring.jta.bitronix.datasource.defer-connection-release = true ＃数据库是否可以在同一连接上运行多个事务并支持事务交错。&lt;br&gt;
spring.jta.bitronix.datasource.disabled = ＃是否禁用此资源，这意味着暂时禁止从其池中获取连接。&lt;br&gt;
spring.jta.bitronix.datasource.driver-properties = ＃应在底层实现上设置的属性。&lt;br&gt;
spring.jta.bitronix.datasource.enable -jdbc4-connection-test = ＃从池中获取连接时是否调用Connection.isValid（）。&lt;br&gt;
spring.jta.bitronix.datasource.failed = ＃将此资源生成器标记为失败。&lt;br&gt;
spring.jta.bitronix.datasource.ignore-recovery-failures = false ＃是否应忽略恢复失败。&lt;br&gt;
spring.jta.bitronix.datasource.isolation-level = ＃连接的默认隔离级别。&lt;br&gt;
spring.jta.bitronix.datasource.local-auto-commit = ＃本地事务的默认自动提交模式。&lt;br&gt;
spring.jta.bitronix.datasource.login-timeout =＃建立数据库连接的超时时间（秒）。&lt;br&gt;
spring.jta.bitronix.datasource.max-idle-time = 60 ＃从池中清除连接的时间（以秒为单位）。&lt;br&gt;
spring.jta.bitronix.datasource.max-pool-size = 10 ＃池的最大大小。0表示没有限制。&lt;br&gt;
spring.jta.bitronix.datasource.min-pool-size = 0 ＃池的最小大小。&lt;br&gt;
spring.jta.bitronix.datasource.prepared-statement-cache-size = 0 ＃&lt;br&gt;
预准备语句缓存的目标大小。0禁用缓存。spring.jta.bitronix.datasource.share-transaction-connections = false＃是否可以在事务上下文中共享处于ACCESSIBLE状态的连接。&lt;br&gt;
spring.jta.bitronix.datasource.test-query = ＃用于在返回连接之前验证连接的SQL查询或语句。&lt;br&gt;
spring.jta.bitronix.datasource.two-pc-ordering-position = 1 ＃此资源在两阶段提交期间应采取的位置（始终首先是Integer.MIN_VALUE，并且始终是最后一个是Integer.MAX_VALUE）。&lt;br&gt;
spring.jta.bitronix.datasource.unique-name = dataSource ＃用于在恢复期间标识资源的唯一名称。&lt;br&gt;
spring.jta.bitronix.datasource.use -tm -join = true ＃启动XAResources时是否应该使用TMJOIN。&lt;br&gt;
spring.jta.bitronix.properties.allow-multiple-lrc = false ＃是否允许多个LRC资源登记到同一事务中。&lt;br&gt;
spring.jta.bitronix.properties.asynchronous2-pc = false ＃是否启用异步执行两阶段提交。&lt;br&gt;
spring.jta.bitronix.properties.background-recovery-interval-seconds = 60 ＃在后台运行恢复过程的时间间隔（以秒为单位）。&lt;br&gt;
spring.jta.bitronix.properties.current-node-only-recovery = true ＃是否仅恢复当前节点。&lt;br&gt;
spring.jta.bitronix.properties.debug-zero-resource-transaction = false＃是否记录创建和提交没有单个登记资源的事务调用堆栈。&lt;br&gt;
spring.jta.bitronix.properties.default-transaction-timeout = 60 ＃默认事务超时，以秒为单位。&lt;br&gt;
spring.jta.bitronix.properties.disable-jmx = false ＃是否启用JMX支持。&lt;br&gt;
spring.jta.bitronix.properties.exception-analyzer = ＃设置要使用的异常分析器实现的完全限定名称。&lt;br&gt;
spring.jta.bitronix.properties.filter-log-status = false ＃是否启用日志过滤，以便只写入强制日志。&lt;br&gt;
spring.jta.bitronix.properties.force-batching-enabled = true＃是否批量磁盘强制。&lt;br&gt;
spring.jta.bitronix.properties.forced-write-enabled = true ＃是否强制将日志记录到磁盘。&lt;br&gt;
spring.jta.bitronix.properties.graceful-shutdown-interval = 60 ＃TM在关闭时中止事务之前等待事务完成的最大秒数。&lt;br&gt;
spring.jta.bitronix.properties.jndi-transaction-synchronization-registry-name = ＃TransactionSynchronizationRegistry的JNDI名称。&lt;br&gt;
spring.jta.bitronix.properties.jndi-user-transaction-name = ＃UserTransaction的JNDI名称。&lt;br&gt;
spring.jta.bitronix.properties.journal = disk ＃期刊的名称。可以是&#39;disk&#39;，&#39;null&#39;或类名。&lt;br&gt;
spring.jta.bitronix.properties.log-part1-filename = btm1.tlog ＃日志的第一个片段的名称。&lt;br&gt;
spring.jta.bitronix.properties.log-part2-filename = btm2.tlog ＃日志的第二个片段的名称。&lt;br&gt;
spring.jta.bitronix.properties.max-log-size-in-mb = 2 ＃日志片段的最大大小（兆字节）。&lt;br&gt;
spring.jta.bitronix.properties.resource-configuration-filename = ＃ResourceLoader配置文件名。&lt;br&gt;
spring.jta.bitronix.properties.server-id = #ASCII ID必须唯一标识此TM实例。默认为机器的IP地址。&lt;br&gt;
spring.jta.bitronix.properties.skip-corrupted-logs = false#Skip损坏的事务日志条目。&lt;br&gt;
spring.jta.bitronix.properties.warn-about-zero-resource-transaction = true ＃是否为没有单个登记资源的事务记录警告。&lt;/p&gt;
&lt;p&gt;＃EMBEDDED MONGODB（EmbeddedMongoProperties）&lt;br&gt;
spring.mongodb.embedded.features = sync_delay ＃逗号分隔的要启用的功能列表。&lt;br&gt;
spring.mongodb.embedded.storage.database-dir = ＃用于数据存储的目录。&lt;br&gt;
spring.mongodb.embedded.storage.oplog-size = #oplog的最大大小。&lt;br&gt;
spring.mongodb.embedded.storage.repl-set-name = ＃副本集的名称。&lt;br&gt;
spring.mongodb.embedded.version = 3.5.5 ＃要使用的Mongo版本。&lt;/p&gt;
&lt;p&gt;#REDIS（RedisProperties）&lt;br&gt;
spring.redis.cluster.max -redirects = ＃在群集中执行命令时要遵循的最大重定向数。&lt;br&gt;
spring.redis.cluster.nodes = ＃逗号分隔的“host：port”对列表引导自。&lt;br&gt;
spring.redis.database = 0 ＃连接工厂使用的数据库索引。&lt;br&gt;
spring.redis.url = ＃连接URL。覆盖主机，端口和密码。用户被忽略。示例：redis：// user：password@example.com ：6379&lt;br&gt;
spring.redis.host = localhost ＃Redis服务器主机。&lt;br&gt;
spring.redis.jedis.pool.max-active = 8＃池在给定时间可以分配的最大连接数。使用负值无限制。&lt;br&gt;
spring.redis.jedis.pool.max-idle = 8 ＃池中“空闲”连接的最大数量。使用负值表示无限数量的空闲连接。&lt;br&gt;
spring.redis.jedis.pool.max -wait = -1ms ＃在池耗尽时，在抛出异常之前连接分配应该阻塞的最长时间。使用负值无限期阻止。&lt;br&gt;
spring.redis.jedis.pool.min-idle = 0 ＃目标是池中维护的最小空闲连接数。此设置仅在其为正时才有效。&lt;br&gt;
spring.redis.lettuce.pool.max-active = 8＃池在给定时间可以分配的最大连接数。使用负值无限制。&lt;br&gt;
spring.redis.lettuce.pool.max-idle = 8 ＃池中“空闲”连接的最大数量。使用负值表示无限数量的空闲连接。&lt;br&gt;
spring.redis.lettuce.pool.max -wait = -1ms ＃在池耗尽时，在抛出异常之前连接分配应阻塞的最长时间。使用负值无限期阻止。&lt;br&gt;
spring.redis.lettuce.pool.min-idle = 0 ＃目标是池中维护的最小空闲连接数。此设置仅在其为正时才有效。&lt;br&gt;
spring.redis.lettuce.shutdown-timeout = 100ms＃关机超时。&lt;br&gt;
spring.redis.password = ＃redis服务器的登录密码。&lt;br&gt;
spring.redis.port = 6379 #Redis服务器端口。&lt;br&gt;
spring.redis.sentinel.master = #Redis服务器的名称。&lt;br&gt;
spring.redis.sentinel.nodes = ＃逗号分隔的“host：port”对列表。&lt;br&gt;
spring.redis.ssl = false ＃是否启用SSL支持。&lt;br&gt;
spring.redis.timeout = ＃连接超时。&lt;/p&gt;
&lt;p&gt;#TRANSACTION （TransactionProperties）&lt;br&gt;
spring.transaction.default-timeout = ＃默认事务超时。如果未指定持续时间后缀，则将使用秒。&lt;br&gt;
spring.transaction.rollback-on-commit-failure = ＃是否回滚提交失败。&lt;/p&gt;
&lt;p&gt;＃----------------------------------------&lt;br&gt;
＃INTEGRATION PROPERTIES&lt;br&gt;
＃----- -----------------------------------&lt;/p&gt;
&lt;p&gt;#ACTIVEMQ（ActiveMQProperties）&lt;br&gt;
spring.activemq.broker-url = ActiveMQ代理的URL。默认情况下自动生成。&lt;br&gt;
spring.activemq.close-timeout = 15s ＃在考虑结束完成之前等待的时间。&lt;br&gt;
spring.activemq.in-memory = true ＃默认代理URL是否应该在内存中。如果已指定显式代理，则忽略。&lt;br&gt;
spring.activemq.non-blocking-redelivery = false ＃是否在从回滚事务重新传递消息之前停止消息传递。这意味着启用此消息顺序时不会保留消息顺序。&lt;br&gt;
spring.activemq.password = ＃代理的登录密码。&lt;br&gt;
spring.activemq.send-timeout = 0ms ＃等待消息发送响应的时间。将其设置为0以永远等待。&lt;br&gt;
spring.activemq.user = ＃代理的登录用户。&lt;br&gt;
spring.activemq.packages.trust-all = ＃是否信任所有包。&lt;br&gt;
spring.activemq.packages.trusted = ＃逗号分隔的要信任的特定包列表（不信任所有包时）。&lt;br&gt;
spring.activemq.pool.block-if-full = true ＃是否阻止请求连接并且池已满。将其设置为false以改为抛出“JMSException”。&lt;br&gt;
spring.activemq.pool.block-if-full-timeout = -1ms＃如果池仍然满，则在抛出异常之前阻塞。&lt;br&gt;
spring.activemq.pool.enabled = false ＃是否应创建JmsPoolConnectionFactory，而不是常规ConnectionFactory。&lt;br&gt;
spring.activemq.pool.idle-timeout = 30s ＃连接空闲超时。&lt;br&gt;
spring.activemq.pool.max-connections = 1 ＃最大池化连接数。&lt;br&gt;
spring.activemq.pool.max-sessions-per-connection = 500 ＃池中每个连接的最大池化会话数。&lt;br&gt;
spring.activemq.pool.time-between-expiration-check = -1ms ＃在空闲连接驱逐线程的运行之间休眠的时间。当为负时，没有空闲连接驱逐线程运行。&lt;br&gt;
spring.activemq.pool.use-anonymous-producer = true ＃是否只使用一个匿名“MessageProducer”实例。将其设置为false以在每次需要时创建一个“MessageProducer”。&lt;/p&gt;
&lt;p&gt;#ARTEMIS （ArtemisProperties）&lt;br&gt;
spring.artemis.embedded.cluster-password = ＃群集密码。默认情况下在启动时随机生成。&lt;br&gt;
spring.artemis.embedded.data-directory = #Journal 文件目录。如果关闭持久性，则没有必要。&lt;br&gt;
spring.artemis.embedded.enabled = true ＃如果Artemis服务器API可用，是否启用嵌入模式。&lt;br&gt;
spring.artemis.embedded.persistent = false ＃是否启用持久存储。&lt;br&gt;
spring.artemis.embedded.queues = ＃逗号分隔的队列，在启动时创建。&lt;br&gt;
spring.artemis.embedded.server-id =＃服务器ID。默认情况下，使用自动递增的计数器。&lt;br&gt;
spring.artemis.embedded.topics = ＃在启动时要创建的以逗号分隔的主题列表。&lt;br&gt;
spring.artemis.host = localhost ＃Artemis broker主机。&lt;br&gt;
spring.artemis.mode = ＃Artemis部署模式，默认情况下自动检测。&lt;br&gt;
spring.artemis.password = ＃代理的登录密码。&lt;br&gt;
spring.artemis.pool.block-if-full = true ＃是否在请求连接且池已满时阻止。将其设置为false以改为抛出“JMSException”。&lt;br&gt;
spring.artemis.pool.block-if-full-timeout = -1ms ＃如果池仍然满，则在抛出异常之前阻塞。&lt;br&gt;
spring.artemis.pool.enabled = false ＃是否应创建JmsPoolConnectionFactory，而不是常规ConnectionFactory。&lt;br&gt;
spring.artemis.pool.idle-timeout = 30s ＃连接空闲超时。&lt;br&gt;
spring.artemis.pool.max-connections = 1 ＃池化连接的最大数量。&lt;br&gt;
spring.artemis.pool.max-sessions-per-connection = 500 ＃池中每个连接的最大池化会话数。&lt;br&gt;
spring.artemis.pool.time-between-expiration-check = -1ms ＃在空闲连接驱逐线程的运行之间休眠的时间。当为负时，没有空闲连接驱逐线程运行。&lt;br&gt;
spring.artemis.pool.use-anonymous-producers = true＃是否只使用一个匿名“MessageProducer”实例。将其设置为false以在每次需要时创建一个“MessageProducer”。&lt;br&gt;
spring.artemis.port = 61616 #Artemis 经纪人端口。&lt;br&gt;
spring.artemis.user = ＃代理的登录用户。&lt;/p&gt;
&lt;p&gt;#SPRING BATCH（BatchProperties）&lt;br&gt;
spring.batch.initialize-schema = embedded ＃数据库模式初始化模式。&lt;br&gt;
spring.batch.job.enabled = true ＃在启动时执行上下文中的所有Spring Batch作业。&lt;br&gt;
spring.batch.job.names = ＃逗号分隔的要在启动时执行的作业名称列表（例如，&lt;code&gt;job1，job2&lt;/code&gt;）。默认情况下，将执行上下文中找到的所有作业。&lt;br&gt;
spring.batch.schema = classpath中：组织/ springframework的/批号/核心/ schema- @ @ 平台@ @ .SQL ＃的路径SQL文件，以用于初始化数据库架构。&lt;br&gt;
spring.batch.table-prefix =＃所有批次元数据表的表前缀。&lt;/p&gt;
&lt;p&gt;#SPRING INTEGRATION（IntegrationProperties）&lt;br&gt;
spring.integration.jdbc.initialize-schema = embedded ＃数据库模式初始化模式。&lt;br&gt;
spring.integration.jdbc.schema = classpath中：组织/ springframework的/集成/ JDBC / schema- @ @ 平台@ @ .SQL ＃的路径SQL文件，以用于初始化数据库架构。&lt;/p&gt;
&lt;p&gt;#JMS （JmsProperties）&lt;br&gt;
spring.jms.cache.consumers = false ＃是否缓存消息使用者。&lt;br&gt;
spring.jms.cache.enabled = true ＃是否缓存会话。&lt;br&gt;
spring.jms.cache.producers = true ＃是否缓存消息生成器。&lt;br&gt;
spring.jms.cache.session-cache-size = 1 ＃会话缓存的大小（根据JMS会话类型）。&lt;br&gt;
spring.jms.jndi-name = ＃连接工厂JNDI名称。设置时，优先于其他连接工厂自动配置。&lt;br&gt;
spring.jms.listener.acknowledge-mode = ＃容器的确认模式。默认情况下，侦听器使用自动确认进行事务处理。&lt;br&gt;
spring.jms.listener.auto-startup = true ＃启动时自动启动容器。&lt;br&gt;
spring.jms.listener.concurrency = ＃最小并发使用者数。&lt;br&gt;
spring.jms.listener.max-concurrency = ＃最大并发使用者数。&lt;br&gt;
spring.jms.pub-sub-domain = false ＃默认目标类型是否为topic。&lt;br&gt;
spring.jms.template.default-destination = ＃用于没有目标参数的发送和接收操作的默认目标。&lt;br&gt;
spring.jms.template.delivery-delay = ＃用于发送呼叫的传递延迟。&lt;br&gt;
spring.jms.template.delivery-mode =＃交付模式。设置时启用QoS（服务质量）。&lt;br&gt;
spring.jms.template.priority = ＃发送时消息的优先级。设置时启用QoS（服务质量）。&lt;br&gt;
spring.jms.template.qos-enabled = ＃发送消息时是否启用显式QoS（服务质量）。&lt;br&gt;
spring.jms.template.receive-timeout = ＃用于接收呼叫的超时。&lt;br&gt;
spring.jms.template.time-to-live = ＃发送时消息的生存时间。设置时启用QoS（服务质量）。&lt;/p&gt;
&lt;p&gt;#APACHE KAFKA（KafkaProperties）&lt;br&gt;
spring.kafka.admin.client-id = #ID 在发出请求时传递给服务器。用于服务器端日志记录。&lt;br&gt;
spring.kafka.admin.fail-fast = false ＃如果代理在启动时不可用，是否快速失败。&lt;br&gt;
spring.kafka.admin.properties。* = ＃用于配置客户端的其他特定于管理员的属性。&lt;br&gt;
spring.kafka.admin.ssl.key-password = ＃密钥库文件中私钥的密码。&lt;br&gt;
spring.kafka.admin.ssl.key-store-location = ＃密钥库文件的位置。&lt;br&gt;
spring.kafka.admin.ssl.key-store-password =＃存储密钥库文件的密码。&lt;br&gt;
spring.kafka.admin.ssl.key-store-type = ＃密钥库的类型。&lt;br&gt;
spring.kafka.admin.ssl.protocol = ＃要使用的SSL协议。&lt;br&gt;
spring.kafka.admin.ssl.trust-store-location = ＃信任库文件的位置。&lt;br&gt;
spring.kafka.admin.ssl.trust-store-password = ＃存储信任存储文件的密码。&lt;br&gt;
spring.kafka.admin.ssl.trust-store-type = ＃信任库的类型。&lt;br&gt;
spring.kafka.bootstrap-servers = ＃逗号分隔的主机：端口对列表，用于建立与Kafka集群的初始连接。除非被覆盖，否则适用于所有组件。&lt;br&gt;
spring.kafka.client-id = #ID 在发出请求时传递给服务器。用于服务器端日志记录。&lt;br&gt;
spring.kafka.consumer.auto-commit-interval = ＃如果&#39;enable.auto.commit&#39;设置为true，则将消费者偏移自动提交给Kafka的频率。&lt;br&gt;
spring.kafka.consumer.auto-offset-reset = ＃当Kafka中没有初始偏移量或者服务器上不再存在当前偏移量时该怎么办。&lt;br&gt;
spring.kafka.consumer.bootstrap-servers = ＃逗号分隔的主机：端口对列表，用于建立与Kafka集群的初始连接。为消费者覆盖全球财产。&lt;br&gt;
spring.kafka.consumer.client-id =#ID在发出请求时传递给服务器。用于服务器端日志记录。&lt;br&gt;
spring.kafka.consumer.enable-auto-commit = ＃是否在后台定期提交消费者的偏移量。&lt;br&gt;
spring.kafka.consumer.fetch-max-wait = ＃如果没有足够的数据立即满足“fetch-min-size”给出的要求，服务器在回答获取请求之前会阻塞的最长时间。&lt;br&gt;
spring.kafka.consumer.fetch-min-size = ＃服务器应为获取请求返回的最小数据量。&lt;br&gt;
spring.kafka.consumer.group-id = ＃唯一字符串，用于标识此使用者所属的使用者组。&lt;br&gt;
spring.kafka.consumer.heartbeat间隔= ＃心跳与消费者协调员之间的预期时间。&lt;br&gt;
spring.kafka.consumer.key-deserializer = #Deserializer 类的键。&lt;br&gt;
spring.kafka.consumer.max-poll-records = ＃一次调用poll（）时返回的最大记录数。&lt;br&gt;
spring.kafka.consumer.properties。* = ＃用于配置客户端的其他特定于使用者的属性。&lt;br&gt;
spring.kafka.consumer.ssl.key-password = ＃密钥库文件中私钥的密码。&lt;br&gt;
spring.kafka.consumer.ssl.key-store-location = ＃密钥库文件的位置。&lt;br&gt;
spring.kafka.consumer.ssl.key-store-password =＃存储密钥库文件的密码。&lt;br&gt;
spring.kafka.consumer.ssl.key-store-type = ＃密钥库的类型。&lt;br&gt;
spring.kafka.consumer.ssl.protocol = ＃要使用的SSL协议。&lt;br&gt;
spring.kafka.consumer.ssl.trust-store-location = ＃信任存储文件的位置。&lt;br&gt;
spring.kafka.consumer.ssl.trust-store-password = ＃存储信任存储文件的密码。&lt;br&gt;
spring.kafka.consumer.ssl.trust-store-type = ＃信任库的类型。&lt;br&gt;
spring.kafka.consumer.value-deserializer = #Deserializer 类的值。&lt;br&gt;
spring.kafka.jaas.control-flag = required ＃登录配置的控制标志。&lt;br&gt;
spring.kafka.jaas.enabled = false ＃是否启用JAAS配置。&lt;br&gt;
spring.kafka.jaas.login-module = com.sun.security.auth.module.Krb5LoginModule ＃登录模块。&lt;br&gt;
spring.kafka.jaas.options = ＃其他JAAS选项。&lt;br&gt;
spring.kafka.listener.ack-count = ＃当ackMode为“COUNT”或“COUNT_TIME”时，偏移提交之间的记录数。&lt;br&gt;
spring.kafka.listener.ack-mode = ＃Listener AckMode。请参阅spring-kafka文档。&lt;br&gt;
spring.kafka.listener.ack-time = ＃当ackMode为“TIME”或“COUNT_TIME”时，偏移提交之间的时间。&lt;br&gt;
spring.kafka.listener.client-id =＃侦听器的使用者client.id属性的前缀。&lt;br&gt;
spring.kafka.listener.concurrency = ＃在侦听器容器中运行的线程数。&lt;br&gt;
spring.kafka.listener.idle-event-interval = ＃发布空闲消费者事件（未收到数据）之间的时间。&lt;br&gt;
spring.kafka.listener.log-container-config = ＃是否在初始化期间记录容器配置（INFO级别）。&lt;br&gt;
spring.kafka.listener.monitor-interval = ＃检查无响应的消费者之间的时间。如果未指定持续时间后缀，则将使用秒。&lt;br&gt;
spring.kafka.listener.no-poll-threshold =#Multiplier应用于“pollTimeout”以确定消费者是否无响应。&lt;br&gt;
spring.kafka.listener.poll-timeout = ＃轮询消费者时使用的超时。&lt;br&gt;
spring.kafka.listener.type = single ＃Listener类型。&lt;br&gt;
spring.kafka.producer.acks = ＃生产者要求领导者在考虑完成请求之前收到的确认数。&lt;br&gt;
spring.kafka.producer.batch-size = ＃默认批量大小。&lt;br&gt;
spring.kafka.producer.bootstrap-servers = ＃逗号分隔的主机：端口对列表，用于建立与Kafka集群的初始连接。为生产者覆盖全球财产。&lt;br&gt;
spring.kafka.producer.buffer-memory = ＃生产者可用于缓冲等待发送到服务器的记录的总内存大小。&lt;br&gt;
spring.kafka.producer.client-id = #ID 在发出请求时传递给服务器。用于服务器端日志记录。&lt;br&gt;
spring.kafka.producer.compression-type = ＃生产者生成的所有数据的压缩类型。&lt;br&gt;
spring.kafka.producer.key-serializer = ＃密码的Serializer类。&lt;br&gt;
spring.kafka.producer.properties。* = ＃用于配置客户端的其他特定于生产者的属性。&lt;br&gt;
spring.kafka.producer.retries = ＃大于零时，启用重试失败的发送。&lt;br&gt;
spring.kafka.producer.ssl.key-password = ＃密钥库文件中私钥的密码。&lt;br&gt;
spring.kafka.producer.ssl.key-store-location = ＃密钥库文件的位置。&lt;br&gt;
spring.kafka.producer.ssl.key-store-password = ＃存储密钥库文件的密码。&lt;br&gt;
spring.kafka.producer.ssl.key-store-type = ＃密钥库的类型。&lt;br&gt;
spring.kafka.producer.ssl.protocol = ＃要使用的SSL协议。&lt;br&gt;
spring.kafka.producer.ssl.trust-store-location = ＃信任库文件的位置。&lt;br&gt;
spring.kafka.producer.ssl.trust-store-password = ＃存储信任存储文件的密码。&lt;br&gt;
spring.kafka.producer.ssl.trust-store-type = ＃信任库的类型。&lt;br&gt;
spring.kafka.producer.transaction-id-prefix = ＃非空时，为生产者启用事务支持。&lt;br&gt;
spring.kafka.producer.value-serializer = #Serializer 类的值。&lt;br&gt;
spring.kafka.properties。* = ＃用于配置客户端的生产者和使用者&lt;br&gt;
共有的附加属性。spring.kafka.ssl.key-password = ＃密钥库文件中私钥的密码。&lt;br&gt;
spring.kafka.ssl.key-store-location = ＃密钥库文件的位置。&lt;br&gt;
spring.kafka.ssl.key-store-password =＃存储密钥库文件的密码。&lt;br&gt;
spring.kafka.ssl.key-store-type = ＃密钥库的类型。&lt;br&gt;
spring.kafka.ssl.protocol = ＃要使用的SSL协议。&lt;br&gt;
spring.kafka.ssl.trust-store-location = ＃信任库文件的位置。&lt;br&gt;
spring.kafka.ssl.trust-store-password = ＃存储信任存储文件的密码。&lt;br&gt;
spring.kafka.ssl.trust-store-type = ＃信任库的类型。&lt;br&gt;
spring.kafka.streams.application-id = #Kafka streams application.id property; 默认spring.application.name。&lt;br&gt;
spring.kafka.streams.auto-startup = true ＃是否自动启动流工厂bean。&lt;br&gt;
spring.kafka.streams.bootstrap-servers = ＃逗号分隔的主机：端口对列表，用于建立与Kafka集群的初始连接。覆盖流的全局属性。&lt;br&gt;
spring.kafka.streams.cache-max-size-buffering = ＃用于跨所有线程缓冲的最大内存大小。&lt;br&gt;
spring.kafka.streams.client-id = #ID 在发出请求时传递给服务器。用于服务器端日志记录。&lt;br&gt;
spring.kafka.streams.properties。* = ＃用于配置流的其他Kafka属性。&lt;br&gt;
spring.kafka.streams.replication-factor =＃流处理应用程序创建的更改日志主题和重新分区主题的复制因子。&lt;br&gt;
spring.kafka.streams.ssl.key-password = ＃密钥库文件中私钥的密码。&lt;br&gt;
spring.kafka.streams.ssl.key-store-location = ＃密钥库文件的位置。&lt;br&gt;
spring.kafka.streams.ssl.key-store-password = ＃存储密钥库文件的密码。&lt;br&gt;
spring.kafka.streams.ssl.key-store-type = ＃密钥库的类型。&lt;br&gt;
spring.kafka.streams.ssl.protocol = ＃要使用的SSL协议。&lt;br&gt;
spring.kafka.streams.ssl.trust-store-location = ＃信任库文件的位置。&lt;br&gt;
spring.kafka.streams.ssl.trust-store-password = ＃存储信任存储文件的密码。&lt;br&gt;
spring.kafka.streams.ssl.trust-store-type = ＃信任库的类型。&lt;br&gt;
spring.kafka.streams.state-dir = ＃状态存储的目录位置。&lt;br&gt;
spring.kafka.template.default-topic = ＃发送消息的默认主题。&lt;/p&gt;
&lt;p&gt;#RABBIT（RabbitProperties）&lt;br&gt;
spring.rabbitmq.addresses = ＃逗号分隔的客户端应连接的地址列表。&lt;br&gt;
spring.rabbitmq.cache.channel.checkout-timeout = ＃达到缓存大小后等待获取通道的持续时间。&lt;br&gt;
spring.rabbitmq.cache.channel.size = ＃要在缓存中保留的通道数。&lt;br&gt;
spring.rabbitmq.cache.connection.mode = channel ＃连接工厂缓存模式。&lt;br&gt;
spring.rabbitmq.cache.connection.size = ＃缓存的连接数。&lt;br&gt;
spring.rabbitmq.connection-timeout = ＃连接超时。将其设置为零以永远等待。&lt;br&gt;
spring.rabbitmq.dynamic = true ＃是否创建AmqpAdmin bean。&lt;br&gt;
spring.rabbitmq.host = localhost ＃RabbitMQ主机。&lt;br&gt;
spring.rabbitmq.listener.direct.acknowledge-mode = ＃容器的确认模式。&lt;br&gt;
spring.rabbitmq.listener.direct.auto-startup = true ＃是否在启动时自动启动容器。&lt;br&gt;
spring.rabbitmq.listener.direct.consumers-per-queue = ＃每个队列的消费者数量。&lt;br&gt;
spring.rabbitmq.listener.direct.default-requeue-rejected = ＃默认情况下，拒绝的交付是否重新排队。&lt;br&gt;
spring.rabbitmq.listener.direct.idle-event-interval =＃应该发布空闲容器事件的频率。&lt;br&gt;
spring.rabbitmq.listener.direct.missing-queues-fatal = false ＃如果容器声明的队列在代理上不可用，则是否失败。&lt;br&gt;
spring.rabbitmq.listener.direct.prefetch = ＃每个消费者可能未完成的未确认消息的最大数量。&lt;br&gt;
spring.rabbitmq.listener.direct.retry.enabled = false ＃是否启用发布重试。&lt;br&gt;
spring.rabbitmq.listener.direct.retry.initial-interval = 1000ms ＃第一次和第二次尝试传递消息之间的持续时间。&lt;br&gt;
spring.rabbitmq.listener.direct.retry.max-attempts = 3＃传递邮件的最大尝试次数。&lt;br&gt;
spring.rabbitmq.listener.direct.retry.max -interval = 10000ms ＃尝试之间的最长持续时间。&lt;br&gt;
spring.rabbitmq.listener.direct.retry.multiplier = 1 ＃乘数应用于先前的重试间隔。&lt;br&gt;
spring.rabbitmq.listener.direct.retry.stateless = true ＃重试是无状态还是有状态。&lt;br&gt;
spring.rabbitmq.listener.simple.acknowledge-mode = ＃容器的确认模式。&lt;br&gt;
spring.rabbitmq.listener.simple.auto-startup = true ＃是否在启动时自动启动容器。&lt;br&gt;
spring.rabbitmq.listener.simple.concurrency =＃侦听器调用者线程的最小数量。&lt;br&gt;
spring.rabbitmq.listener.simple.default-requeue-rejected = ＃默认情况下，拒绝的交付是否重新排队。&lt;br&gt;
spring.rabbitmq.listener.simple.idle-event-interval = ＃应该发布空闲容器事件的频率。&lt;br&gt;
spring.rabbitmq.listener.simple.max-concurrency = ＃侦听器调用者线程的最大数量。&lt;br&gt;
spring.rabbitmq.listener.simple.missing-queues-fatal = true ＃如果容器声明的队列在代理上不可用，则是否失败和/或如果在运行时删除一个或多个队列，是否停止容器。&lt;br&gt;
spring.rabbitmq.listener.simple.prefetch =＃每个消费者可能未完成的未确认消息的最大数量。&lt;br&gt;
spring.rabbitmq.listener.simple.retry.enabled = false ＃是否启用发布重试。&lt;br&gt;
spring.rabbitmq.listener.simple.retry.initial-interval = 1000ms ＃第一次和第二次尝试传递消息之间的持续时间。&lt;br&gt;
spring.rabbitmq.listener.simple.retry.max-attempts = 3 ＃传递邮件的最大尝试次数。&lt;br&gt;
spring.rabbitmq.listener.simple.retry.max -interval = 10000ms ＃尝试之间的最长持续时间。&lt;br&gt;
spring.rabbitmq.listener.simple.retry.multiplier = 1 ＃乘数应用于上一个重试间隔。&lt;br&gt;
spring.rabbitmq.listener.simple.retry.stateless = true ＃重试是无状态还是有状态。&lt;br&gt;
spring.rabbitmq.listener.simple.transaction-size = ＃确认模式为AUTO时要在acks之间处理的消息数。如果大于预取，则预取将增加到此值。&lt;br&gt;
spring.rabbitmq.listener.type = simple ＃Listener容器类型。&lt;br&gt;
spring.rabbitmq.password = guest ＃登录以对代理进行身份验证。&lt;br&gt;
spring.rabbitmq.port = 5672 ＃RabbitMQ端口。&lt;br&gt;
spring.rabbitmq.publisher-confirms = false ＃是否启用发布者确认。&lt;br&gt;
spring.rabbitmq.publisher-returns = false＃是否启用发布者返回。&lt;br&gt;
spring.rabbitmq.requested-heartbeat = ＃请求心跳超时; 零，没有。如果未指定持续时间后缀，则将使用秒。&lt;br&gt;
spring.rabbitmq.ssl.algorithm = #SSL 算法使用。默认情况下，由Rabbit客户端库配置。&lt;br&gt;
spring.rabbitmq.ssl.enabled = false ＃是否启用SSL支持。&lt;br&gt;
spring.rabbitmq.ssl.key-store = ＃保存SSL证书的密钥库的路径。&lt;br&gt;
spring.rabbitmq.ssl.key-store-password = ＃用于访问密钥库的密码。&lt;br&gt;
spring.rabbitmq.ssl.key-store-type = PKCS12 ＃密钥库类型。&lt;br&gt;
spring.rabbitmq.ssl.trust-store = ＃持有SSL证书的信任存储。&lt;br&gt;
spring.rabbitmq.ssl.trust-store-password = ＃用于访问信任库的密码。&lt;br&gt;
spring.rabbitmq.ssl.trust-store-type = JKS #Trust store type。&lt;br&gt;
spring.rabbitmq.ssl.validate-server-certificate = true ＃是否启用服务器端证书验证。&lt;br&gt;
spring.rabbitmq.ssl.verify-hostname = true ＃是否启用主机名验证。&lt;br&gt;
spring.rabbitmq.template.default-receive-queue = ＃从明确指定none时接收消息的默认队列的名称。&lt;br&gt;
spring.rabbitmq.template.exchange =＃用于发送操作的默认交换的名称。&lt;br&gt;
spring.rabbitmq.template.mandatory = ＃是否启用强制消息。&lt;br&gt;
spring.rabbitmq.template.receive-timeout = ＃receive（）&lt;code&gt;操作的超时。 spring.rabbitmq.template.reply-timeout = #outoutout用于&lt;/code&gt;sendAndReceive（）`操作。&lt;br&gt;
spring.rabbitmq.template.retry.enabled = false ＃是否启用发布重试。&lt;br&gt;
spring.rabbitmq.template.retry.initial-interval = 1000ms ＃第一次和第二次尝试传递消息之间的持续时间。&lt;br&gt;
spring.rabbitmq.template.retry.max-attempts = 3 ＃传递邮件的最大尝试次数。&lt;br&gt;
spring.rabbitmq.template.retry.max -interval = 10000ms ＃尝试之间的最长持续时间。&lt;br&gt;
spring.rabbitmq.template.retry.multiplier = 1 ＃乘数应用于先前的重试间隔。&lt;br&gt;
spring.rabbitmq.template.routing-key = ＃用于发送操作的默认路由密钥的值。&lt;br&gt;
spring.rabbitmq.username = guest ＃登录用户以对代理进行身份验证。&lt;br&gt;
spring.rabbitmq.virtual-host = ＃连接到代理时使用的虚拟主机。&lt;/p&gt;
&lt;p&gt;＃----------------------------------------&lt;br&gt;
＃ACTUATOR PROPERTIES&lt;br&gt;
＃----- -----------------------------------&lt;/p&gt;
&lt;p&gt;#MANAGEMENT HTTP SERVER（ManagementServerProperties）&lt;br&gt;
management.server.add-application-context-header = false ＃在每个响应中添加“X-Application-Context”HTTP标头。&lt;br&gt;
management.server.address = ＃管理端点应绑定到的网络地址。需要自定义management.server.port。&lt;br&gt;
management.server.port = ＃管理端点HTTP端口（默认情况下使用与应用程序相同的端口）。配置其他端口以使用特定于管理的SSL。&lt;br&gt;
management.server.servlet.context-path = ＃管理端点context-path（例如，&lt;code&gt;/ management&lt;/code&gt;）。需要自定义management.server.port。&lt;br&gt;
management.server.ssl.ciphers= ＃支持的SSL密码。&lt;br&gt;
management.server.ssl.client-auth = ＃客户端身份验证模式。&lt;br&gt;
management.server.ssl.enabled = true ＃是否启用SSL支持。&lt;br&gt;
management.server.ssl.enabled-protocols = ＃启用SSL协议。&lt;br&gt;
management.server.ssl.key-alias = ＃标识密钥库中密钥的别名。&lt;br&gt;
management.server.ssl.key-password = ＃用于访问密钥库中密钥的密码。&lt;br&gt;
management.server.ssl.key-store = ＃保存SSL证书的密钥库的路径（通常是jks文件）。&lt;br&gt;
management.server.ssl.key-store-password =＃用于访问密钥库的密码。&lt;br&gt;
management.server.ssl.key-store-provider = ＃密钥库的提供者。&lt;br&gt;
management.server.ssl.key-store-type = ＃密钥库的类型。&lt;br&gt;
management.server.ssl.protocol = TLS ＃要使用的SSL协议。&lt;br&gt;
management.server.ssl.trust-store = ＃持有SSL证书的信任存储。&lt;br&gt;
management.server.ssl.trust-store-password = ＃用于访问信任库的密码。&lt;br&gt;
management.server.ssl.trust-store-provider = ＃信任存储的提供者。&lt;br&gt;
management.server.ssl.trust-store-type = ＃信任库的类型。&lt;/p&gt;
&lt;p&gt;#CLOUDFOUNDRY&lt;br&gt;
management.cloudfoundry.enabled = true ＃是否启用扩展的Cloud Foundry执行器端点。&lt;br&gt;
management.cloudfoundry.skip-ssl-validation = false ＃是否跳过Cloud Foundry执行器端点安全调用的SSL验证。&lt;/p&gt;
&lt;p&gt;#ENDPOINTS GENERAL CONFIGURATION&lt;br&gt;
management.endpoints.enabled-by-default = ＃默认情况下是否启用或禁用所有端点。&lt;/p&gt;
&lt;p&gt;#ENDPOINTS JMX CONFIGURATION（JmxEndpointProperties）&lt;br&gt;
management.endpoints.jmx.domain = org.springframework.boot #Endpoints JMX域名。如果设置，则回退到&#39;spring.jmx.default-domain&#39;。&lt;br&gt;
management.endpoints.jmx.exposure.include = * ＃应包含的端点ID或所有的“&lt;em&gt;”。&lt;br&gt;
management.endpoints.jmx.exposure.exclude = ＃应排除的端点ID或所有的&#39;&lt;/em&gt;&#39;。&lt;br&gt;
management.endpoints.jmx.static-names = ＃附加的静态属性，附加到表示端点的MBean的所有ObjectName。&lt;/p&gt;
&lt;p&gt;#ENDPOINTS WEB CONFIGURATION（WebEndpointProperties）&lt;br&gt;
management.endpoints.web.exposure.include = health，info ＃应包含的端点ID或所有的“&lt;em&gt;”。&lt;br&gt;
management.endpoints.web.exposure.exclude = ＃应排除的端点ID或所有的&#39;&lt;/em&gt;&#39;。&lt;br&gt;
management.endpoints.web.base-path = / actuator #Web端点的基本路径。相对于server.servlet.context-path或management.server.servlet.context-path，如果配置了management.server.port。&lt;br&gt;
management.endpoints.web.path-mapping = ＃端点ID与应公开它们的路径之间的映射。&lt;/p&gt;
&lt;p&gt;#ENDPOINTS CORS CONFIGURATION（CorsEndpointProperties）&lt;br&gt;
management.endpoints.web.cors.allow-credentials = ＃是否支持凭据。未设置时，不支持凭据。&lt;br&gt;
management.endpoints.web.cors.allowed-headers = ＃逗号分隔的请求中允许的标头列表。&#39;&lt;em&gt;&#39;允许所有标题。&lt;br&gt;
management.endpoints.web.cors.allowed-methods = ＃逗号分隔的允许方法列表。&#39;&lt;/em&gt;&#39;允许所有方法。未设置时，默认为GET。&lt;br&gt;
management.endpoints.web.cors.allowed-origins = ＃逗号分隔的原始列表允许。&#39;*&#39;允许所有来源。未设置时，将禁用CORS支持。&lt;br&gt;
management.endpoints.web.cors.exposed-headers = ＃逗号分隔的标题列表，包含在响应中。&lt;br&gt;
management.endpoints.web.cors.max-age = 1800s ＃客户端缓存来自飞行前请求的响应的时间。如果未指定持续时间后缀，则将使用秒。&lt;/p&gt;
&lt;p&gt;#AUDIT EVENTS ENDPOINT（AuditEventsEndpoint）&lt;br&gt;
management.endpoint.auditevents.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。&lt;br&gt;
management.endpoint.auditevents.enabled = true ＃是否启用auditevents端点。&lt;/p&gt;
&lt;p&gt;#BEANS ENDPOINT（BeansEndpoint）&lt;br&gt;
management.endpoint.beans.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。&lt;br&gt;
management.endpoint.beans.enabled = true ＃是否启用beans端点。&lt;/p&gt;
&lt;p&gt;#CACHES ENDPOINT（CachesEndpoint）&lt;br&gt;
management.endpoint.caches.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。&lt;br&gt;
management.endpoint.caches.enabled = true ＃是否启用缓存端点。&lt;/p&gt;
&lt;p&gt;＃条件报告ENDPOINT（ConditionsReportEndpoint）&lt;br&gt;
management.endpoint.conditions.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。&lt;br&gt;
management.endpoint.conditions.enabled = true ＃是否启用条件端点。&lt;/p&gt;
&lt;p&gt;#CONFIGURATION PROPERTIES REPORT ENDPOINT（ConfigurationPropertiesReportEndpoint，ConfigurationPropertiesReportEndpointProperties）&lt;br&gt;
management.endpoint.configprops.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。&lt;br&gt;
management.endpoint.configprops.enabled = true ＃是否启用configprops端点。&lt;br&gt;
management.endpoint.configprops.keys-to-sanitize = password，secret，key，token，。* credentials。*，vcap_services，sun.java.command ＃应该清理的密钥。键可以是属性结尾的简单字符串或正则表达式。&lt;/p&gt;
&lt;p&gt;#ENVEST ENDPOINT（EnvironmentEndpoint，EnvironmentEndpointProperties）&lt;br&gt;
management.endpoint.env.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。&lt;br&gt;
management.endpoint.env.enabled = true ＃是否启用env端点。&lt;br&gt;
management.endpoint.env.keys-to-sanitize = password，secret，key，token，。* credentials。*，vcap_services，sun.java.command ＃应该清理的密钥。键可以是属性结尾的简单字符串或正则表达式。&lt;/p&gt;
&lt;p&gt;#FLYWAY ENDPOINT（FlywayEndpoint）&lt;br&gt;
management.endpoint.flyway.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。&lt;br&gt;
management.endpoint.flyway.enabled = true ＃是否启用flyway端点。&lt;/p&gt;
&lt;p&gt;#HEEC ENDPOINT（HealthEndpoint，HealthEndpointProperties）&lt;br&gt;
management.endpoint.health.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。&lt;br&gt;
management.endpoint.health.enabled = true ＃是否启用运行状况端点。&lt;br&gt;
management.endpoint.health.roles = ＃用于确定是否授权用户显示详细信息的角色。为空时，所有经过身份验证的用户都被授权。&lt;br&gt;
management.endpoint.health.show-details = never ＃何时显示完整的健康详细信息。&lt;/p&gt;
&lt;p&gt;#HEAP DUMP ENDPOINT（HeapDumpWebEndpoint）&lt;br&gt;
management.endpoint.heapdump.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。&lt;br&gt;
management.endpoint.heapdump.enabled = true ＃是否启用heapdump端点。&lt;/p&gt;
&lt;p&gt;#HTTP TRACE ENDPOINT（HttpTraceEndpoint）&lt;br&gt;
management.endpoint.httptrace.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。&lt;br&gt;
management.endpoint.httptrace.enabled = true ＃是否启用httptrace端点。&lt;/p&gt;
&lt;p&gt;#INFO ENDPOINT（InfoEndpoint）&lt;br&gt;
info = ＃要添加到信息端点的任意属性。&lt;br&gt;
management.endpoint.info.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。&lt;br&gt;
management.endpoint.info.enabled = true ＃是否启用信息端点。&lt;/p&gt;
&lt;p&gt;#INTEGRATION GRAPH ENDPOINT（IntegrationGraphEndpoint）&lt;br&gt;
management.endpoint.integrationgraph.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。&lt;br&gt;
management.endpoint.integrationgraph.enabled = true ＃是否启用集成图终结点。&lt;/p&gt;
&lt;p&gt;#JOLOKIA ENDPOINT（JolokiaProperties）&lt;br&gt;
management.endpoint.jolokia.config。* = ＃Jolokia设置。有关更多详细信息，请参阅Jolokia的文档。&lt;br&gt;
management.endpoint.jolokia.enabled = true ＃是否启用jolokia端点。&lt;/p&gt;
&lt;p&gt;#LIQUIBASE ENDPOINT（LiquibaseEndpoint）&lt;br&gt;
management.endpoint.liquibase.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。&lt;br&gt;
management.endpoint.liquibase.enabled = true ＃是否启用liquibase端点。&lt;/p&gt;
&lt;p&gt;#log FILE ENDPOINT（＃LOG LogFileWebEndpoint，LogFileWebEndpointProperties）&lt;br&gt;
management.endpoint.logfile.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。&lt;br&gt;
management.endpoint.logfile.enabled = true ＃是否启用日志文件端点。&lt;br&gt;
management.endpoint.logfile.external-file = ＃要访问的外部日志文件。如果日志文件由输出重定向而不是日志记录系统本身写入，则可以使用。&lt;/p&gt;
&lt;p&gt;＃LOGGERS ENDPOINT（LoggersEndpoint）&lt;br&gt;
management.endpoint.loggers.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。&lt;br&gt;
management.endpoint.loggers.enabled = true ＃是否启用记录器端点。&lt;/p&gt;
&lt;p&gt;#REQUEST MAPPING ENDPOINT（MappingsEndpoint）&lt;br&gt;
management.endpoint.mappings.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。&lt;br&gt;
management.endpoint.mappings.enabled = true ＃是否启用映射端点。&lt;/p&gt;
&lt;p&gt;#METRICS ENDPOINT（MetricsEndpoint）&lt;br&gt;
management.endpoint.metrics.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。&lt;br&gt;
management.endpoint.metrics.enabled = true ＃是否启用指标端点。&lt;/p&gt;
&lt;p&gt;#PROMETHEUS ENDPOINT（PrometheusScrapeEndpoint）&lt;br&gt;
management.endpoint.prometheus.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。&lt;br&gt;
management.endpoint.prometheus.enabled = true ＃是否启用prometheus端点。&lt;/p&gt;
&lt;p&gt;#STEEDEDED TASKS ENDPOINT（ScheduledTasksEndpoint）&lt;br&gt;
management.endpoint.scheduledtasks.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。&lt;br&gt;
management.endpoint.scheduledtasks.enabled = true ＃是否启用scheduledtasks端点。&lt;/p&gt;
&lt;p&gt;#SESSIONS ENDPOINT（SessionsEndpoint）&lt;br&gt;
management.endpoint.sessions.enabled = true ＃是否启用会话端点。&lt;/p&gt;
&lt;p&gt;#SHUTDOWN ENDPOINT（ShutdownEndpoint）&lt;br&gt;
management.endpoint.shutdown.enabled = false ＃是否启用关闭端点。&lt;/p&gt;
&lt;p&gt;#THREAD DUMP ENDPOINT（ThreadDumpEndpoint）&lt;br&gt;
management.endpoint.threaddump.cache.time-to-live = 0ms ＃可以缓存响应的最长时间。&lt;br&gt;
management.endpoint.threaddump.enabled = true ＃是否启用threaddump端点。&lt;/p&gt;
&lt;p&gt;＃HEALTH INDICATORS&lt;br&gt;
management.health.db.enabled = true ＃是否启用数据库运行状况检查。&lt;br&gt;
management.health.cassandra.enabled = true ＃是否启用Cassandra运行状况检查。&lt;br&gt;
management.health.couchbase.enabled = true ＃是否启用Couchbase运行状况检查。&lt;br&gt;
management.health.defaults.enabled = true ＃是否启用默认健康指标。&lt;br&gt;
management.health.diskspace.enabled = true ＃是否启用磁盘空间运行状况检查。&lt;br&gt;
management.health.diskspace.path = ＃用于计算可用磁盘空间的路径。&lt;br&gt;
management.health.diskspace.threshold = 10MB＃应该可用的最小磁盘空间。&lt;br&gt;
management.health.elasticsearch.enabled = true ＃是否启用Elasticsearch运行状况检查。&lt;br&gt;
management.health.elasticsearch.indices = ＃逗号分隔的索引名称。&lt;br&gt;
management.health.elasticsearch.response-timeout = 100ms ＃等待集群响应的时间。&lt;br&gt;
management.health.influxdb.enabled = true ＃是否启用InfluxDB运行状况检查。&lt;br&gt;
management.health.jms.enabled = true ＃是否启用JMS运行状况检查。&lt;br&gt;
management.health.ldap.enabled = true ＃是否启用LDAP运行状况检查。&lt;br&gt;
management.health.mail.enabled = true＃是否启用邮件健康检查。&lt;br&gt;
management.health.mongo.enabled = true ＃是否启用MongoDB运行状况检查。&lt;br&gt;
management.health.neo4j.enabled = true ＃是否启用Neo4j运行状况检查。&lt;br&gt;
management.health.rabbit.enabled = true ＃是否启用RabbitMQ运行状况检查。&lt;br&gt;
management.health.redis.enabled = true ＃是否启用Redis运行状况检查。&lt;br&gt;
management.health.solr.enabled = true ＃是否启用Solr运行状况检查。&lt;br&gt;
management.health.status.http-mapping = ＃将健康状态映射到HTTP状态代码。默认情况下，已注册的运行状况映射到合理的默认值（例如，UP映射到200）。&lt;br&gt;
management.health.status.order = DOWN，OUT_OF_SERVICE，UP，UNKNOWN ＃以逗号分隔的健康状态列表，按严重程度排序。&lt;/p&gt;
&lt;p&gt;#HTTP TRACING（HttpTraceProperties）&lt;br&gt;
management.trace.http.enabled = true ＃是否启用HTTP请求 - 响应跟踪。&lt;br&gt;
management.trace.http.include =请求标头，响应标头，cookie，错误＃要包含在跟踪中的项目。&lt;/p&gt;
&lt;p&gt;#INFO CONTRIBUTORS（InfoContributorProperties）&lt;br&gt;
management.info.build.enabled = true ＃是否启用构建信息。&lt;br&gt;
management.info.defaults.enabled = true ＃是否启用默认信息贡献者。&lt;br&gt;
management.info.env.enabled = true ＃是否启用环境信息。&lt;br&gt;
management.info.git.enabled = true ＃是否启用git信息。&lt;br&gt;
management.info.git.mode = simple ＃用于公开git信息的模式。&lt;/p&gt;
&lt;p&gt;#METRICS&lt;br&gt;
management.metrics.distribution.maximum-expected-value。* = ＃预计将以指定名称开始计量ID的最大值。&lt;br&gt;
management.metrics.distribution.minimum-expected-value。* = ＃预计将以指定名称开始的仪表ID的最小值。&lt;br&gt;
management.metrics.distribution.percentiles。* = ＃特定计算的非可聚合百分位数，用于以指定名称开始的仪表ID发送到后端。&lt;br&gt;
＃以指定名称开头的仪表ID的特定SLA边界。最长的比赛获胜。management.metrics.enable。* =management.metrics.distribution.percentiles-histogram。* = ＃是否以指定名称开头的米ID应发布百分位直方图。&lt;br&gt;
management.metrics.distribution.sla。* =&lt;br&gt;
＃是否应启用以指定名称开头的仪表ID。最长的匹配获胜，关键的“all”也可以用于配置所有的米。&lt;br&gt;
management.metrics.export.appoptics.api-token = #AppOptics API令牌。&lt;br&gt;
management.metrics.export.appoptics.batch-size = 500 ＃每个请求用于此后端的度量数。如果找到更多测量值，则将发出多个请求。&lt;br&gt;
management.metrics.export.appoptics.connect-timeout = 5s ＃对此后端的请求的连接超时。&lt;br&gt;
management.metrics.export.appoptics.enabled= true ＃是否启用将度量标准导出到此后端。&lt;br&gt;
management.metrics.export.appoptics.host-tag = instance ＃将指标发送到AppOptics时将映射到“@host”的标记。&lt;br&gt;
management.metrics.export.appoptics.num-threads = 2 ＃指标发布计划程序使用的线程数。&lt;br&gt;
management.metrics.export.appoptics.read-timeout = 10s ＃读取此后端请求的超时时间。&lt;br&gt;
management.metrics.export.appoptics.step = 1m ＃要使用的步长（即报告频率）。&lt;br&gt;
management.metrics.export.appoptics.uri = https://api.appoptics.com/v1/measurements# 将指标发送到的URI。&lt;br&gt;
management.metrics.export.atlas.batch-size = 10000 ＃每个请求用于此后端的度量数。如果找到更多测量值，则将发出多个请求。&lt;br&gt;
management.metrics.export.atlas.config-refresh-frequency = 10s ＃从LWC服务刷新配置设置的频率。&lt;br&gt;
management.metrics.export.atlas.config-time-to-live = 150s #LWC服务订阅的生存时间。&lt;br&gt;
management.metrics.export.atlas.config-uri = http：// localhost：7101 / lwc / api / v1 / expressions / local-dev #Atlas LWC端点的URI，用于检索当前订阅。&lt;br&gt;
management.metrics.export.atlas.connect-timeout = 1s＃对此后端的请求的连接超时。&lt;br&gt;
management.metrics.export.atlas.enabled = true ＃是否启用将度量标准导出到此后端。&lt;br&gt;
management.metrics.export.atlas.eval-uri = http：// localhost：7101 / lwc / api / v1 / evaluate ＃用于评估订阅数据的Atlas LWC端点的URI。&lt;br&gt;
management.metrics.export.atlas.lwc-enabled = false ＃是否启用流式传输到Atlas LWC。&lt;br&gt;
management.metrics.export.atlas.meter-time-to-live = 15m ＃没有任何活动的米的生存时间。在此期限之后，仪表将被视为已过期且不会报告。&lt;br&gt;
management.metrics.export.atlas.num-threads = 2＃指标发布计划程序使用的线程数。&lt;br&gt;
management.metrics.export.atlas.read-timeout = 10s ＃读取此后端请求的超时时间。&lt;br&gt;
management.metrics.export.atlas.step = 1m ＃要使用的步长（即报告频率）。&lt;br&gt;
management.metrics.export.atlas.uri = http：// localhost：7101 / api / v1 / publish #Atlas服务器的URI。&lt;br&gt;
management.metrics.export.datadog.api-key = ＃Datadog API密钥。&lt;br&gt;
management.metrics.export.datadog.application-key = ＃Datadog应用程序密钥。不是严格要求，但通过向Datadog发送仪表描述，类型和基本单位来改进Datadog体验。&lt;br&gt;
management.metrics.export.datadog.batch-size = 10000 ＃每个请求用于此后端的度量数。如果找到更多测量值，则将发出多个请求。&lt;br&gt;
management.metrics.export.datadog.connect-timeout = 1s ＃对此后端的请求的连接超时。&lt;br&gt;
management.metrics.export.datadog.descriptions = true ＃是否将描述元数据发布到Datadog。将其关闭以最小化发送的元数据量。&lt;br&gt;
management.metrics.export.datadog.enabled = true ＃是否启用将度量标准导出到此后端。&lt;br&gt;
management.metrics.export.datadog.host-tag = instance＃将指标发送到Datadog时将映射到“主机”的标记。&lt;br&gt;
management.metrics.export.datadog.num-threads = 2 ＃指标发布计划程序使用的线程数。&lt;br&gt;
management.metrics.export.datadog.read-timeout = 10s ＃读取此后端请求的超时时间。&lt;br&gt;
management.metrics.export.datadog.step = 1m ＃要使用的步长（即报告频率）。&lt;br&gt;
management.metrics.export.datadog.uri = https://app.datadoghq.com#management.metrics.export.dynatrace.api-token =#idex将指标发送到。如果需要将指标发布到到Datadog的内部代理，则可以使用此方法定义代理的位置。&lt;br&gt;
#Dynatrace身份验证令牌。&lt;br&gt;
management.metrics.export.dynatrace.batch-size = 10000 ＃每个请求用于此后端的度量数。如果找到更多测量值，则将发出多个请求。&lt;br&gt;
management.metrics.export.dynatrace.connect-timeout = 1s ＃对此后端的请求的连接超时。&lt;br&gt;
management.metrics.export.dynatrace.device-id = 将度量标准导出到Dynatrace的自定义设备的ID。&lt;br&gt;
management.metrics.export.dynatrace.enabled = true ＃是否启用将度量标准导出到此后端。&lt;br&gt;
management.metrics.export.dynatrace.num-threads = 2＃指标发布计划程序使用的线程数。&lt;br&gt;
management.metrics.export.dynatrace.read-timeout = 10s ＃读取此后端请求的超时时间。&lt;br&gt;
management.metrics.export.dynatrace.step = 1m ＃要使用的步长（即报告频率）。&lt;br&gt;
management.metrics.export.dynatrace.technology-type = java ＃导出的指标的技术类型。用于在Dynatrace UI中对逻辑技术名称下的度量标准进行分组。&lt;br&gt;
management.metrics.export.dynatrace.uri = 将指标发送到的URI。应该用于SaaS，自我管理的实例或通过内部代理途径。&lt;br&gt;
management.metrics.export.elastic.auto-create-index = true＃是否自动创建索引（如果不存在）。&lt;br&gt;
management.metrics.export.elastic.batch-size = 10000 ＃每个请求用于此后端的度量数。如果找到更多测量值，则将发出多个请求。&lt;br&gt;
management.metrics.export.elastic.connect-timeout = 1s ＃对此后端的请求的连接超时。&lt;br&gt;
management.metrics.export.elastic.enabled = true ＃是否启用将度量标准导出到此后端。&lt;br&gt;
management.metrics.export.elastic.host = http：// localhost：9200 ＃将指标导出到的主机。&lt;br&gt;
management.metrics.export.elastic.index = metrics ＃将指标导出到的索引。&lt;br&gt;
management.metrics.export.elastic.index-date-format＃时间戳字段的名称。= yyyy-MM ＃用于滚动索引的索引日期格式。附加到索引名称后面加一个&#39; - &#39;。&lt;br&gt;
management.metrics.export.elastic.num-threads = 2 ＃指标发布计划程序使用的线程数。&lt;br&gt;
management.metrics.export.elastic.password = ＃弹性服务器的登录密码。&lt;br&gt;
management.metrics.export.elastic.read-timeout = 10s ＃读取此后端请求的超时时间。&lt;br&gt;
management.metrics.export.elastic.step = 1m ＃要使用的步长（即报告频率）。&lt;br&gt;
management.metrics.export.elastic.timestamp-field-name = @timestamp management.metrics.export.elastic.user-name =&lt;br&gt;
＃弹性服务器的登录用户。&lt;br&gt;
management.metrics.export.ganglia.addressing-mode = multicast ＃UDP寻址模式，单播或多播。&lt;br&gt;
management.metrics.export.ganglia.duration- units =毫秒＃用于报告持续时间的基本时间单位。&lt;br&gt;
management.metrics.export.ganglia.enabled = true ＃是否启用向Ganglia导出指标。&lt;br&gt;
management.metrics.export.ganglia.host = localhost ＃Ganglia服务器的主机，用于接收导出的指标。&lt;br&gt;
management.metrics.export.ganglia.port = 8649 ＃Ganglia服务器端口，用于接收导出的指标。&lt;br&gt;
management.metrics.export.ganglia.protocol-version = 3.1 ＃Ganglia协议版本。必须是3.1或3.0。&lt;br&gt;
management.metrics.export.ganglia.rate- units = seconds ＃用于报告费率的基本时间单位。&lt;br&gt;
management.metrics.export.ganglia.step = 1m ＃要使用的步长（即报告频率）。&lt;br&gt;
management.metrics.export.ganglia.time-to-live = 1 ＃生活在Ganglia上的指标的时间。将多播生存时间设置为大于主机之间的跳数（路由器）的数量。&lt;br&gt;
management.metrics.export.graphite.duration-units =毫秒＃用于报告持续时间的基本时间单位。&lt;br&gt;
management.metrics.export.graphite.enabled = true＃是否启用将指标导出到Graphite。&lt;br&gt;
management.metrics.export.graphite.host = localhost ＃Graphite服务器的主机，用于接收导出的指标。&lt;br&gt;
management.metrics.export.graphite.port = 2004 ＃Graphite服务器的端口，用于接收导出的指标。&lt;br&gt;
management.metrics.export.graphite.protocol = pickled ＃在将数据发送到Graphite时使用的协议。&lt;br&gt;
management.metrics.export.graphite.rate-units = seconds ＃用于报告费率的基本时间单位。&lt;br&gt;
management.metrics.export.graphite.step = 1m ＃要使用的步长（即报告频率）。&lt;br&gt;
management.metrics.export.graphite.tags-as-prefix =＃对于默认命名约定，将指定的标记键转换为度量标准前缀的一部分。&lt;br&gt;
management.metrics.export.humio.api-token = ＃Humio API令牌。&lt;br&gt;
management.metrics.export.humio.batch-size = 10000 ＃每个请求用于此后端的度量数。如果找到更多测量值，则将发出多个请求。&lt;br&gt;
management.metrics.export.humio.connect-timeout = 5s ＃对此后端的请求的连接超时。&lt;br&gt;
management.metrics.export.humio.enabled = true ＃是否启用将度量标准导出到此后端。&lt;br&gt;
management.metrics.export.humio.num-threads = 2 ＃指标发布计划程序使用的线程数。&lt;br&gt;
management.metrics.export.humio.read-timeout = 10s ＃读取此后端请求的超时时间。&lt;br&gt;
management.metrics.export.humio.repository = sandbox ＃要将指标发布到的存储库的名称。&lt;br&gt;
management.metrics.export.humio.step = 1m ＃要使用的步长（即报告频率）。&lt;br&gt;
management.metrics.export.humio.tags。* = ＃Humio标签，用于描述将存储指标的数据源。Humio标签是与Micrometer标签不同的概念。千分尺的标签用于沿尺寸边界划分度量。&lt;br&gt;
management.metrics.export.humio.uri = https://cloud.humio.com#idex将指标发送到。如果您需要将指标发布到Humio的内部代理，您可以使用此方法定义代理的位置。&lt;br&gt;
management.metrics.export.influx.auto-create-db = true ＃在尝试向其发布指标之前，是否创建Influx数据库是否存在。&lt;br&gt;
management.metrics.export.influx.batch-size = 10000 ＃每个请求用于此后端的度量数。如果找到更多测量值，则将发出多个请求。&lt;br&gt;
management.metrics.export.influx.compressed = true ＃是否对发布到Influx的度量批次启用GZIP压缩。&lt;br&gt;
management.metrics.export.influx.connect-timeout = 1s＃对此后端的请求的连接超时。&lt;br&gt;
management.metrics.export.influx.consistency = one ＃为每个点写一致性。&lt;br&gt;
management.metrics.export.influx.db = mydb ＃将指标发送到Influx时将映射到“主机”的标记。&lt;br&gt;
management.metrics.export.influx.enabled = true ＃是否启用将度量标准导出到此后端。&lt;br&gt;
management.metrics.export.influx.num-threads = 2 ＃指标发布计划程序使用的线程数。&lt;br&gt;
management.metrics.export.influx.password = ＃Influx服务器的登录密码。&lt;br&gt;
management.metrics.export.influx.read-timeout = 10s＃读取此后端请求的超时时间。&lt;br&gt;
management.metrics.export.influx.retention-duration = ＃Influx应在当前数据库中保留数据的时间段。&lt;br&gt;
management.metrics.export.influx.retention-shard-duration = ＃分片组覆盖的时间范围。&lt;br&gt;
management.metrics.export.influx.retention-policy = ＃要使用的保留策略（如果未指定，则Influx写入DEFAULT保留策略）。&lt;br&gt;
management.metrics.export.influx.retention-replication-factor = ＃在群集中存储了多少份数据副本。&lt;br&gt;
management.metrics.export.influx.step = 1m ＃要使用的步长（即报告频率）。&lt;br&gt;
management.metrics.export.influx.uri = http：// localhost：8086 ＃Influx服务器的URI。&lt;br&gt;
management.metrics.export.influx.user-name = ＃Influx服务器的登录用户。&lt;br&gt;
management.metrics.export.jmx.domain = metrics ＃Metrics JMX域名。&lt;br&gt;
management.metrics.export.jmx.enabled = true ＃是否已启用将度量标准导出到JMX。&lt;br&gt;
management.metrics.export.jmx.step = 1m ＃要使用的步长（即报告频率）。&lt;br&gt;
management.metrics.export.kairos.batch-size = 10000 ＃每个请求用于此后端的度量数。如果找到更多测量值，则将发出多个请求。&lt;br&gt;
management.metrics.export.kairos.connect-timeout = 1s ＃对此后端的请求的连接超时。&lt;br&gt;
management.metrics.export.kairos.enabled = true ＃是否启用将度量标准导出到此后端。&lt;br&gt;
management.metrics.export.kairos.num-threads = 2 ＃指标发布计划程序使用的线程数。&lt;br&gt;
management.metrics.export.kairos.password = #KairosDB服务器的登录密码。&lt;br&gt;
management.metrics.export.kairos.read-timeout = 10s ＃读取此后端请求的超时时间。&lt;br&gt;
management.metrics.export.kairos.step = 1m＃要使用的步长（即报告频率）。&lt;br&gt;
management.metrics.export.kairos.uri = localhost：8080 / api / v1 /  datapoints #KairosDB服务器的URI。&lt;br&gt;
management.metrics.export.kairos.user-name = #KairosDB服务器的登录用户。&lt;br&gt;
management.metrics.export.newrelic.account-id = ＃新Relic帐户ID。&lt;br&gt;
management.metrics.export.newrelic.api-key = #New Relic API密钥。&lt;br&gt;
management.metrics.export.newrelic.batch-size = 10000 ＃每个请求用于此后端的度量数。如果找到更多测量值，则将发出多个请求。&lt;br&gt;
management.metrics.export.newrelic.connect-timeout = 1s ＃对此后端的请求的连接超时。&lt;br&gt;
management.metrics.export.newrelic.enabled = true ＃是否启用将度量标准导出到此后端。&lt;br&gt;
management.metrics.export.newrelic.num-threads = 2 ＃指标发布计划程序使用的线程数。&lt;br&gt;
management.metrics.export.newrelic.read-timeout = 10s ＃读取此后端请求的超时时间。&lt;br&gt;
management.metrics.export.newrelic.step = 1m ＃要使用的步长（即报告频率）。&lt;br&gt;
management.metrics.export.newrelic.uri = https：//insights-collector.newrelic.com #idex 将指标发送到。&lt;br&gt;
management.metrics.export.prometheus.descriptions = true＃是否将发布描述作为scrape有效负载的一部分启用到Prometheus。将其关闭以最小化每次刮擦发送的数据量。&lt;br&gt;
management.metrics.export.prometheus.enabled = true ＃是否启用将指标导出到Prometheus。&lt;br&gt;
management.metrics.export.prometheus.step = 1m ＃要使用的步长（即报告频率）。&lt;br&gt;
management.metrics.export.prometheus.pushgateway.base-url = localhost：9091 ＃Pushgateway的基本URL。&lt;br&gt;
management.metrics.export.prometheus.pushgateway.enabled = false ＃通过Prometheus Pushgateway启用发布。&lt;br&gt;
management.metrics.export.prometheus.pushgateway.grouping-key =＃为推送的指标分组键。&lt;br&gt;
management.metrics.export.prometheus.pushgateway.job = ＃此应用程序实例的作业标识符。&lt;br&gt;
management.metrics.export.prometheus.pushgateway.push-rate = 1m ＃用于推送指标的频率。&lt;br&gt;
management.metrics.export.prometheus.pushgateway.shutdown-operation = ＃应该在关机时执行的操作。&lt;br&gt;
management.metrics.export.signalfx.access-token = #SignalFX访问令牌。&lt;br&gt;
management.metrics.export.signalfx.batch-size = 10000 ＃每个请求用于此后端的度量数。如果找到更多测量值，则将发出多个请求。&lt;br&gt;
management.metrics.export.signalfx.connect-timeout = 1s ＃对此后端的请求的连接超时。&lt;br&gt;
management.metrics.export.signalfx.enabled = true ＃是否启用将度量标准导出到此后端。&lt;br&gt;
management.metrics.export.signalfx.num-threads = 2 ＃指标发布计划程序使用的线程数。&lt;br&gt;
management.metrics.export.signalfx.read-timeout = 10s ＃读取此后端请求的超时时间。&lt;br&gt;
management.metrics.export.signalfx.source = ＃唯一标识正在向SignalFx发布指标的应用实例。默认为本地主机名。&lt;br&gt;
management.metrics.export.signalfx.step = 10s＃步骤大小（即报告频率）使用。&lt;br&gt;
management.metrics.export.signalfx.uri = https：//ingest.signalfx.com# 将指标发送到的URI。&lt;br&gt;
management.metrics.export.simple.enabled = true ＃在没有任何其他导出器的情况下，是否启用将指标导出到内存后端。&lt;br&gt;
management.metrics.export.simple.mode =累积＃计数模式。&lt;br&gt;
management.metrics.export.simple.step = 1m ＃要使用的步长（即报告频率）。&lt;br&gt;
management.metrics.export.statsd.enabled = true ＃是否启用将度量标准导出到StatsD。&lt;br&gt;
management.metrics.export.statsd.flavor = datadog#StatsD线路协议使用。&lt;br&gt;
management.metrics.export.statsd.host = localhost ＃StatsD服务器的主机，用于接收导出的指标。&lt;br&gt;
management.metrics.export.statsd.max-packet-length = 1400 ＃单个有效负载的总长度应保持在网络的MTU中。&lt;br&gt;
management.metrics.export.statsd.polling-frequency = 10s ＃测量仪表&lt;br&gt;
的频率。轮询仪表时，会重新计算其值，如果值已更改（或者publishUnchangedMeters为true），则会将其发送到StatsD服务器。management.metrics.export.statsd.port = 8125 ＃StatsD服务器的端口，用于接收导出的指标。&lt;br&gt;
management.metrics.export.statsd.publish-不变米= true ＃是否将未更改的计量表发送到StatsD服务器。&lt;br&gt;
management.metrics.export.wavefront.api-token = ＃将指标直接发布到Wavefront API主机时使用的API令牌。&lt;br&gt;
management.metrics.export.wavefront.batch-size = 10000 ＃每个请求用于此后端的度量数。如果找到更多测量值，则将发出多个请求。&lt;br&gt;
management.metrics.export.wavefront.connect-timeout = 1s ＃对此后端的请求的连接超时。&lt;br&gt;
management.metrics.export.wavefront.enabled = true ＃是否启用将度量标准导出到此后端。&lt;br&gt;
management.metrics.export.wavefront.global-prefix =＃全局前缀用于将源自此应用程序的白盒工具的度量标准与在Wavefront UI中查看时源自其他Wavefront集成的度量标准分开。&lt;br&gt;
management.metrics.export.wavefront.num-threads = 2 ＃指标发布计划程序使用的线程数。&lt;br&gt;
management.metrics.export.wavefront.read-timeout = 10s ＃读取此后端请求的超时时间。&lt;br&gt;
management.metrics.export.wavefront.source = ＃应用程序实例的唯一标识符，该实例是发布到Wavefront的度量标准的来源。默认为本地主机名。&lt;br&gt;
management.metrics.export.wavefront.step = 10s ＃要使用的步长（即报告频率）。&lt;br&gt;
management.metrics.export.wavefront.uri = https://longboard.wavefront.com# 将指标发送到的URI。&lt;br&gt;
management.metrics.use-global-registry = true ＃是否应将自动配置的MeterRegistry实现绑定到Metrics上的全局静态注册表。&lt;br&gt;
management.metrics.tags。* = ＃应用于每个仪表的公共标签。&lt;br&gt;
management.metrics.web.client.max-uri-tags = 100 ＃允许的唯一URI标记值的最大数量。达到最大标记值数后，过滤器将拒绝具有其他标记值的度量标准。&lt;br&gt;
management.metrics.web.client.requests-metric-name = http.client.requests ＃已发送请求的度量标准的名称。&lt;br&gt;
management.metrics.web.server.auto-time-requests = true ＃是否应自动为Spring MVC，WebFlux或Jersey处理的请求定时。&lt;br&gt;
management.metrics.web.server.max-uri-tags = 100 ＃允许的唯一URI标记值的最大数量。达到最大标记值数后，过滤器将拒绝具有其他标记值的度量标准。&lt;br&gt;
management.metrics.web.server.requests-metric-name = http.server.requests ＃已接收请求的度量标准的名称。&lt;br&gt;
＃----------------------------------------&lt;br&gt;
#DEDTOOLS PROPERTIES&lt;br&gt;
＃----- -----------------------------------&lt;br&gt;
#DESTOOLS（DevToolsProperties）&lt;br&gt;
spring.devtools.add-properties = true ＃是否启用开发属性默认值。&lt;br&gt;
spring.devtools.livereload.enabled = true ＃是否启用livereload.com兼容服务器。&lt;br&gt;
spring.devtools.livereload.port = 35729 ＃服务器端口。&lt;br&gt;
spring.devtools.restart.additional-exclude = ＃应该从触发完全重启中排除的其他模式。&lt;br&gt;
spring.devtools.restart.additional-paths = ＃要监视更改的其他路径。&lt;br&gt;
spring.devtools.restart.enabled = true ＃是否启用自动重启。&lt;br&gt;
spring.devtools.restart.exclude= META-INF /行家/ **，META-INF /资源/ **，资源/ **，静态/ **，公共/ *&lt;em&gt;，模板/ &lt;strong&gt;，&lt;/strong&gt; / &lt;em&gt;的Test.class，&lt;/em&gt;&lt;/em&gt; / * Tests.class，git.properties，META-INF / build-info.properties ＃应该从触发完全重启中排除的模式。&lt;br&gt;
spring.devtools.restart.log-condition-evaluation-delta = true ＃是否在重新启动时记录条件评估增量。&lt;br&gt;
spring.devtools.restart.poll-interval = 1s ＃轮询类路径更改之间等待的时间。&lt;br&gt;
spring.devtools.restart.quiet-period = 400ms ＃触发重启之前没有任何类路径更改所需的安静时间量。&lt;br&gt;
spring.devtools.restart.trigger-file =＃特定文件的名称，当更改时，触发重新启动检查。如果未指定，则任何类路径文件更改都会触发重新启动。&lt;br&gt;
#remote DEVTOOLS（RemoteDevToolsProperties）&lt;br&gt;
spring.devtools.remote.context-path = /。~~ spring-boot！〜＃用于处理远程连接的上下文路径。&lt;br&gt;
spring.devtools.remote.proxy.host = ＃用于连接远程应用程序的代理主机。&lt;br&gt;
spring.devtools.remote.proxy.port = ＃用于连接远程应用程序的代理端口。&lt;br&gt;
spring.devtools.remote.restart.enabled = true ＃是否启用远程重启。&lt;br&gt;
spring.devtools.remote.secret = ＃建立连接所需的共享密钥（启用远程支持所需）。&lt;br&gt;
spring.devtools.remote.secret头名= X-AUTH-TOKEN ＃用于传输共享密钥的HTTP头。&lt;br&gt;
＃----------------------------------------&lt;br&gt;
#TESTING PROPERTIES&lt;br&gt;
＃----- -----------------------------------&lt;br&gt;
spring.test.database.replace = any ＃要替换的现有DataSource的类型。&lt;br&gt;
spring.test.mockmvc.print =默认#MVC 打印选项。&lt;/p&gt;
">springboot2的配置文件properties和yml的一些常用属性</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://https://chenm0.github.io/post/weifuwu-sheji/"" data-c="
          &lt;h3 id=&#34;单独的数据库&#34;&gt;单独的数据库：&lt;/h3&gt;
&lt;p&gt;微服务设计的一个关键是数据库设计，基本原则是每个服务都有自己单独的数据库，而且只有微服务本身可以访问这个数据库。它是基于下面三个原因。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优化服务接口&lt;/strong&gt;：微服务之间的接口越小越好，最好只有服务调用接口（RPC或消息），没有其他接口。如果微服务不能独享自己的数据库，那么数据库也变成了接口的一部分，这大大拓展了接口范围。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;错误诊断&lt;/strong&gt;：生产环境中的错误大部分都是和数据库有关的，要么是数据出了问题，要么是数据库的使用方式出了问题。当你不能完全控制数据库的访问时，会有各种各样的错误发生。它可能是别的程序直接连到你的数据库或者是其他部门直接用客户端访问数据库的数据，而这些都是在程序中查不到的，增加了错误排查难度。如果是程序中的问题，只要修改了代码，那么这个错误就不会再有。而上面提到的错误，你永远都没法预测它们什么时候还会再次发生。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;性能调优&lt;/strong&gt;：性能调优也是一样，你需要对数据库有全权控制才能保证它的性能。如果其他部门一定要访问数据库，而且只是查询的话，那么可以另外创建一份只读数据库，让他们在另一个库中查询，这样才不会影响到你的库。&lt;/p&gt;
&lt;p&gt;理想的设计是你的数据库只有你的服务能访问，你也只调用自己数据库中的数据，所有对别的微服务的访问都通过服务调用来实现（请参阅&lt;a href=&#34;https://blog.csdn.net/weixin_38748858/article/details/101062272&#34;&gt;“微服务之间调用的最佳设计“&lt;/a&gt;）。当然，在实际应用中，单纯的服务调用可能不能满足性能或其他要求，不同的微服务都多少需要共享一些数据。&lt;/p&gt;
&lt;h3 id=&#34;共享数据&#34;&gt;共享数据：&lt;/h3&gt;
&lt;p&gt;微服务之间的数据共享可以有下四种方式。&lt;/p&gt;
&lt;h4 id=&#34;静态表&#34;&gt;静态表：&lt;/h4&gt;
&lt;p&gt;有一些静态的数据库表，例如国家，可能会被很多程序用到，而且程序内部需要对国家这个表做连接（join）生成最终用户展示数据，这样用微服务调用的方式就效率不高，影响性能。一个办法是在每个微服务中配置一个这样的表，它是只读的，这样就可以做数据库连接了。当然你需要保证数据同步。这个方案在多数情况下都是可以接受的，因为以下两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;静态的数据库表结构基本不变：因为一旦表结构变了，你不但要更改所有微服务的数据库表，还要修改所有微服务的程序。&lt;/li&gt;
&lt;li&gt;数据库表中的数据变化不频繁：这样数据同步的工作量不大。另外当你同步数据库时总会有延迟，如果数据变化不频繁那么你有很多同步方式可供选择。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;只读业务数据访问&#34;&gt;只读业务数据访问：&lt;/h4&gt;
&lt;p&gt;如果你需要读取别的数据库里的动态业务数据， 理想的方式是服务调用。如果你只是调用其他微服务做一些计算，一般情况下性能都是可以接受的。如果你需要做数据的连接，那么你可以用程序代码来做，而不是用SQL语句。如果测试之后性能不能满足要求，那你可以考虑在自己的数据库里建一套只读数据表。数据同步方式大致有两种。如果是事件驱动方式，就用发消息的方式进行同步，如果是RPC方式，就用数据库本身提供的同步方式或者第三方同步软件。&lt;br&gt;
通常情况下，你可能只需要其他数据库的几张表，每张表只需要几个字段。这时，其他数据库是数据的最终来源，控制所有写操作以及相应的业务验证逻辑，我们叫它主表。你的只读库可以叫从表。 当一条数据写入主表后，会发一条广播消息，所有拥有从表的微服务监听消息并更新只读表中的数据。但这时你要特别小心，因为它的危险性要比静态表大得多。第一它的表结构变更会更频繁，而且它的变更完全不受你控制。第二业务数据不像静态表，它是经常更新的，这样对数据同步的要求就比较高。要根据具体的业务需求来决定多大的延迟是可以接受的。&lt;br&gt;
另外它还有两个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;数据的容量&lt;/strong&gt;：数据库中的数据量是影响性能的主要因素。因为这个数据是外来的，不利于掌握它的流量规律，很难进行容量规划，也不能更好地进行性能调优。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;接口外泄&lt;/strong&gt;: 微服务之间的接口本来只有服务调用接口，这时你可以对内部程序和数据库做任何更改，而不影响其他服务。现在数据库表结构也变成了接口的一部分。接口一旦发布之后，基本是不能更改的，这大大限制了你的灵活性。幸运的是因为另外建了一套表，有了一个缓冲，当主表修改时，从表也许不需要同步更新。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;除非你能用服务调用（没有本地只读数据库）的方式完成所有功能，不然不管你是用RPC方式还是事件驱动方式进行微服务集成，上面提到的问题都是不可避免的。但是你可以通过合理规划数据库更改，来减少上面问题带来的影响，下面将会详细讲解。&lt;/p&gt;
&lt;h4 id=&#34;读写业务数据访问&#34;&gt;读写业务数据访问：&lt;/h4&gt;
&lt;p&gt;这是最复杂的一种情况。一般情况下，你有一个表是主表，而其他表是从表。主表包含主要信息，而且这些主要信息被复制到从表，但微服务会有额外字段需要写入从表。这样本地微服务对从表就既有读也有写的操作。而且主表和从表有一个先后次序的关系。从表的主键来源于主表，因此一定先有主表，再有从表。&lt;/p&gt;
&lt;p&gt;假设我们有两个与电影有关的微服务，一个是电影论坛，用户可以发表对电影的评论。另一个是电影商店。“movie”是共享表，左边的一个是电影论坛库，它的“movie”表是主表。右边的是电影商店库，它的“movie”表是从表。它们共享“id”字段（主键）。主表是数据的主要来源，但从表里的“quantity”和“price”字段主表里面没有。主表插入数据后，发消息，从表接到消息，插入一条数据到本地“movie”表。并且从表还会修改表里的“quantity”和“price”字段。在这种情况下，要给每一个字段分配一个唯一源头（微服务），只有源头才有权利主动更改字段，其他微服务只能被动更改（接收源头发出的更改消息之后再改）。在本例子中， “quantity”和“price”字段的源头是右边的表，其他的字段的源头都是左边的表。本例子中“quantity”和“price”只在从表中存在，因此数据写入是单向的，方向是主表到从表。如果主表也需要这些字段，那么它们还要被回写，那数据写入就变成双向的。&lt;/p&gt;
&lt;h4 id=&#34;直接访问其它数据库&#34;&gt;直接访问其它数据库：&lt;/h4&gt;
&lt;p&gt;这种方式是要绝对禁止的。生产环境中的许多程序错误和性能问题都是由这种方式产生的。上面的三种方式由于是另外新建了本地只读数据库表，产生了数据库的物理隔离，这样一个数据库的性能问题不会影响到另一个。另外，当主库中的表结构更改时，你可以暂时保持从库中的表不变，这样程序还可以运行。如果直接访问别人的库，主库一修改，别的微服务程序马上就会报错。请参阅ApplicationDatabase。&lt;/p&gt;
&lt;h3 id=&#34;向后兼容的数据库更新&#34;&gt;向后兼容的数据库更新：&lt;/h3&gt;
&lt;p&gt;从上面的论述可以看出，数据库表结构的修改是一个影响范围很广的事情。在微服务架构中，共享的表在别的服务中也会有一个只读的拷贝。现在当你要更改表结构时，还需要考虑到对别的微服务的影响。当在单体（Monolithic）架构中，为了保证程序部署能够回滚，数据库的更新是向后兼容的。需要兼容性的另一个原因是支持蓝绿发布（Blue-Green Deployment）。在这种部署方式中，你同时拥有新旧版本的代码，由负载均衡来决定每一个请求指向那个版本。它们可以共享一个数据库（这就要求数据库是向后兼容的），也可以使用不同的数据。数据库的更新简单来讲有以下几种类型：&lt;br&gt;
&lt;strong&gt;增加表或字段&lt;/strong&gt;：如果字段可取空值，这个操作是向后兼容的。如果是非空值就要插入一个缺省值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;删除表或字段&lt;/strong&gt;：可先暂时保留被删除表或字段，经过几个版本之后再删除。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;修改字段名&lt;/strong&gt;：新增加一个字段，把数据从旧字段拷贝到新字段，用数据库触发器（或程序）同步旧字段和新字段（供过渡时期使用）。 然后再在几个版本之后把原来的字段删除（请参阅&lt;a href=&#34;https://thoughts-on-java.org/update-database-schema-without-downtime/&#34;&gt;Update your Database Schema Without Downtime&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;修改表名&lt;/strong&gt;：如果数据库支持可更新视图，最简单的办法是先修改表的名字，然后创建一个可更新视图指向原来的表（请参阅&lt;a href=&#34;https://martinfowler.com/articles/evodb.html&#34;&gt;Evolutionary Database Design&lt;/a&gt; ）。如果数据库不支持可更新视图，使用的方法与修改字段名相似，需要创建新的表并做数据同步。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;修改字段类型&lt;/strong&gt;：与修改字段名几乎相同，只是在拷贝数据时，需要做数据类型转换。&lt;/p&gt;
&lt;p&gt;向后兼容的数据库更新的好处是，当程序部署出现问题时，如需进行回滚。只要回滚程序就行了，而不必回滚数据库。回滚时一般只回滚一个版本。凡是需要删除的表或字段在本次部署时都不做修改，等到一个或几个版本之后，确认没有问题了再删除。它的另一个好处就是不会对其他微服务中的共享表产生立刻的直接影响。当本微服务升级后，其他微服务可以评估这些数据库更新带来的影响再决定是否需要做相应的程序或数据库修改。&lt;/p&gt;
&lt;h3 id=&#34;跨服务事物&#34;&gt;跨服务事物：&lt;/h3&gt;
&lt;p&gt;微服务的一个难点是如何实现跨服务的事物支持。两阶段提交（Two-Phase Commit）已被证明性能上不能满足需求，现在基本上没有人用。被一致认可的方法叫Saga。它的原理是为事物中的每个操作写一个补偿操作（Compensating Transaction），然后在回滚阶段挨个执行每一个补偿操作。示例如下图，在一个事物中共有3个操作T1，T2，T3。每一个操作要定义一个补偿操作，C1，C2，C3。事物执行时是按照正向顺序先执行T1，当回滚时是按照反向顺序先执行C3。 事物中的每一个操作（正向操作和补偿操作）都被包装成一个命令（Command），Saga执行协调器（Saga Execution Coordinator (SEC)）负责执行所有命令。在执行之前，所有的命令都会按顺序被存入日志中，然后Saga执行协调器从日志中取出命令，依次执行。当某个执行出现错误时，这个错误也被写入日志，并且所有正在执行的命令被停止，开始回滚操作。&lt;/p&gt;
&lt;p&gt;Saga放松了对一致性（Consistency）的要求，它能保证的是最终一致性（Eventual Consistency），因此在事物执行过程中数据是不一致的，并且这种不一致会被别的进程看到。在生活中，大多数情况下，我们对一致性的要求并没有那么高，短暂的不一致性是可以接收的。例如银行的转账操作，它们在执行过程中都不是在一个数据库事物里执行的，而是用记账的方式分成两个动作来执行，保证的也是最终一致性。&lt;/p&gt;
&lt;p&gt;Saga的原理看起来很简单，但要想正确的实施还是有一定难度的。它的核心问题在于对错误的处理，要把它完全讲明白需要另写一遍文章，我现在只讲一下要点。网络环境是不可靠的，正在执行的命令可能很长时间都没有返回结果，这时，第一，你要设定一个超时。第二，因为你不知道没有返回值的原因是，已经完成了命令但网络出了问题，还是没完成就牺牲了，因此不知道是否要执行补偿操作。这时正确的做法是重试原命令，直到得到完成确认，然后再执行补偿操作。但这对命令有一个要求，那就是这个操作必须是幂等的（Idempotent），也就是说它可以执行多次，但最终结果还是一样的。&lt;/p&gt;
&lt;p&gt;另外，有些操作的补偿操作比较容易生成，例如付款操作，你只要把钱款退回就可以了。但有些操作，像发邮件，完成之后就没有办法回到之前的状态了，这时就只能再发一个邮件更正以前的信息。因此补偿操作不一定非要返回到原来的状态，而是抵消掉原来操作产生的效果。&lt;/p&gt;
&lt;h3 id=&#34;微服务的拆分&#34;&gt;微服务的拆分：&lt;/h3&gt;
&lt;p&gt;我们原来的程序大多数都是单体程序，但现在要把它拆分成微服务，应该怎样做才能降低对现有应用的影响呢？&lt;/p&gt;
&lt;p&gt;假设我们要拆分出来一个微服务叫“client-service”，它需要访问“core client”表。第一步，我们先把程序从原来的代码里拆分出来，变成一个服务. 数据库不动，这个服务仍然指向原来的数据库。其他程序不再直接访问这个服务管理的表，而是通过服务调用或另建共享表来获取数据。&lt;/p&gt;
&lt;p&gt;第二步，再把服务的数据库表拆分出来，这时微服务就拥有它自己的数据库了，而不再需要原来的共享数据库了。这时就成了一个真正意义上的的微服务。&lt;/p&gt;
&lt;p&gt;上面只讲了拆分一个微服务，如果有多个需要拆分，则需一个一个按照上面讲的方法依次进行。&lt;/p&gt;
&lt;p&gt;另外，Martin Fowler在他的文章&amp;quot;Break Monolith into Microservices&amp;quot;里有一个很好的建议。那就是，当你把服务从单体程序里拆分时，不要只想着把代码拆分出来。因为现在的需求可能已经跟原来有所不同，原先的设计可能也不太适用了。而且，技术也已更新，代码也要作相应的改造。更好的办法是重写原来的功能（而不是重写原来的代码），把重点放在拆分业务功能上，而不是拆分代码上，用新的设计和技术来实现这个业务功能。&lt;/p&gt;
&lt;h3 id=&#34;结论&#34;&gt;结论：&lt;/h3&gt;
&lt;p&gt;数据库设计是微服务设计的一个关键点，基本原则是每个微服务都有自己单独的数据库，而且只有微服务本身可以访问这个数据库。微服务之间的数据共享可以通过服务调用，或者主、从表的方式实现。在共享数据时，要找到合适的同步方式。在微服务架构中，数据库的修改影响广泛，需要保证这种修改是向后兼容的。实现跨服务事物的标准方法是Saga。当把单体程序拆分成微服务时，可以分步进行，以减少对现有程序的影响。&lt;/p&gt;
">微服务的数据库设计</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://https://chenm0.github.io/post/twonum/"" data-c="
          &lt;p&gt;给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。&lt;br&gt;
示例 1：&lt;br&gt;
//输入：nums = [2,7,11,15], target = 9&lt;br&gt;
//输出：[0,1]&lt;br&gt;
//解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。&lt;/p&gt;
&lt;p&gt;// 示例 2：&lt;br&gt;
//输入：nums = [3,2,4], target = 6&lt;br&gt;
//输出：[1,2]&lt;/p&gt;
&lt;p&gt;// 示例 3：&lt;/p&gt;
&lt;p&gt;//输入：nums = [3,3], target = 6&lt;br&gt;
//输出：[0,1]&lt;br&gt;
// 提示：&lt;/p&gt;
&lt;p&gt;// 2 &amp;lt;= nums.length &amp;lt;= 104&lt;br&gt;
// -109 &amp;lt;= nums[i] &amp;lt;= 109&lt;br&gt;
// -109 &amp;lt;= target &amp;lt;= 109&lt;br&gt;
// 只会存在一个有效答案&lt;/p&gt;
&lt;p&gt;// 进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？&lt;br&gt;
// Related Topics 数组 哈希表&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map&amp;lt;Integer,Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        for (int i = 1; i &amp;lt;= nums.length; i++) {
            if (map.contains(target - nums[i])){
                return new int[]{map.get(target - nums[i]),i};
            }
            map.put(map.contains(target - nums[i]), i);
        }
        return new int[0];
    }
    
}
&lt;/code&gt;&lt;/pre&gt;
">两数之和</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://https://chenm0.github.io/post/spring-data-rest-learn/"" data-c="
          &lt;h3 id=&#34;1-paging&#34;&gt;1. Paging&lt;/h3&gt;
&lt;p&gt;Spring Data REST能识别含有分页和排序请求的URL，从而返回用户想要的数据，而不是直接返回一大堆数据集合。如果你继承PagingAndSortingRepository&amp;lt;T, ID&amp;gt;并获取实体类的列表集合，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;interface PersonRepository extends PagingAndSortingRepository&amp;lt;Person, Long&amp;gt; {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么请求数据分页默认数为20个，也就是说第一次请求为20个数据，并带有分页的参数，如果想要自定义分页的参数，可以采用更改请求的URL参数的办法进行更改：&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;http://localhost:8080/persons/?size=5&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;如果要在你自己的查询方法中使用分页，需要在方法的参数中添加一个Pageable参数，这样获得的数据是一页数据(Page)而不是一个列表(List):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@RestResource(path = &amp;quot;nameStartsWith&amp;quot;, rel = &amp;quot;nameStartsWith&amp;quot;)

public PagefindByNameStartsWith(@Param(&amp;quot;name&amp;quot;) String name, Pageable p);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样的一个查询方法，会输出到链接：/people/search/nameStartsWith 并且会支持分页，这个原理和Spring Data Jpa的类似。&lt;/p&gt;
&lt;h3 id=&#34;2-previous-and-next-links&#34;&gt;2. Previous and Next Links&lt;/h3&gt;
&lt;p&gt;每个分页的response数据返回到前端页面，都有一个prev和next链接，比如在浏览器中请求 localhost:8080/people?size=5 后得到的数据如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
&amp;quot;_links&amp;quot; : {
	&amp;quot;self&amp;quot; : {
		&amp;quot;href&amp;quot; : &amp;quot;http://localhost:8080/persons{&amp;amp;sort,page,size}&amp;quot;, 
	&amp;quot;templated&amp;quot; : true
	},
	&amp;quot;next&amp;quot; : {
		&amp;quot;href&amp;quot; : &amp;quot;http://localhost:8080/persons?page=1&amp;amp;size=5{&amp;amp;sort}&amp;quot;, 
		&amp;quot;templated&amp;quot; : true
	}
},
	&amp;quot;_embedded&amp;quot; : {
		... data ...
	},
	&amp;quot;page&amp;quot; : { ③
	&amp;quot;size&amp;quot; : 5,
	&amp;lt;!-- &amp;quot;totalElements&amp;quot; : 50 --&amp;gt;
	&amp;quot;totalPages&amp;quot; : 10,
	&amp;quot;number&amp;quot; : 0
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这两个链接是指向下一级链接(next)和上一级(prev)的链接的地址&lt;/p&gt;
&lt;h3 id=&#34;3sorting&#34;&gt;3.Sorting&lt;/h3&gt;
&lt;p&gt;和Paging一样，Spring Data Rest识别含有排序的URL请求参数，实体类对应的同样有一个实体仓库。为了让数据按照自己想要的参数进行排序，可以在URL请求中添加一个name属性，并指定属性的排序方式，指定排序的方向(正向asc,逆向desc),比如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;http://localhost:8080/people/search/nameStartsWith?name=K&amp;amp;sort=name,desc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样一个语句是使用了定义在PersonRepository中的findByNameStartsWith查询方法进行查询所有Person的姓名中以字母K开头的并以name进行逆向排序的用户。通常为使用多个属性进行排序，往往可以添加sort=PROPERTY自己想要排序的参数进行排序。&lt;/p&gt;
">Spring Data Rest---Paging and Sorting </a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://https://chenm0.github.io/post/weifuwu-ques/"" data-c="
          &lt;p&gt;&lt;strong&gt;服务注册发现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;服务注册就是维护一个登记簿，它管理系统内所有的服务地址。当新的服务启动后，它会向登记簿交待自己的地址信息。服务的依赖方直接向登记簿要 Service Provider 地址就行了。当下用于服务注册的工具非常多 ZooKeeper，Consul，Etcd, 还有 Netflix 家的 eureka 等。服务注册有两种:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;形式：客户端注册和第三方注册。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;客户端注册（zookeeper&lt;/strong&gt;）&lt;br&gt;
客户端注册是服务自身要负责注册与注销的工作。当服务启动后向注册中心注册自身，当服务下线时注销自己。期间还需要和注册中心保持心跳。心跳不一定要客户端来做，也可以由注册中心负责（这个过程叫探活）。这种方式的缺点是注册工作与服务耦合在一起，不同语言都要实现一套注册逻辑。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三方注册（独立的服务 Registrar）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第三方注册由一个独立的服务Registrar负责注册与注销。当服务启动后以某种方式通知Registrar，然后 Registrar 负责向注册中心发起注册工作。同时注册中心要维护与服务之间的心跳，当服务不可用时，向注册中心注销服务。这种方式的缺点是 Registrar 必须是一个高可用的系统则注册工作没法进展。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;客户端发现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;客户端发现是指客户端负责查询可用服务地址，以及负载均衡的工作。这种方式最方便直接，而且也方便做负载均衡。再者一旦发现某个服务不可用立即换另外一个，非常直接。缺点也在于多语言时的重复工作，每个语言实现相同的逻辑。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务端发现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;服务端发现需要额外的 Router 服务，请求先打到 Router，然后 Router 负责查询服务与负载均衡。这种方式虽然没有客户端发现的缺点，但是它的缺点是保证 Router 的高可用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;API 网关&lt;/strong&gt;&lt;br&gt;
API Gateway 是一个服务器，也可以说是进入系统的唯一节点。这跟面向对象设计模式中的&lt;br&gt;
Facade 模式很像。API Gateway 封装内部系统的架构，并且提供 API 给各个客户端。它还可能有其他功能，如授权、监控、负载均衡、缓存、请求分片和管理、静态响应处理等。下图展示了一个适应当前架构的 API Gateway。&lt;br&gt;
API Gateway 负责请求转发、合成和协议转换。所有来自客户端的请求都要先经过 API Gateway，然后路由这些请求到对应的微服务。API Gateway 将经常通过调用多个微服务来处理一个请求以及聚合多个服务的结果。它可以在 web 协议与内部使用的非 Web 友好型协议间进行转换，如HTTP 协议、WebSocket 协议。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;请求转发&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;服务转发主要是对客户端的请求安装微服务的负载转发到不同的服务上&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;响应合并&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把业务上需要调用多个服务接口才能完成的工作合并成一次调用对外统一提供服务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;协议转换&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;重点是支持 SOAP，JMS，Rest 间的协议转换。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据转换&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;重点是支持 XML 和 Json 之间的报文格式转换能力（可选）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安全认证&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;基于 Token 的客户端访问控制和安全策略&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;传输数据和报文加密，到服务端解密，需要在客户端有独立的 SDK 代理包&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基于 Https 的传输加密，客户端和服务端数字证书支持&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基于 OAuth2.0 的服务安全认证(授权码，客户端，密码模式等）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;配置中心&lt;/strong&gt;&lt;br&gt;
配置中心一般用作系统的参数配置，它需要满足如下几个要求：高效获取、实时感知、分布式访问。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;zookeeper 配置中心&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;采取数据加载到内存方式解决高效获取的问题，借助 zookeeper 的节点监听机制来实现实时感知。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;事件调度（kafka）&lt;/strong&gt;&lt;br&gt;
消息服务和事件的统一调度，常用用 kafka ，activemq 等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务跟踪（starter-sleuth）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;随着微服务数量不断增长，需要跟踪一个请求从一个微服务到下一个微服务的传播过程， SpringCloud Sleuth 正是解决这个问题，它在日志中引入唯一 ID，以保证微服务调用之间的一致性，这样你就能跟踪某个请求是如何从一个微服务传递到下一个。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;为了实现请求跟踪，当请求发送到分布式系统的入口端点时，只需要服务跟踪框架为该请求创建一个唯一的跟踪标识，同时在分布式系统内部流转的时候，框架始终保持传递该唯一标识，直到返回给请求方为止，这个唯一标识就是前文中提到的 Trace ID。通过 Trace ID 的记录，我们就能将所有请求过程日志关联起来。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为了统计各处理单元的时间延迟，当请求达到各个服务组件时，或是处理逻辑到达某个状态时，也通过一个唯一标识来标记它的开始、具体过程以及结束，该标识就是我们前文中提到的 Span ID，对于每个 Span 来说，它必须有开始和结束两个节点，通过记录开始 Span 和结束 Span 的时间戳，就能统计出该 Span 的时间延迟，除了时间戳记录之外，它还可以包含一些其他元数据，比如：事件名称、请求信息等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在快速入门示例中，我们轻松实现了日志级别的跟踪信息接入，这完全归功于spring-cloudstarter-sleuth 组件的实现。在 Spring Boot 应用中，通过在工程中引入 spring-cloud&lt;br&gt;
starter-sleuth 依赖之后， 它会自动的为当前应用构建起各通信通道的跟踪机制，比如：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;通过诸如 RabbitMQ、Kafka（或者其他任何 Spring Cloud Stream 绑定器实现的消息&lt;br&gt;
中间件）传递的请求。&lt;/li&gt;
&lt;li&gt;通过 Zuul 代理传递的请求。&lt;/li&gt;
&lt;li&gt;通过 RestTemplate 发起的请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;服务熔断（Hystrix）&lt;/strong&gt;&lt;br&gt;
在微服务架构中通常会有多个服务层调用，基础服务的故障可能会导致级联故障，进而造成整个系统不可用的情况，这种现象被称为服务雪崩效应。服务雪崩效应是一种因“服务提供者”的不可用导致“服务消费者”的不可用,并将不可用逐渐放大的过程。&lt;/p&gt;
&lt;p&gt;熔断器的原理很简单，如同电力过载保护器。它可以实现快速失败，如果它在一段时间内侦测到许多类似的错误，会强迫其以后的多个调用快速失败，不再访问远程服务器，从而防止应用程序&lt;/p&gt;
&lt;p&gt;不断地尝试执行可能会失败的操作，使得应用程序继续执行而不用等待修正错误，或者浪费 CPU时间去等到长时间的超时产生。熔断器也可以使应用程序能够诊断错误是否已经修正，如果已经修正，应用程序会再次尝试调用操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hystrix 断路器机制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;断路器很好理解, 当 Hystrix Command 请求后端服务失败数量超过一定比例(默认 50%), 断路器会切换到开路状态(Open). 这时所有请求会直接失败而不会发送到后端服务. 断路器保持在开路状态一段时间后(默认 5 秒), 自动切换到半开路状态(HALF-OPEN). 这时会判断下一次请求的返回情况,&lt;/p&gt;
&lt;p&gt;如果请求成功, 断路器切回闭路状态(CLOSED), 否则重新切换到开路状态(OPEN). Hystrix 的断路器就像我们家庭电路中的保险丝, 一旦后端服务不可用, 断路器会直接切断请求链, 避免发送大量无效请求影响系统吞吐量, 并且断路器有自我检测并恢复的能力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;API 管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SwaggerAPI 管理工具。&lt;/p&gt;
">微服务：服务注册发现+ API 网关+配置中心+配置中心+服务跟踪</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://https://chenm0.github.io/post/hibernate-cascadetype/"" data-c="
          &lt;h3 id=&#34;cascade属性-指定级联操作的行为可多选&#34;&gt;cascade属性： 指定级联操作的行为(可多选)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CascadeType.PERSIST 级联新增（又称级联保存）：&lt;/strong&gt;&lt;br&gt;
获取A对象里也同时也重新获取最新的B时的对象。即会重新查询数据库里的最新数据，并且，只有A类新增时，会级联B对象新增。若B对象在数据库存（跟新）在则抛异常（让B变为持久态），对应EntityManager的presist方法,调用JPA规范中的persist()，不适用于Hibernate的save()方法&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CascadeType.MERGE 级联合并（又称级联更新）&lt;/strong&gt;&lt;br&gt;
指A类新增或者变化，会级联B对象（新增或者变化） ，对应EntityManager的merge方法，调用JPA规范中merge()时，不适用于Hibernate的update()方法&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CascadeType.REMOVE 级联删除&lt;/strong&gt;&lt;br&gt;
只有A类删除时，会级联删除B类,即在设置的那一端进行删除时，另一端才会级联删除，对应EntityManager的remove方法，调用JPA规范中的remove()时，适用于Hibernate的delete()方法&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CascadeType.REFRESH 级联刷新&lt;/strong&gt;&lt;br&gt;
获取order（一或多）对象里也同时也重新获取最新的items（多）的对象，对应EntityManager的refresh(object)，调用JPA规范中的refresh()时，适用于Hibernate的flush()方法&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CascadeType.ALL&lt;/strong&gt;&lt;br&gt;
包含所有持久化方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;综上：大多数情况用CascadeType.MERGE就能达到级联跟新又不报错，用CascadeType.ALL时要斟酌下CascadeType.REMOVE&lt;/strong&gt;&lt;/p&gt;
">hibernate CascadeType属性说明</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://https://chenm0.github.io/post/postgresql-ques/"" data-c="
          &lt;ol&gt;
&lt;li&gt;在进行数据库记录的迁移和复制数据后容易出现错误&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;DETAIL:  Key (id)=(1) already exists
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select setval(&#39;tablename_id_seq&#39;, max(id)) from tablename;
&lt;/code&gt;&lt;/pre&gt;
">PostgreSQL踩坑记录</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://https://chenm0.github.io/post/shejimoshi-tongsu/"" data-c="
          &lt;h3 id=&#34;工厂方法&#34;&gt;工厂方法&lt;/h3&gt;
&lt;p&gt;追 MM 少不了请吃饭了，麦当劳的鸡翅和肯德基的鸡翅都是 MM 爱吃的东西，虽然口味有所不同，但不管你带 MM 去麦当劳或肯德基，只管向服务员说「来四个鸡翅」就行了。麦当劳和肯德基就是生产鸡翅的 Factory 工厂模式：客户类和工厂类分开。&lt;/p&gt;
&lt;p&gt;消费者任何时候需要某种产品，只需向工厂请求即可。消费者无须修改就可以接纳新产品。缺点是当产品修改时，工厂类也要做相应的修改。如：如何创建及如何向客户端提供。&lt;/p&gt;
&lt;h3 id=&#34;建造者模式&#34;&gt;建造者模式&lt;/h3&gt;
&lt;p&gt;MM 最爱听的就是「我爱你」这句话了，见到不同地方的 MM，要能够用她们的方言跟她说这句话哦，我有一个多种语言翻译机，上面每种语言都有一个按键，见到 MM 我只要按对应的键，它就能够用相应的语言说出「我爱你」这句话了，国外的 MM 也可以轻松搞掂，这就是我的「我爱你」builder。&lt;/p&gt;
&lt;p&gt;建造模式：将产品的内部表象和产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象。建造模式使得产品内部表象可以独立的变化，客户不必知道产品内部组成的细节。建造模式可以强制实行一种分步骤进行的建造过程。&lt;/p&gt;
&lt;h3 id=&#34;抽象工厂&#34;&gt;抽象工厂&lt;/h3&gt;
&lt;p&gt;请 MM 去麦当劳吃汉堡，不同的 MM 有不同的口味，要每个都记住是一件烦人的事情，我一般采用 Factory Method 模式，带着 MM 到服务员那儿，说「要一个汉堡」，具体要什么样的汉堡呢，让 MM 直接跟服务员说就行了。&lt;/p&gt;
&lt;p&gt;工厂方法模式：核心工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类去做，成为一个抽象工厂角色，仅负责给出具体工厂类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。&lt;/p&gt;
&lt;h3 id=&#34;原型模式&#34;&gt;原型模式&lt;/h3&gt;
&lt;p&gt;跟 MM 用 QQ 聊天，一定要说些深情的话语了，我搜集了好多肉麻的情话，需要时只要 copy 出来放到 QQ 里面就行了，这就是我的情话 prototype 了。（100 块钱一份，你要不要）&lt;/p&gt;
&lt;p&gt;原始模型模式：通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的方法创建出更多同类型的对象。原始模型模式允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。缺点是每一个类都必须配备一个克隆方法。&lt;/p&gt;
&lt;h3 id=&#34;单态模式&#34;&gt;单态模式&lt;/h3&gt;
&lt;p&gt;俺有 6 个漂亮的老婆，她们的老公都是我，我就是我们家里的老公 Sigleton，她们只要说道「老公」，都是指的同一个人，那就是我 (刚才做了个梦啦，哪有这么好的事)&lt;/p&gt;
&lt;p&gt;单例模式：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式。单例模式只应在有真正的 “单一实例” 的需求时才可使用&lt;/p&gt;
&lt;h3 id=&#34;适配器模式&#34;&gt;适配器模式&lt;/h3&gt;
&lt;p&gt;在朋友聚会上碰到了一个美女 Sarah，从香港来的，可我不会说粤语，她不会说普通话，只好求助于我的朋友 kent 了，他作为我和 Sarah 之间的 Adapter，让我和 Sarah 可以相互交谈了 (也不知道他会不会耍我)&lt;/p&gt;
&lt;p&gt;适配器（变压器）模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。适配类可以根据参数返还一个合适的实例给客户端。&lt;/p&gt;
&lt;h3 id=&#34;桥梁模式&#34;&gt;桥梁模式&lt;/h3&gt;
&lt;p&gt;早上碰到 MM，要说早上好，晚上碰到 MM，要说晚上好；碰到 MM 穿了件新衣服，要说你的衣服好漂亮哦，碰到 MM 新做的发型，要说你的头发好漂亮哦。不要问我 “早上碰到 MM 新做了个发型怎么说” 这种问题，自己用 BRIDGE 组合一下不就行了&lt;/p&gt;
&lt;p&gt;桥梁模式：将抽象化与实现化脱耦，使得二者可以独立的变化，也就是说将他们之间的强关联变成弱关联，也就是指在一个软件系统的抽象化和实现化之间使用组合 / 聚合关系而不是继承关系，从而使两者可以独立的变化。&lt;/p&gt;
&lt;h3 id=&#34;合成模式&#34;&gt;合成模式&lt;/h3&gt;
&lt;p&gt;Mary 今天过生日。“我过生日，你要送我一件礼物。”“嗯，好吧，去商店，你自己挑。”“这件 T 恤挺漂亮，买，这条裙子好看，买，这个包也不错，买。”“喂，买了三件了呀，我只答应送一件礼物的哦。”“什么呀，T 恤加裙子加包包，正好配成一套呀，小姐，麻烦你包起来。”“……”，MM 都会用 Composite 模式了，你会了没有？&lt;/p&gt;
&lt;p&gt;合成模式：合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。合成模式使得客户端把一个个单独的成分对象和由他们复合而成的合成对象同等看待。&lt;/p&gt;
&lt;h3 id=&#34;装饰模式&#34;&gt;装饰模式&lt;/h3&gt;
&lt;p&gt;Mary 过完轮到 Sarly 过生日，还是不要叫她自己挑了，不然这个月伙食费肯定玩完，拿出我去年在华山顶上照的照片，在背面写上 “最好的的礼物，就是爱你的 Fita”，再到街上礼品店买了个像框（卖礼品的 MM 也很漂亮哦），再找隔壁搞美术设计的 Mike 设计了一个漂亮的盒子装起来……，我们都是 Decorator，最终都在修饰我这个人呀，怎么样，看懂了吗？&lt;/p&gt;
&lt;p&gt;装饰模式：装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案，提供比继承更多的灵活性。动态给一个对象增加功能，这些功能可以再动态的撤消。增加由一些基本功能的排列组合而产生的非常大量的功能。&lt;/p&gt;
&lt;h3 id=&#34;门面模式&#34;&gt;门面模式&lt;/h3&gt;
&lt;p&gt;我有一个专业的 Nikon 相机，我就喜欢自己手动调光圈、快门，这样照出来的照片才专业，但 MM 可不懂这些，教了半天也不会。幸好相机有 Facade 设计模式，把相机调整到自动档，只要对准目标按快门就行了，一切由相机自动调整，这样 MM 也可以用这个相机给我拍张照片了。门面模式：外部与一个子系统的通信必须通过一个统一的门面对象进行。&lt;/p&gt;
&lt;p&gt;门面模式提供一个高层次的接口，使得子系统更易于使用。每一个子系统只有一个门面类，而且此门面类只有一个实例，也就是说它是一个单例模式。但整个系统可以有多个门面类。&lt;/p&gt;
&lt;h3 id=&#34;享元模式&#34;&gt;享元模式&lt;/h3&gt;
&lt;p&gt;每天跟 MM 发短信，手指都累死了，最近买了个新手机，可以把一些常用的句子存在手机里，要用的时候，直接拿出来，在前面加上 MM 的名字就可以发送了，再不用一个字一个字敲了。共享的句子就是 Flyweight，MM 的名字就是提取出来的外部特征，根据上下文情况使用。享元模式：FLYWEIGHT 在拳击比赛中指最轻量级。&lt;/p&gt;
&lt;p&gt;享元模式以共享的方式高效的支持大量的细粒度对象。享元模式能做到共享的关键是区分内蕴状态和外蕴状态。内蕴状态存储在享元内部，不会随环境的改变而有所不同。外蕴状态是随环境的改变而改变的。外蕴状态不能影响内蕴状态，它们是相互独立的。&lt;/p&gt;
&lt;p&gt;将可以共享的状态和不可以共享的状态从常规类中区分开来，将不可以共享的状态从类里剔除出去。客户端不可以直接创建被共享的对象，而应当使用一个工厂对象负责创建被共享的对象。享元模式大幅度的降低内存中对象的数量。&lt;/p&gt;
&lt;h3 id=&#34;代理模式&#34;&gt;代理模式&lt;/h3&gt;
&lt;p&gt;跟 MM 在网上聊天，一开头总是 “hi, 你好”,“你从哪儿来呀？”“你多大了？”“身高多少呀？” 这些话，真烦人，写个程序做为我的 Proxy 吧，凡是接收到这些话都设置好了自己的回答，接收到其他的话时再通知我回答，怎么样，酷吧。&lt;/p&gt;
&lt;p&gt;代理模式：代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用。代理就是一个人或一个机构代表另一个人或者一个机构采取行动。某些情况下，客户不想或者不能够直接引用一个对象，代理对象可以在客户和目标对象直接起到中介的作用。&lt;/p&gt;
&lt;p&gt;客户端分辨不出代理主题对象与真实主题对象。代理模式可以并不知道真正的被代理对象，而仅仅持有一个被代理对象的接口，这时候代理对象不能够创建被代理对象，被代理对象必须有系统的其他角色代为创建并传入。&lt;/p&gt;
&lt;h3 id=&#34;责任链模式&#34;&gt;责任链模式&lt;/h3&gt;
&lt;p&gt;晚上去上英语课，为了好开溜坐到了最后一排，哇，前面坐了好几个漂亮的 MM 哎，找张纸条，写上 “Hi, 可以做我的女朋友吗？如果不愿意请向前传”，纸条就一个接一个的传上去了，糟糕，传到第一排的 MM 把纸条传给老师了，听说是个老处女呀，快跑！&lt;/p&gt;
&lt;p&gt;责任链模式：在责任链模式中，很多对象由每一个对象对其下家的引用而接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。客户并不知道链上的哪一个对象最终处理这个请求，系统可以在不影响客户端的情况下动态的重新组织链和分配责任。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象所接受。&lt;/p&gt;
&lt;h3 id=&#34;命令模式&#34;&gt;命令模式&lt;/h3&gt;
&lt;p&gt;俺有一个 MM 家里管得特别严，没法见面，只好借助于她弟弟在我们俩之间传送信息，她对我有什么指示，就写一张纸条让她弟弟带给我。这不，她弟弟又传送过来一个 COMMAND，为了感谢他，我请他吃了碗杂酱面，哪知道他说：“我同时给我姐姐三个男朋友送 COMMAND，就数你最小气，才请我吃面。”&lt;/p&gt;
&lt;p&gt;命令模式：命令模式把一个请求或者操作封装到一个对象中。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。命令模式允许请求的一方和发送的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否执行，何时被执行以及是怎么被执行的。系统支持命令的撤消。&lt;/p&gt;
&lt;h3 id=&#34;解释器模式&#34;&gt;解释器模式&lt;/h3&gt;
&lt;p&gt;俺有一个《泡 MM 真经》，上面有各种泡 MM 的攻略，比如说去吃西餐的步骤、去看电影的方法等等，跟 MM 约会时，只要做一个 Interpreter，照着上面的脚本执行就可以了。&lt;/p&gt;
&lt;p&gt;解释器模式：给定一个语言后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。解释器模式将描述怎样在有了一个简单的文法后，使用模式设计解释这些语句。&lt;/p&gt;
&lt;p&gt;在解释器模式里面提到的语言是指任何解释器对象能够解释的任何组合。在解释器模式中需要定义一个代表文法的命令类的等级结构，也就是一系列的组合规则。每一个命令对象都有一个解释方法，代表对命令对象的解释。命令对象的等级结构中的对象的任何排列组合都是一个语言。&lt;/p&gt;
&lt;h3 id=&#34;迭代模式&#34;&gt;迭代模式&lt;/h3&gt;
&lt;p&gt;我爱上了 Mary，不顾一切的向她求婚。Mary：“想要我跟你结婚，得答应我的条件” 我：“什么条件我都答应，你说吧” Mary：“我看上了那个一克拉的钻石” 我：“我买，我买，还有吗？” Mary：“我看上了湖边的那栋别墅” 我：“我买，我买，还有吗？” Mary：“我看上那辆法拉利跑车” 我脑袋嗡的一声，坐在椅子上，一咬牙：“我买，我买，还有吗？”&lt;/p&gt;
&lt;p&gt;迭代模式：迭代模式可以顺序访问一个聚集中的元素而不必暴露聚集的内部表象。多个对象聚在一起形成的总体称之为聚集，聚集对象是能够包容一组对象的容器对象。迭代子模式将迭代逻辑封装到一个独立的子对象中，从而与聚集本身隔开。&lt;/p&gt;
&lt;p&gt;迭代模式简化了聚集的界面。每一个聚集对象都可以有一个或一个以上的迭代子对象，每一个迭代子的迭代状态可以是彼此独立的。迭代算法可以独立于聚集角色变化。&lt;/p&gt;
&lt;h3 id=&#34;调停者模式&#34;&gt;调停者模式&lt;/h3&gt;
&lt;p&gt;四个 MM 打麻将，相互之间谁应该给谁多少钱算不清楚了，幸亏当时我在旁边，按照各自的筹码数算钱，赚了钱的从我这里拿，赔了钱的也付给我，一切就 OK 啦，俺得到了四个 MM 的电话。调停者模式：调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使他们可以松散偶合。&lt;/p&gt;
&lt;p&gt;当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。保证这些作用可以彼此独立的变化。调停者模式将多对多的相互作用转化为一对多的相互作用。调停者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。&lt;/p&gt;
&lt;h3 id=&#34;备忘录模式&#34;&gt;备忘录模式&lt;/h3&gt;
&lt;p&gt;同时跟几个 MM 聊天时，一定要记清楚刚才跟 MM 说了些什么话，不然 MM 发现了会不高兴的哦，幸亏我有个备忘录，刚才与哪个 MM 说了什么话我都拷贝一份放到备忘录里面保存，这样可以随时察看以前的记录啦。&lt;/p&gt;
&lt;p&gt;备忘录模式：备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。&lt;/p&gt;
&lt;h3 id=&#34;观察者模式&#34;&gt;观察者模式&lt;/h3&gt;
&lt;p&gt;想知道咱们公司最新 MM 情报吗？加入公司的 MM 情报邮件组就行了，tom 负责搜集情报，他发现的新情报不用一个一个通知我们，直接发布给邮件组，我们作为订阅者（观察者）就可以及时收到情报啦。&lt;/p&gt;
&lt;p&gt;观察者模式：观察者模式定义了一种一队多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。&lt;/p&gt;
&lt;h3 id=&#34;状态模式&#34;&gt;状态模式&lt;/h3&gt;
&lt;p&gt;跟 MM 交往时，一定要注意她的状态哦，在不同的状态时她的行为会有不同，比如你约她今天晚上去看电影，对你没兴趣的 MM 就会说 “有事情啦”，对你不讨厌但还没喜欢上的 MM 就会说 “好啊，不过可以带上我同事么？”，已经喜欢上你的 MM 就会说 “几点钟？看完电影再去泡吧怎么样？”，当然你看电影过程中表现良好的话，也可以把 MM 的状态从不讨厌不喜欢变成喜欢哦。&lt;/p&gt;
&lt;p&gt;状态模式：状态模式允许一个对象在其内部状态改变的时候改变行为。这个对象看上去象是改变了它的类一样。状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。&lt;/p&gt;
&lt;p&gt;状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。&lt;/p&gt;
&lt;h3 id=&#34;策略模式&#34;&gt;策略模式&lt;/h3&gt;
&lt;p&gt;跟不同类型的 MM 约会，要用不同的策略，有的请电影比较好，有的则去吃小吃效果不错，有的去海边浪漫最合适，单目的都是为了得到 MM 的芳心，我的追 MM 锦囊中有好多 Strategy 哦。策略模式：策略模式针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。&lt;/p&gt;
&lt;p&gt;策略模式使得算法可以在不影响到客户端的情况下发生变化。策略模把行为和环境分开。环境类负责维持和查询行为类，各种算法在具体的策略类中提供。由于算法和环境独立开来，算法的增减，修改都不会影响到环境和客户端&lt;/p&gt;
&lt;h3 id=&#34;模版方法模式&#34;&gt;模版方法模式&lt;/h3&gt;
&lt;p&gt;看过《如何说服女生上床》这部经典文章吗？女生从认识到上床的不变的步骤分为巧遇、打破僵局、展开追求、接吻、前戏、动手、爱抚、进去八大步骤 (Template method)，但每个步骤针对不同的情况，都有不一样的做法，这就要看你随机应变啦 (具体实现)；&lt;/p&gt;
&lt;p&gt;模板方法模式：模板方法模式准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。&lt;/p&gt;
&lt;h3 id=&#34;访问者模式&#34;&gt;访问者模式&lt;/h3&gt;
&lt;p&gt;情人节到了，要给每个 MM 送一束鲜花和一张卡片，可是每个 MM 送的花都要针对她个人的特点，每张卡片也要根据个人的特点来挑，我一个人哪搞得清楚，还是找花店老板和礼品店老板做一下 Visitor，让花店老板根据 MM 的特点选一束花，让礼品店老板也根据每个人特点选一张卡，这样就轻松多了；&lt;/p&gt;
&lt;p&gt;访问者模式：访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。访问者模式使得增加新的操作变的很容易，就是增加一个新的访问者类。&lt;/p&gt;
&lt;p&gt;访问者模式将有关的行为集中到一个访问者对象中，而不是分散到一个个的节点类中。当使用访问者模式时，要将尽可能多的对象浏览逻辑放在访问者类中，而不是放到它的子类中。访问者模式可以跨过几个类的等级结构访问属于不同的等级结构的成员类。&lt;/p&gt;
">设计模式的通俗理解</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://https://chenm0.github.io/post/thymeleaf/"" data-c="
          &lt;p&gt;如需了解Thymeleaf 基本表达式，请参考《&lt;a href=&#34;http://www.cnblogs.com/hjwublog/p/5051632.html&#34;&gt;Thymeleaf &lt;/a&gt;&lt;a href=&#34;http://www.cnblogs.com/hjwublog/p/5051632.html&#34;&gt;基本表达式&lt;/a&gt;》一文&lt;/p&gt;
&lt;h1 id=&#34;thaction&#34;&gt;&lt;strong&gt;th:action&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;定义后台控制器路径，类似&lt;form&gt;标签的action属性。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;form id=&amp;quot;login-form&amp;quot; th:action=&amp;quot;@{/login}&amp;quot;&amp;gt;...&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;theach&#34;&gt;&lt;strong&gt;th:each&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;对象遍历，功能类似jstl中的&amp;lt;c:forEach&amp;gt;标签。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class StudentRequestBean {

private List&amp;lt;Student&amp;gt; students;

...

}

public class Student implements Serializable{

private String firstName;

private String school;

...}

@RequestMapping(value = &amp;quot;/addStudent&amp;quot;, method = RequestMethod.POST)

public String addStudent(@ModelAttribute(value = &amp;quot;stuReqBean&amp;quot;) 

StudentRequestBean stuReqBean，ModelMap model) {...}
&lt;/code&gt;&lt;/pre&gt;
&lt;form id=&#34;login-form&#34; th:action=&#34;@{/addStudent}&#34; 
```
th:object=&#34;${stuReqBean}&#34; method=&#34;POST&#34;&gt;
&lt;div class=&#34;student&#34; th:each=&#34;stuIter,rowStat:${stuReqBean.students}&#34;&gt;
&lt;p&gt;&amp;lt;input type=&amp;quot;text&amp;quot; class=&amp;quot;firstName&amp;quot; value=&amp;quot;&amp;quot;&lt;/p&gt;
&lt;p&gt;th:field=&amp;quot;*{students[&lt;strong&gt;${rowStat.index}&lt;/strong&gt;].firstName}&amp;quot;&amp;gt;&lt;/input&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;input type=&amp;quot;text&amp;quot; class=&amp;quot;school&amp;quot; value=&amp;quot;&amp;quot;&lt;/p&gt;
&lt;p&gt;th:field=&amp;quot;*{students[&lt;strong&gt;${rowStat.index}&lt;/strong&gt;].school}&amp;quot;&amp;gt;&lt;/input&gt;&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;/div&gt;
&lt;/form&gt;
```
&lt;p&gt;上面的例子中通过选择表达式*{}既能将表单绑定到后台的StudentRequestBean中的集合属性students，也能将Servlet上下文中的StudentRequestBean中的List类型的students变量回显，回显时通过th:each进行遍历。&lt;/p&gt;
&lt;p&gt;注意1：绑定集合属性元素下标的用法*{students[&lt;strong&gt;${rowStat.index}&lt;/strong&gt;].firstName}&lt;/p&gt;
&lt;p&gt;注意2：如果List&lt;Student&gt; students为null，页面将无法显示表单，后台必须给students初始化一个值，即:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;List&amp;lt;Student &amp;gt; stus = new ArrayList&amp;lt;Student &amp;gt;();

stus .add(new Student ());

StudentRequestBean.setStudents(stus );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意3：stuIter代表students的迭代器&lt;/p&gt;
&lt;h1 id=&#34;thfield&#34;&gt;&lt;strong&gt;th:field&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;常用于表单字段绑定。通常与th:object一起使用。 属性绑定、集合绑定。&lt;/p&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class LoginBean implements Serializable{...

private String username;

private List&amp;lt;User&amp;gt; user;

...}


public class User implements Serializable{...

private String username;;

...}


@RequestMapping(value = &amp;quot;/login&amp;quot;, method = RequestMethod.POST)

public String login(@ModelAttribute(value = &amp;quot;loginBean&amp;quot;) LoginBean loginBean，ModelMap model) {..}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;form id=&amp;quot;login-form&amp;quot; th:action=&amp;quot;@{/login}&amp;quot; th:object=&amp;quot;${loginBean}&amp;quot;&amp;gt;...

&amp;lt;input type=&amp;quot;text&amp;quot; value=&amp;quot;&amp;quot; th:field=&amp;quot;*{username}&amp;quot;&amp;gt;&amp;lt;/input&amp;gt;

&amp;lt;input type=&amp;quot;text&amp;quot; value=&amp;quot;&amp;quot; th:field=&amp;quot;*{user[0].username}&amp;quot;&amp;gt;&amp;lt;/input&amp;gt;

&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;thhref&#34;&gt;&lt;strong&gt;th:href&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;定义超链接，类似&lt;a&gt;标签的href 属性。value形式为@{/logout}&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;a th:href=&amp;quot;@{/logout}&amp;quot; class=&amp;quot;signOut&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;thid&#34;&gt;&lt;strong&gt;th:id&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;div id声明，类似html标签中的id属性。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;student&amp;quot; th:id = &amp;quot;stu+(${rowStat.index}+1)&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;thif&#34;&gt;&lt;strong&gt;th:if&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;条件判断。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div th:if=&amp;quot;${rowStat.index} == 0&amp;quot;&amp;gt;... do something ...&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;thinclude&#34;&gt;&lt;strong&gt;th:include&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;见th:fragment&lt;/p&gt;
&lt;h1 id=&#34;thfragment&#34;&gt;&lt;strong&gt;th:fragment&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;声明定义该属性的div为模板片段，常用与头文件、页尾文件的引入。常与th:include，th:replace一起使用。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;声明模板片段/WEBINF/templates/footer. html&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div th: fragment=&amp;quot; copy&amp;quot; &amp;gt;

© 2011 The Good Thymes Virtual Grocery

&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;引入模板片段&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div th: include=&amp;quot; /templates/footer : : copy&amp;quot; &amp;gt;&amp;lt;/div&amp;gt;

&amp;lt;div th: replace=&amp;quot; /templates/footer : : copy&amp;quot; &amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;thobject&#34;&gt;&lt;strong&gt;th:object&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;用于表单数据对象绑定，将表单绑定到后台controller的一个JavaBean参数。常与th:field一起使用进行表单数据绑定。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class LoginBean implements Serializable{...}


@RequestMapping(value = &amp;quot;/login&amp;quot;, method = RequestMethod.POST)

public String login(@ModelAttribute(value = &amp;quot;loginBean&amp;quot;) LoginBean loginBean，ModelMap model) {...}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;form id=&amp;quot;login-form&amp;quot; th:action=&amp;quot;@{/login}&amp;quot; th:object=&amp;quot;${loginBean}&amp;quot;&amp;gt;...&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;thsrc&#34;&gt;&lt;strong&gt;th:src&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;用于外部资源引入，类似于&lt;script&gt;标签的src属性，常与@{}一起使用。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script th:src=&amp;quot;@{/resources/js/jquery/jquery.json-2.4.min.js}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;threplace&#34;&gt;&lt;strong&gt;th:replace&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;见th:fragment&lt;/p&gt;
&lt;h1 id=&#34;thtext&#34;&gt;&lt;strong&gt;th:text&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;文本显示。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;td class=&amp;quot;text&amp;quot; th:text=&amp;quot;${username}&amp;quot; &amp;gt;&amp;lt;/td&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;thvalue&#34;&gt;&lt;strong&gt;th:value&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;用于标签复制，类似&lt;option&gt;标签的value属性。&lt;/p&gt;
&lt;p&gt;例如:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;option th:value=&amp;quot;Adult&amp;quot;&amp;gt;Adult&amp;lt;/option&amp;gt;

&amp;lt;input  id=&amp;quot;msg&amp;quot; type=&amp;quot;hidden&amp;quot; th:value=&amp;quot;${msg}&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
">Thymeleaf常用属性</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://https://chenm0.github.io/post/cms1/"" data-c="
          &lt;pre&gt;&lt;code&gt;内容管理系统是一种位于WEB 前端（Web 服务器）和后端办公系统或流程（内容创作、编辑）之间的软件系统，本文是对于内容管理系统CMS在内容生产环节的总结与分享。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;*关于CMS内容管理系统：*&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;内容管理系统（content management system，CMS）是一种位于WEB 前端（Web 服务器）和后端办公系统或流程（内容创作、编辑）之间的软件系统。&lt;/p&gt;
&lt;p&gt;“内容”是任何类型的数字信息，可以是文本、图形图像、Web页面、业务文档、数据库表单、视频、声音、XML文件等。&lt;/p&gt;
&lt;h3 id=&#34;1-关于cms搭建的思考&#34;&gt;1. 关于CMS搭建的思考&lt;/h3&gt;
&lt;p&gt;通常，设计一个产品之前，我们需要思考以下几个基本的问题：&lt;/p&gt;
&lt;p&gt;**产品目标：**我们希望通过这个产品得到什么？&lt;/p&gt;
&lt;p&gt;——这决定我们要做成一个什么类型的产品&lt;/p&gt;
&lt;p&gt;**目标用户：**产品面向的目标用户具有什么特征？&lt;/p&gt;
&lt;p&gt;——这决定我们去哪找什么样的用户&lt;/p&gt;
&lt;p&gt;**用户需求：**我们的用户希望通过这个产品得到什么？&lt;/p&gt;
&lt;p&gt;——这决定我们要设计哪些功能模块&lt;/p&gt;
&lt;p&gt;**场景动机：**我们的用户在什么样的场景下会有使用产品的动机？&lt;/p&gt;
&lt;p&gt;——这决定我们要怎么设计产品&lt;/p&gt;
&lt;p&gt;**标准指标：**想法正确、方案合理、市场匹配的标准/指标是什么？&lt;/p&gt;
&lt;p&gt;——这决定我们的目标是否达成&lt;/p&gt;
&lt;p&gt;我们需要思考和梳理的内容，可概括为3点：对象、痛点、解决方案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对象：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;内容的生产人员，例：运营、用户（由用户端满足需求）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内容的审核人员，例：运营、客服&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内容的推广人员，例：运营、用户（由用户端满足需求）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;相互作用的系统，例：过滤系统、推荐系统&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;痛点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;运营：高效地完成内容生产、便捷地审核用户推荐、特定需求的人工推荐、推荐系统的精准度优化、及时直观地获取到内容运营的数据情况；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;客服：便捷地审核用户举报、问题用户的管理、推荐系统的精准度优化；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;过滤系统：对内容完成智能过滤；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;推荐系统：对内容完成智能推荐。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;解决方案：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运营：好用的内容编辑、修改和发布工具；待审核的处理工作台；人工推荐配置支持、推荐系统的运作情况；内容运营数据的可视化呈现；&lt;/li&gt;
&lt;li&gt;客服：待审核的处理工作台；用户标记管理、过滤系统的运作情况；&lt;/li&gt;
&lt;li&gt;过滤系统：系统的搭建和持续优化方案；&lt;/li&gt;
&lt;li&gt;推荐系统：系统的搭建和持续优化方案。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://https://chenm0.github.io//post-images/1621580833843.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;2-内容的生产来源&#34;&gt;2. 内容的生产(来源)&lt;/h3&gt;
&lt;p&gt;CMS内容管理系统，从字面意思就能知道，管理的对象是“内容”，而“内容”的具体类型是什么、“管理”的具体范畴是什么，这些都是要依据具体的业务而定。&lt;/p&gt;
&lt;p&gt;得有内容才有管理，没内容谈何管理呢？那问题来了，内容从哪里来呢？来源都有哪些？&lt;/p&gt;
&lt;h4 id=&#34;21-常见的内容生产模式&#34;&gt;2.1 常见的内容生产模式&lt;/h4&gt;
&lt;p&gt;介绍一下常见的内容生产模式，有以下三种：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UGC模式：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全称：user generated content。即：用户输出内容。&lt;/li&gt;
&lt;li&gt;产品代表：小红书。主要通过激励用户生产内容，形成社区氛围。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;PGC模式：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全称：professionally generated content。即：专业输出内容。&lt;/li&gt;
&lt;li&gt;产品代表：知乎。主要通过专业人员生产内容，提供给用户消费。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;OGC模式：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;全称：occupationally generated content。即：职业输出内容。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;产品代表：新闻资讯类。主要通过具有一定知识和专业背景的行业人士生产内容，并领取相应报酬。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;三者之间的区别：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;UGC与PGC的区别：生产内容的人有无专业知识、资质；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PGC与OGC的区别：生产内容的人是否以此为职业，获得对应的报酬。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;往往PGC模式的内容生产者，也是产品的用户，还可能是种子用户、忠诚用户、意见领袖。&lt;/p&gt;
&lt;p&gt;综上，我们可以将内容的来源分成4种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户生产（UGC&amp;amp;PGC）&lt;/li&gt;
&lt;li&gt;运营生产（OGC）&lt;/li&gt;
&lt;li&gt;技术爬取（通过技术手段去爬取内容）&lt;/li&gt;
&lt;li&gt;授权使用（以付费的形式购买内容版权）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中：用户生产内容的产品支持，可由用户端的产品设计来满足。&lt;/p&gt;
&lt;p&gt;技术爬取和授权使用，在需求明确的前提下，主要是由技术人员来实现和对接。&lt;/p&gt;
&lt;p&gt;如果存在与多家平台有版权内容的授权对接工作，那建议可开发统一的内容接入接口。不同的版权内容平台，可能对接的方式有着大大小小的差异，这里可能涉及到一定的开发工作量。作为一名尽职的B端产品经理，本着为公司降本（降低开发成本）提效（提高版本效率）的一贯原则，最理想的状态是把统一的接口文档一发，就能把部分的开发工作量给转移了出去。但现实往往都是很骨感的，如果对方是“爸爸”，愿意把内容的版权给你就已经很难得了，那还是得乖乖自个儿开发接入。&lt;/p&gt;
&lt;p&gt;以过来人的经验（踩过坑的那种），这部分的工作不要过分依赖开发，由其独自对接完成，需要加入必要的管理和规划，以免重复低效的工作占用太多的开发资源，或是人员离职变动带来的麻烦。至于价值、重要程度和优先级，需依据自己的项目、产品和团队情况，具体评估。&lt;/p&gt;
&lt;p&gt;而内容管理系统（CMS）在生产环节主要服务的对象是负责内容生产的运营小伙伴。&lt;/p&gt;
&lt;p&gt;一般情况下，内容运营除了管理官方账号外，可能同时还在运营着多个个人账号，如果运营同事也是依靠用户端来完成内容发布的工作，那就会存在频繁切换登录不同账号的麻烦。而切换登录这个需求对于普通用户可能根本就不存在。&lt;/p&gt;
&lt;p&gt;除此之外，内容运营还存在用户需求之上的发布需求，比如可以预设定时发布等等。&lt;/p&gt;
&lt;h4 id=&#34;22-cms在生产环节的需求点&#34;&gt;2.2 CMS在生产环节的需求点&lt;/h4&gt;
&lt;p&gt;总结一下，内容管理系统（CMS）在生产环节的需求概要有：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;账号关联：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;和CMS系统账号关联，支持系统账号和运营账号一对多的关系；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用CMS系统发布内容时候，可选择对应的运营账号；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持运营账号解除绑定或转移，以便应对人员调整或离职的变动。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;生产工具：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提供便捷、好用的编辑功能；&lt;/li&gt;
&lt;li&gt;支持效果预览；&lt;/li&gt;
&lt;li&gt;可保存草稿。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;**素材管理：**如果对素材的复用度较高，可考虑增加素材管理，同时也方便随时随地有台电脑登录系统就能开展工作，避免素材要用起来才发现保存在某台电脑本地的尴尬。&lt;/p&gt;
&lt;p&gt;**模板管理：**如果对特定内容的排版呈现有统一的要求，例如“每日推荐”等，只需要替换具体内容和素材即可，则可以增加模板管理，为运营减免重复不必要的排版布局工作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;预设时间发布：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内容通常都是提前就会准备好的，尤其是针对一些节日主题或活动营销的内容，会提前思考、撰写，并对更新的节奏做好规划排期（就像产品经理做版本规划一样）。&lt;/li&gt;
&lt;li&gt;如果有提供定时发布功能，那负责内容运营的同事就可以集中时间一次性地把准备好的内容提前设置好发布时间，使其更合理的安排工作时间和实施内容计划，提高工作效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;早期的版本，可仅提供基本的、必要的管理、编辑和发布功能，保证内容运营的顺利生产。而更能提高效率的工具和功能，则可与运营部门确认整体的内容工作规划，在不同的时期配合新增上线。&lt;/p&gt;
&lt;p&gt;具体的功能设计可参考：微信公众平台、秀米编辑器、365编辑器。&lt;/p&gt;
&lt;p&gt;以上，就是对于内容管理系统CMS在内容生产环节的总结与分享。后面，还会有CMS在内容过滤、内容呈现和内容举报环节的文章更新。&lt;/p&gt;
">搭建内容管理系统CMS（1）：如何支持内容生产？</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://https://chenm0.github.io/post/amazons3-util/"" data-c="
          &lt;pre&gt;&lt;code&gt;/**
 * @author chenmo
 * @Date: Created in 2021/5/12 5:05 下午
 * @Utils: Intellij Idea
 * @Description: TODO
 */
@Component
@RequiredArgsConstructor
public class AmazonS3Operator {

    private static final Logger LOGGER = LoggerFactory.getLogger(AmazonS3Operator.class);

    final AmazonS3Configuration amazonS3Configuration;

    //创建链接
    public AmazonS3 createConnection(){
        var credentials = new BasicAWSCredentials(amazonS3Configuration.getAccessKey(), amazonS3Configuration.getSecretKey());
        var conn = new AmazonS3Client(credentials);
        conn.setEndpoint(amazonS3Configuration.getEndPoint());
        var buckets = conn.listBuckets();
        LOGGER.info(&amp;quot;amazonS3 bucket list ==========================================&amp;quot;);
        for (Bucket bucket : buckets) {
            LOGGER.info(&amp;quot;amazonS3 bucket =========&amp;gt;&amp;quot;+bucket.getName() + &amp;quot;\t&amp;quot; +
                    StringUtils.fromDate(bucket.getCreationDate()));
        }
        LOGGER.info(&amp;quot;================================================================&amp;quot;);
        return conn;
    }

    //创建Bucket
    public Bucket createBucket(String name){
        return createConnection().createBucket(name);
    }

    //上传一个文件
    public String uploadFileToBucket(MultipartFile multipartFile){
        var snowflake = new Snowflake(1,1);
        var key = snowflake.nextIdStr();
        FileInputStream fileInputStream = null;
        try {
            fileInputStream = (FileInputStream) multipartFile.getInputStream();
            createConnection().putObject(amazonS3Configuration.getBucket(),key,fileInputStream,new ObjectMetadata());
            LOGGER.info(&amp;quot;上传文件&amp;quot;+key+&amp;quot;：&amp;quot;+multipartFile.getName()+ &amp;quot;到&amp;quot;+amazonS3Configuration.getBucket()+&amp;quot;成功！！！！&amp;quot;);
            return key;
        }catch (FileNotFoundException e){
            LOGGER.info(&amp;quot;上传文件&amp;quot;+key+&amp;quot;：&amp;quot;+multipartFile.getName()+  &amp;quot;到&amp;quot;+amazonS3Configuration.getBucket()+&amp;quot;失败，文件未找到&amp;quot;);
            return null;
        }catch (IOException e){
            e.printStackTrace();
            return null;
        }finally {
            try {
                if(fileInputStream != null){
                    fileInputStream.close();
                }
            }catch (IOException e){
                LOGGER.debug(&amp;quot;inputStream close IOException:&amp;quot; + e.getMessage());
                e.printStackTrace();
            }
        }
    }

    //预览一个文件
    public String reviewFileFromBucket(String key){
        try {
            if(StringUtils.isNullOrEmpty(key)){
                return null;
            }
            var httpRequest = new GeneratePresignedUrlRequest(amazonS3Configuration.getBucket(), key);
            return createConnection().generatePresignedUrl(httpRequest).toString();
        }catch (Exception e){
            e.printStackTrace();
        }
        return null;
    }

}
&lt;/code&gt;&lt;/pre&gt;
">AmazonS3工具类</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://https://chenm0.github.io/post/design-study/"" data-c="
          &lt;h3 id=&#34;设计模式的目的&#34;&gt;设计模式的目的&lt;/h3&gt;
&lt;p&gt;编写软件过程中，程序员面临着来自 耦合性，内聚性以及可维护性，可扩展性，重用性，灵活性 等多方面的挑战，设计模式是为了让程序(软件)具有更好的:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;代码重用性 (即：相同功能的代码，不用多次编写)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可读性 (即：编程规范性, 便于其他程序员的阅读和理解)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可扩展性 (即：当需要增加新的功能时，非常的方便，称为可维护)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可靠性 (即：当我们增加新的功能后，对原来的功能没有影响)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使程序呈现高内聚，低耦合的特性&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;“懂了设计模式，你就懂了面向对象分析和设计（OOA/D）的精要” ----设计模式包含了面向对象的精髓

“C++老手和 C++新手的区别就是前者手背上有很多伤疤” ----Scott Mayers 在其巨著《Effective C++》
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;设计模式七大原则&#34;&gt;设计模式七大原则&lt;/h3&gt;
&lt;p&gt;设计模式原则，其实就是程序员在编程时，应当遵守的原则，也是各种设计模式的基础(即：设计模式为什么这样设计的依据)&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;Ø 设计模式常用的七大原则有:&lt;/mark&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;单一职责原则&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接口隔离原则&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;依赖倒转(倒置)原则&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;里氏替换原则&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开闭原则&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;迪米特法则&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;合成复用原则&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;单一职责原则&#34;&gt;单一职责原则&lt;/h4&gt;
&lt;h5 id=&#34;基本介绍&#34;&gt;基本介绍&lt;/h5&gt;
&lt;p&gt;对类来说的，即一个类应该只负责一项职责。如类 A 负责两个不同职责：职责 1，职责 2。当职责 1 需求变更而改变 A 时，可能造成职责 2 执行错误，所以需要将类 A 的粒度分解为 A1，A2&lt;/p&gt;
&lt;h5 id=&#34;应用实例&#34;&gt;应用实例&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;方案一:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 1. 在方式 1 的 run 方法中，违反了单一职责原则
// 2. 解决的方案非常的简单，根据交通工具运行方法不同，分解成不同类即可
public class SingleResponsibility1{
	public static void main(String[] args){
		Vehicle vehicle = new Vehicle();
		vehicle.run(&amp;quot;摩托车&amp;quot;);
		vehicle.run(&amp;quot;汽车&amp;quot;);
		vehicle.run(&amp;quot;飞机&amp;quot;);
	}
}
class Vehicle {
	public void run(String vehicle) { 
			System.out.println(vehicle + &amp;quot; 在公路上运行....&amp;quot;);
	}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;方案二&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//方案 2 的分析
//1. 遵守单一职责原则
//2. 但是这样做的改动很大，即将类分解，同时修改客户端
//3. 改进：直接修改 Vehicle 类，改动的代码会比较少=&amp;gt;方案 3
public class SingleResponsibility1{
	public static void main(String[] args){
		RoadVehicle roadVehicle = new RoadVehicle();
		roadVehicle.run(&amp;quot;摩托车&amp;quot;);
		roadVehicle.run(&amp;quot;汽车&amp;quot;);
		AirVehicle airVehicle = new AirVehicle();
		airVehicle.run(&amp;quot;飞机&amp;quot;);
	}
}
class RoadVehicle {
	public void run(String vehicle) { 
		System.out.println(vehicle + &amp;quot;公路运行&amp;quot;);
	}
}


class AirVehicle {
	public void run(String vehicle) { 
		System.out.println(vehicle + &amp;quot;天空运行&amp;quot;);
	}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;方案三&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//方式 3 的分析
//1. 这种修改方法没有对原来的类做大的修改，只是增加方法
//2. 这里虽然没有在类这个级别上遵守单一职责原则，但是在方法级别上，仍然是遵守单一职责
public class SingleResponsibility3 {
	public static void main(String[] args) {
		Vehicle2 vehicle2	= new Vehicle2();
		vehicle2.run(&amp;quot;汽车&amp;quot;);
		vehicle2.runWater(&amp;quot;轮船&amp;quot;);
		vehicle2.runAir(&amp;quot;飞机&amp;quot;);
	}
}
class Vehicle2 {
	public void run(String vehicle) {
		//处理
		System.out.println(vehicle + &amp;quot; 在公路上运行....&amp;quot;);
	}
	public void runAir(String vehicle) { 
		System.out.println(vehicle + &amp;quot; 在天空上运行....&amp;quot;);
	}
	public void runWater(String vehicle) { 
		System.out.println(vehicle + &amp;quot; 在水中行....&amp;quot;);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;单一职责原则注意事项和细节
1)	降低类的复杂度，一个类只负责一项职责。
2)	提高类的可读性，可维护性
3)	降低变更引起的风险
4)	通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;接口隔离原则interface-segregation-principle&#34;&gt;接口隔离原则(Interface Segregation Principle)&lt;/h4&gt;
&lt;h5 id=&#34;基本介绍-2&#34;&gt;基本介绍&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上&lt;/li&gt;
&lt;li&gt;类 A 通过接口 Interface1 依赖类 B，类 C 通过接口 Interface1 依赖类 D，如果接口 Interface1 对于类 A 和类 C来说不是最小接口，那么类 B 和类 D 必须去实现他们不需要的方法。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;public class Segregation1 {

public static void main(String[] args) {
// TODO Auto-generated method stub
}

}

//接口
interface Interface1 {
void operation1(); void operation2();
 

void operation3(); void operation4(); void operation5();
}


class B implements Interface1 { public void operation1() {
System.out.println(&amp;quot;B 实现了 operation1&amp;quot;);
}
public void operation2() {
System.out.println(&amp;quot;B 实现了 operation2&amp;quot;);
}
public void operation3() {
System.out.println(&amp;quot;B 实现了 operation3&amp;quot;);
}
public void operation4() {
System.out.println(&amp;quot;B 实现了 operation4&amp;quot;);
}
public void operation5() {
System.out.println(&amp;quot;B 实现了 operation5&amp;quot;);
}
}

class D implements Interface1 { public void operation1() {
System.out.println(&amp;quot;D 实现了 operation1&amp;quot;);
}
public void operation2() {
System.out.println(&amp;quot;D 实现了 operation2&amp;quot;);
}
public void operation3() {
System.out.println(&amp;quot;D 实现了 operation3&amp;quot;);
}
public void operation4() {
System.out.println(&amp;quot;D 实现了  operation4&amp;quot;);
}
public void  operation5()  { System.out.println(&amp;quot;D 实现了  operation5&amp;quot;);
}
}

class A { //A 类通过接口 Interface1 依赖(使用) B 类，但是只会用到 1,2,3 方法
public void depend1(Interface1 i) { i.operation1();
}
public void depend2(Interface1 i) { i.operation2();
}
public void depend3(Interface1 i) { i.operation3();
}
}

class C { //C 类通过接口 Interface1  依赖(使用) D 类，但是只会用到 1,4,5 方法
public void depend1(Interface1 i) { i.operation1();
}
public void depend4(Interface1 i) { i.operation4();
}
public void depend5(Interface1 i) { i.operation5();
}
}

&lt;/code&gt;&lt;/pre&gt;
">设计模式的学习</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://https://chenm0.github.io/post/postgresql-jiansuo/"" data-c="
          &lt;h3 id=&#34;相关文档&#34;&gt;相关文档&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;文本搜索的函数与操作符中文说明: 
http://www.postgres.cn/docs/9.3.4/functions-textsearch.html
PostgreSQL 文本搜索文档 : 
https://www.postgresql.org/docs/9.4/textsearch-controls.html
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;核心函数-关键字&#34;&gt;核心函数、关键字&lt;/h3&gt;
&lt;p&gt;全文搜索的思想主要分两步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;将文本解析为对应的倒排索引&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;搜索索引来找到对应的文本&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要使用 PostgreSQL 的全文搜索, 那么就要了解到底是要用什么关键字和函数来&lt;strong&gt;构建索引&lt;/strong&gt;和&lt;strong&gt;搜索&lt;/strong&gt;， 这里主要涉及到&lt;strong&gt;一个关键字&lt;/strong&gt;和&lt;strong&gt;四个函数&lt;/strong&gt;&lt;br&gt;
可以看上边的文档了解函数的具体参数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键字 tsvector:&lt;/strong&gt;&lt;br&gt;
tsvector 是 PostgreSQL 内置的一种字段类型, 用来保存的是分词后的结果 (文本向量) 它是由 [词，序列， 权重] 三个东西共同组成的， 权重可能会没有&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;to_tsvector()&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分词用, 将文本转为向量。 用它可以将字符串转成上边说的 tsvector , 遗憾的是默认不支持中文分词&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;to_tsquery()&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构建搜索的关键字， 支持各种符号表示条件。 详情查看文档&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;setweight()&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置关键词权重， 总共四个权重从高到低为 A-B-C-D&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ts_rank ()&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;排序用， 可以根据 to_tsquery 和 tsvector 的匹配度计算&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;//查询表中包含 aaa 并且包含 BBB或CCC任意一个 的记录
  SELECT * FROM table
  WHERE to_tsvector(&#39;parser_name&#39;, field) @@ to_tsquery(&#39;aaa &amp;amp; (bbb | ccc)&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;索引:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;建立联合索引&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create index document_title_idx on encms.article using gin (to_tsvector(&#39;english&#39;,&amp;quot;content&amp;quot; || &amp;quot;title&amp;quot;) tsvector_ops)
&lt;/code&gt;&lt;/pre&gt;
">PostgreSQL自带全文检索</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://https://chenm0.github.io/post/doge/"" data-c="
          &lt;pre&gt;&lt;code&gt;    ​
 4月20日，狗狗币纪念日。美国知名财经媒体在首页刊登了狗狗币相关报道，标题为《狗狗币交易赶上线上狂潮》，其中提到狗狗币在2021年的回报率超过8100%，是1998年以来标普500涨幅的2倍多，狗狗币市值大约为500亿美元，超过了万豪国际和福特汽车。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;狗狗币2021年1月1日开盘报0.004619美元/枚，2021年4月16日最高报价已触及0.47美元/枚，日内暴涨200%，年内价格暴涨超100倍，仅耗时106天。自2020年3月12日最低价0.001158美元以来，最高涨幅超过了400倍。&lt;br&gt;
　　有观点认为，狗狗币的崛起反映了集体信念的力量以及对更理想形式的加密货币的渴望，预示着去中心化必将大兴其道。但狗狗币大涨400倍的背后，其实是名人的带动、散户的狂欢，以及韭菜的博傻心理，狗狗币的泡沫终将破灭。&lt;/p&gt;
&lt;h3 id=&#34;doge的前世今生&#34;&gt;Doge的前世今生&lt;/h3&gt;
&lt;p&gt;​		狗狗币是币圈一个独特的存在。2013年12月，美国IBM软件工程师Billy Markus和澳大利亚Adobe工程师Jackson Palmer共同在比特币代码基础上创造了Dogecoin。&lt;/p&gt;
&lt;p&gt;极具讽刺的是，两位工程师当年推出狗狗币的目的却是为了“嘲笑”比特币。2013年，比特币价格极速上涨，从以前的一文不值迅速飙升到了几十美元。&lt;/p&gt;
&lt;p&gt;如果说比特币是对传统金融体系的反叛，Dogecoin就是对比特币的反叛，它消解了比特币的一个主要特点——总量固定，不可超发。在Palmer和Marcus对比特币规则的修改下，Dogecoin第一年的发行量就有1000亿个，之后几乎每年都增发5%。目前，Dogecoin总量已经接近1300亿枚，是比特币的6000倍。&lt;/p&gt;
&lt;p&gt;为了加大嘲讽，Palmer还顺手买了Dogecion.com以对标比特币的bitcoin.com的官网。Markus则给自己的推特取名为shibetoshi Nakaoto，用来讽刺比特币创始人中本聪（Satoshi Nakamoto）。&lt;/p&gt;
&lt;p&gt;在今年2月CNET刊发的一篇采访中，Palmer笑道：“我们认为这是注定消亡的一个大玩笑。”&lt;/p&gt;
&lt;p&gt;早在2019年4月，Palmer就清空了自己在Twitter账户上发布的内容，以及YouTube上的视频，消失在网络世界。而狗狗币的市值在诞生后的七年里一直排在200名之后。&lt;/p&gt;
&lt;p&gt;进入2021年，狗狗币突然火了，而且是大火特火。数据统计回溯狗狗币价格发现，狗狗币2021年1月1日开盘报0.004619美元/枚，2021年4月16日最高报价已触及0.47美元/枚，日内暴涨200%，年内价格暴涨超100倍，仅耗时106天。自2020年3月12日最低价0.001158美元以来，最高涨幅超过了400倍。&lt;/p&gt;
&lt;h3 id=&#34;散户和马斯克&#34;&gt;散户和马斯克&lt;/h3&gt;
&lt;p&gt;​		目前看来，狗狗币的此次“出圈”有两大主要推手：一是社交媒体平台Reddit旗下WSB社区聚集的美国散户；二是特斯拉创始人埃隆马斯克。&lt;/p&gt;
&lt;p&gt;今天1月，美股上演史上最大的“散户VS机构”大战，即GME（GameStop）保卫战。&lt;/p&gt;
&lt;p&gt;WallStreetBets（简称WSB）散户集体把18美元的游戏零售商股票GME硬是推到了483美元，爆了华尔街一堆做空机构的大量仓位，在全球金融市场掀起轩然大波。&lt;/p&gt;
&lt;p&gt;不久之后，WSB对股票市场的狂热蔓延至狗狗币。1月28日，推特用户“WSBChairman”问其75万关注者，“狗狗币曾经达到过1美元吗”，Reddit用户纷纷响应，呼吁大家要像买GME股票一样买Dogecoin，持币不售，目标是“1 Dogecoin=1美元”。随后，狗狗币出现了一个巨大的价格反弹，从0.01美元的低位升至0.087美元的峰值。&lt;/p&gt;
&lt;p&gt;​		狗狗币价格狂涨，特斯拉CEO马斯克的“带货”同样功不可没。今年2月4日，马斯克突然发推“Doge”，狗狗币涨幅迅速攀升50%。随后他又连续发布多条与狗狗币有关的推文：“我们不需要成为亿万富翁就能拥有狗狗币，狗狗币才是人民的数字货币。”“我没喝多，也没情绪低落，心里只有狗狗币。”“狗狗币是世界上最有趣的加密货币。”&lt;/p&gt;
&lt;p&gt;​		马斯克站台狗狗币，最早可以追溯至2019年4月，狗狗币官方账户在Twitter发起评选狗狗币CEO的投票，马斯克高票当选。随后，马斯克发推文称，狗狗币是他最喜欢的数字货币，并将自己的Twitter账户信息修改为“狗狗币前CEO”。&lt;/p&gt;
&lt;p&gt;4月初，马斯克在推特上表示将使用SpaceX把一枚狗狗币带到月球上。消息一出，狗狗币直线拉升，当天大涨15%。&lt;/p&gt;
&lt;p&gt;两个星期后，美国最大加密货币交易所Coinbase在纳斯达克交易所直接挂牌上市，成为美国加密货币平台第一股。Coinbase的成功上市带动密货币集体上涨，其中，狗狗币大涨近30%。&lt;/p&gt;
&lt;p&gt;​		次日，马斯克发布推文，狗狗币朝着月亮吠叫，并附上了相关图片，狗狗币立马飙升，当日大涨50%。4月16日，狗狗币持续暴涨，24小时内涨幅一度达250%，最高触及0.47美元/枚，总市值一度突破600亿美元。&lt;/p&gt;
&lt;p&gt;猛烈涨势之下，越来越多商家表示接受或考虑接受狗狗币支付。NBA球队达拉斯独行侠队从3月4日起开始接受狗狗币付款，球迷可以使用狗狗币购买比赛门票和球队商品。3月7日，该球队老板Mark Cuban发推文称：“达拉斯小牛队已经完成了超过20000个的狗狗币交易，使我们成为世界上最大的狗狗币商家。”4月15日，Mark Cuban再度发推文表示，小牛队将在资产负债表上永久持有狗狗币。目前，使用狗狗币购买球队商品的销售额已超12.2万枚。&lt;/p&gt;
&lt;p&gt;​		可以看出的是，狗狗币在美国的社区基础相当牢固。其利用自己超过400倍的涨幅迅速出圈之后，继续获得更多商家支持。&lt;/p&gt;
&lt;p&gt;3月30日，美联国际教育集团（METX.US）宣布，公司已启动区块链技术战略计划，并将在平台上为外籍教师引入狗狗币奖励机制。学生可以根据教师的教学表现奖励他们，教师也可以通过执行在公司平台上发布的教学和研究任务来获得狗狗币。此外，学生还可以通过完成学业和在平台上分享知识来获得狗狗币。&lt;/p&gt;
&lt;p&gt;​		4月19日，士力架巧克力棒的官方推特账号发布了带有#doge day标签的推文，其中包含以狗狗币为主题的包装图。士力架公司还准备为狗狗币投资人推出限量版士力架巧克力棒，并称这只是一个“很酷的GIF图”。&lt;/p&gt;
&lt;p&gt;4月20日，狗狗币迎来了自己的纪念日，利好消息不断。当日，知名在线零售商Newegg宣布，将接受狗狗币作为官方支付方式。Newegg高级品牌经理安德鲁·崔（Andrew Choi）表示：“我们致力于简化客户的购物流程，力求为他们提供最适合他们的购物方式，让他们可以选择最适合他们的付款方式来完成交易。为此，我们很高兴为持有狗狗币的粉丝提供方便的在线购买方式。”&lt;/p&gt;
&lt;p&gt;​		美可味巧克力（Milky Way）则在推特上发布一条狗狗币与巧克力棒亲密接触消息，并把加密行业里常说的“To the Moon”改为了“To the Milky Way”。此外，超过13万人签署了Change.org上的一份请愿书，呼吁亚马逊接受狗狗币作为付款方式。&lt;/p&gt;
&lt;p&gt;当天，美国饶舌巨星Snoop Dogg与Shiba-Inu（原始Doge表情中的那只狗）在YouTube上发布了一个名为“Snoop Dogg 420 DogeCoin Video”的音乐视频。这位歌手还在推特上艾特了马斯克这位狗狗币的最大推手，祝贺他参加4月20日“Doge Day”。&lt;/p&gt;
&lt;h3 id=&#34;泡沫终将破灭&#34;&gt;泡沫终将破灭&lt;/h3&gt;
&lt;p&gt;​		公开数据显示，今年以来，狗狗币的累计涨幅达到了7000%。4月21日，Coin Metrics联合创始人Nic Carter发推文称，在过去一周，有8.72亿枚5年多未移动的狗狗币（相当于2.87亿美元）重新进入流通。&lt;/p&gt;
&lt;p&gt;这种数据表明，大户开始高位抛售，割韭菜的故事开始上演。自创历史新高的0.47美金之后，狗狗币价格一路下跌，4月26日约为0.27美金，较历史新高的跌幅高达42.6%。&lt;/p&gt;
&lt;p&gt;狗狗币的大起大落引起了多位加密货币行业资深人士的质疑，认为它的泡沫实在太大，过多的被吹捧。他们告诫投资人，不该孤注一掷地押注于狗狗币，担心少数大型持有者控制了狗狗币的大部分供应。&lt;/p&gt;
&lt;p&gt;实际上，狗狗币的筹码十分集中，近70%的狗狗币分布在世界各地约100个钱包中，其中最大的一个钱包控制了30%左右的狗狗币。&lt;/p&gt;
&lt;p&gt;英国投资应用Freetrade的分析师David Kimberley认为，狗狗币的崛起是证明经济学博傻理论的一个经典例子。人们买狗狗币，不是因为他们认为狗狗币有任何意义或价值，而是因为他们希望其他人会涌入，推高价格，然后他们可以趁机卖出，迅速赚一笔钱。“当每个人都这么做的时候，泡沫最终会破裂，如果你不及时退出，就会被亏本。”&lt;/p&gt;
&lt;p&gt;“由于马斯克的努力带货和鲸鱼对市场的操纵，狗狗币的价格已经变得非常高，这是一个泡沫。狗狗币的上涨是不可持续的，它将崩溃，大量散户资金将很快损失。”Cardano创始人Charles Hoskinson认为，在泡沫破裂后，狗狗币将成为监管者和立法者介入加密行业的催化剂，这不是一件好事。“狗狗币没有稳定的开发团队，也没有独创的技术。在必然来临的泡沫破裂之后，国会将展开调查，美国SEC将四处奔走，各种各样的监管机构会到处说：这证明加密货币无法控制自己，我们需要进来救你。”&lt;/p&gt;
&lt;p&gt;根据coinmarketcap网站数据，目前全球仍有2109种数字货币在交易所交易，其中相当多的数字货币属于某一个企业所“研发”，它们背后拥有大股东的权力，违背了区块链的“去中心化”理念。&lt;/p&gt;
&lt;p&gt;Real Vision创始人兼首席执行官Raoul Pal日前透露了自己持有的加密资产组合，“我现在的资产50%是比特币，30%是以太坊，20%是其他代币，我试图在整个加密领域中保持平衡，因为我真的不知道在这个领域中什么币会赢，什么币不会赢。”关于最近大热的狗狗币，Pal表示：“它会永远持续下去吗？谁知道呢？但是我买了一些狗狗币，因为人群在涌入。”&lt;/p&gt;
&lt;p&gt;原标题：全面复盘：狗狗币是如何上涨400倍的？ 来源：链新&lt;/p&gt;
">全面复盘：狗狗币是如何上涨400倍的？ </a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://https://chenm0.github.io/post/java8-optional/"" data-c="
          &lt;p&gt;​		从 Java 8 引入的一个很有趣的特性是 &lt;em&gt;Optional&lt;/em&gt;  类。Optional 类主要解决的问题是臭名昭著的空指针异常（NullPointerException） —— 每个 Java 程序员都非常了解的异常。&lt;/p&gt;
&lt;p&gt;​		本质上，这是一个包含有可选值的包装类，这意味着 Optional 类既可以含有对象也可以为空。Optional 是 Java 实现函数式编程的强劲一步，并且帮助在范式中实现。但是 Optional 的意义显然不止于此。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (user != null) {
    Address address = user.getAddress();
    if (address != null) {
        Country country = address.getCountry();
        if (country != null) {
            String isocode = country.getIsocode();
            if (isocode != null) {
                isocode = isocode.toUpperCase();
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		你看到了，这很容易就变得冗长，难以维护。&lt;/p&gt;
&lt;p&gt;​		为了简化这个过程，我们来看看用 &lt;em&gt;Optional&lt;/em&gt; 类是怎么做的。从创建和验证实例，到使用其不同的方法，并与其它返回相同类型的方法相结合，下面是见证 &lt;em&gt;Optional&lt;/em&gt;  奇迹的时刻。&lt;/p&gt;
&lt;h3 id=&#34;创建-optional-实例&#34;&gt;创建 &lt;em&gt;Optional&lt;/em&gt; 实例&lt;/h3&gt;
&lt;p&gt;​		重申一下，这个类型的对象可能包含值，也可能为空。你可以使用同名方法创建一个空的 Optional.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test(expected = NoSuchElementException.class)
public void whenCreateEmptyOptional_thenNull() {
    Optional&amp;lt;User&amp;gt; emptyOpt = Optional.empty();
    emptyOpt.get();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		毫不奇怪，尝试访问 &lt;em&gt;emptyOpt&lt;/em&gt; 变量的值会导致 &lt;em&gt;NoSuchElementException&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;​		你可以使用 &lt;em&gt;of()&lt;/em&gt; 和 ofNullable() 方法创建包含值的 &lt;em&gt;Optional&lt;/em&gt;。两个方法的不同之处在于如果你把 &lt;em&gt;null&lt;/em&gt; 值作为参数传递进去，&lt;em&gt;of()&lt;/em&gt; 方法会抛出 &lt;em&gt;NullPointerException&lt;/em&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test(expected = NullPointerException.class)
public void whenCreateOfEmptyOptional_thenNullPointerException() {
    Optional&amp;lt;User&amp;gt; opt = Optional.of(user);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		你看，我们并没有完全摆脱 &lt;em&gt;NullPointerException&lt;/em&gt;。因此，你应该明确对象不为 &lt;em&gt;null&lt;/em&gt; 的时候使用 &lt;em&gt;of()&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;如果对象即可能是 &lt;em&gt;null&lt;/em&gt; 也可能是非 null，你就应该使用 &lt;em&gt;ofNullable()&lt;/em&gt; 方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Optional&amp;lt;User&amp;gt; opt = Optional.ofNullable(user);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;访问-optional-对象的值&#34;&gt;访问 &lt;em&gt;Optional&lt;/em&gt; 对象的值&lt;/h3&gt;
&lt;p&gt;​		从 &lt;em&gt;Optional&lt;/em&gt; 实例中取回实际值对象的方法之一是使用 &lt;em&gt;get()&lt;/em&gt; 方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void whenCreateOfNullableOptional_thenOk() {
    String name = &amp;quot;John&amp;quot;;
    Optional&amp;lt;String&amp;gt; opt = Optional.ofNullable(name);
    assertEquals(&amp;quot;John&amp;quot;, opt.get());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		不过，你看到了，这个方法会在值为 &lt;em&gt;null&lt;/em&gt; 的时候抛出异常。要避免异常，你可以选择首先验证是否有值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void whenCheckIfPresent_thenOk() {
    User user = new User(&amp;quot;john@gmail.com&amp;quot;, &amp;quot;1234&amp;quot;);
    Optional&amp;lt;User&amp;gt; opt = Optional.ofNullable(user);
    assertTrue(opt.isPresent());
    assertEquals(user.getEmail(), opt.get().getEmail());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		检查是否有值的另一个选择是 &lt;em&gt;ifPresent()&lt;/em&gt; 方法。该方法除了执行检查，还接受一个&lt;em&gt;Consumer(消费者&lt;/em&gt;) 参数，如果对象不是空的，就对执行传入的 Lambda 表达式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;opt.ifPresent( u -&amp;gt; assertEquals(user.getEmail(), u.getEmail()));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		这个例子中，只有 user 用户不为 null 的时候才会执行断言。&lt;/p&gt;
&lt;p&gt;​		接下来，我们来看看提供空值的方法。&lt;/p&gt;
&lt;h3 id=&#34;返回默认值&#34;&gt;返回默认值&lt;/h3&gt;
&lt;p&gt;​		&lt;em&gt;Optional&lt;/em&gt; 类提供了 API 用以返回对象值，或者在对象为空的时候返回默认值。&lt;/p&gt;
&lt;p&gt;​		这里你可以使用的第一个方法是 &lt;em&gt;orElse()&lt;/em&gt;，它的工作方式非常直接，如果有值则返回该值，否则返回传递给它的参数值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void whenEmptyValue_thenReturnDefault() {
    User user = null;
    User user2 = new User(&amp;quot;anna@gmail.com&amp;quot;, &amp;quot;1234&amp;quot;);
    User result = Optional.ofNullable(user).orElse(user2);

    assertEquals(user2.getEmail(), result.getEmail());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		这里 &lt;em&gt;user&lt;/em&gt; 对象是空的，所以返回了作为默认值的 &lt;em&gt;user2&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;​		如果对象的初始值不是 null，那么默认值会被忽略：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void whenValueNotNull_thenIgnoreDefault() {
    User user = new User(&amp;quot;john@gmail.com&amp;quot;,&amp;quot;1234&amp;quot;);
    User user2 = new User(&amp;quot;anna@gmail.com&amp;quot;, &amp;quot;1234&amp;quot;);
    User result = Optional.ofNullable(user).orElse(user2);

    assertEquals(&amp;quot;john@gmail.com&amp;quot;, result.getEmail());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		第二个同类型的 API 是 &lt;em&gt;orElseGet()&lt;/em&gt; —— 其行为略有不同。这个方法会在有值的时候返回值，如果没有值，它会执行作为参数传入的 &lt;em&gt;Supplier(供应者)&lt;/em&gt; 函数式接口，并将返回其执行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;User result = Optional.ofNullable(user).orElseGet( () -&amp;gt; user2);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		&lt;em&gt;orElse()&lt;/em&gt; 和 &lt;em&gt;orElseGet()&lt;/em&gt; 的不同之处&lt;/p&gt;
&lt;p&gt;​		乍一看，这两种方法似乎起着同样的作用。然而事实并非如此。我们创建一些示例来突出二者行为上的异同。&lt;/p&gt;
&lt;p&gt;我们先来看看对象为空时他们的行为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void givenEmptyValue_whenCompare_thenOk() {
    User user = null
    logger.debug(&amp;quot;Using orElse&amp;quot;);
    User result = Optional.ofNullable(user).orElse(createNewUser());
    logger.debug(&amp;quot;Using orElseGet&amp;quot;);
    User result2 = Optional.ofNullable(user).orElseGet(() -&amp;gt; createNewUser());
}

private User createNewUser() {
    logger.debug(&amp;quot;Creating New User&amp;quot;);
    return new User(&amp;quot;extra@gmail.com&amp;quot;, &amp;quot;1234&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		上面的代码中，两种方法都调用了 &lt;em&gt;createNewUser()&lt;/em&gt; 方法，这个方法会记录一个消息并返回 &lt;em&gt;User&lt;/em&gt; 对象。&lt;/p&gt;
&lt;p&gt;代码输出如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Using orElse
Creating New User
Using orElseGet
Creating New User
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		由此可见，当对象为空而返回默认对象时，行为并无差异。&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;​		我们接下来看一个类似的示例，但这里 &lt;em&gt;Optional&lt;/em&gt;  不为空：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void givenPresentValue_whenCompare_thenOk() {
    User user = new User(&amp;quot;john@gmail.com&amp;quot;, &amp;quot;1234&amp;quot;);
    logger.info(&amp;quot;Using orElse&amp;quot;);
    User result = Optional.ofNullable(user).orElse(createNewUser());
    logger.info(&amp;quot;Using orElseGet&amp;quot;);
    User result2 = Optional.ofNullable(user).orElseGet(() -&amp;gt; createNewUser());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		这次的输出：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Using orElse
Creating New User
Using orElseGet
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		这个示例中，两个 &lt;em&gt;Optional&lt;/em&gt;  对象都包含非空值，两个方法都会返回对应的非空值。不过，&lt;em&gt;orElse()&lt;/em&gt; 方法仍然创建了 &lt;em&gt;User&lt;/em&gt; 对象。与之相反，&lt;em&gt;orElseGet()&lt;/em&gt; 方法不创建 &lt;em&gt;User&lt;/em&gt; 对象。&lt;/p&gt;
&lt;p&gt;​		在执行较密集的调用时，比如调用 Web 服务或数据查询，这个差异会对性能产生重大影响。&lt;/p&gt;
&lt;h3 id=&#34;返回异常&#34;&gt;返回异常&lt;/h3&gt;
&lt;p&gt;​		除了 &lt;em&gt;orElse()&lt;/em&gt; 和 &lt;em&gt;orElseGet()&lt;/em&gt; 方法，Optional 还定义了 &lt;em&gt;orElseThrow()&lt;/em&gt; API —— 它会在对象为空的时候抛出异常，而不是返回备选的值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test(expected = IllegalArgumentException.class)
public void whenThrowException_thenOk() {
    User result = Optional.ofNullable(user)
      .orElseThrow( () -&amp;gt; new IllegalArgumentException());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		这里，如果 &lt;em&gt;user&lt;/em&gt; 值为 null，会抛出 &lt;em&gt;IllegalArgumentException&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;​		这个方法让我们有更丰富的语义，可以决定抛出什么样的异常，而不总是抛出 &lt;em&gt;NullPointerException&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;​		现在我们已经很好地理解了如何使用 Optional，我们来看看其它可以对 &lt;em&gt;Optional&lt;/em&gt; 值进行转换和过滤的方法。&lt;/p&gt;
&lt;h3 id=&#34;转换值&#34;&gt;转换值&lt;/h3&gt;
&lt;p&gt;​		有很多种方法可以转换 &lt;em&gt;Optional&lt;/em&gt; 的值。我们从 &lt;em&gt;map()&lt;/em&gt; 和 &lt;em&gt;flatMap()&lt;/em&gt; 方法开始。&lt;/p&gt;
&lt;p&gt;先来看一个使用 &lt;em&gt;map()&lt;/em&gt; API 的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void whenMap_thenOk() {
    User user = new User(&amp;quot;anna@gmail.com&amp;quot;, &amp;quot;1234&amp;quot;);
    String email = Optional.ofNullable(user)
      .map(u -&amp;gt; u.getEmail()).orElse(&amp;quot;default@gmail.com&amp;quot;);

    assertEquals(email, user.getEmail());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		&lt;em&gt;map()&lt;/em&gt; 对值应用(调用)作为参数的&lt;em&gt;函数&lt;/em&gt;，然后将返回的值包装在 &lt;em&gt;Optional&lt;/em&gt; 中。这就使对返回值进行链试调用的操作成为可能 —— 这里的下一环就是 &lt;em&gt;orElse()&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;​		相比这下，&lt;em&gt;flatMap()&lt;/em&gt; 也需要&lt;em&gt;函数&lt;/em&gt;作为参数，并对值调用这个函数，然后直接返回结果。&lt;/p&gt;
&lt;p&gt;​		下面的操作中，我们给 &lt;em&gt;User&lt;/em&gt; 类添加了一个方法，用来返回 &lt;em&gt;Optional&lt;/em&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class User {    
    private String position;

    public Optional&amp;lt;String&amp;gt; getPosition() {
        return Optional.ofNullable(position);
    }

    //...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		既然 getter 方法返回 String 值的 &lt;em&gt;Optional&lt;/em&gt;，你可以在对 &lt;em&gt;User&lt;/em&gt; &lt;em&gt;的 Optional&lt;/em&gt; 对象调用 &lt;em&gt;flatMap()&lt;/em&gt; 时，用它作为参数。其返回的值是解除包装的 String 值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void whenFlatMap_thenOk() {
    User user = new User(&amp;quot;anna@gmail.com&amp;quot;, &amp;quot;1234&amp;quot;);
    user.setPosition(&amp;quot;Developer&amp;quot;);
    String position = Optional.ofNullable(user)
      .flatMap(u -&amp;gt; u.getPosition()).orElse(&amp;quot;default&amp;quot;);

    assertEquals(position, user.getPosition().get());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		过滤值&lt;/p&gt;
&lt;p&gt;​		除了转换值之外，&lt;em&gt;Optional&lt;/em&gt; 类也提供了按条件“过滤”值的方法。&lt;em&gt;filter()&lt;/em&gt; 接受一个 &lt;em&gt;Predicate&lt;/em&gt; 参数，返回测试结果为 true 的值。如果测试结果为 false，会返回一个空的 &lt;em&gt;Optional&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;来看一个根据基本的电子邮箱验证来决定接受或拒绝 &lt;em&gt;User&lt;/em&gt;*(用户)* 的示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void whenFilter_thenOk() {
    User user = new User(&amp;quot;anna@gmail.com&amp;quot;, &amp;quot;1234&amp;quot;);
    Optional&amp;lt;User&amp;gt; result = Optional.ofNullable(user)
      .filter(u -&amp;gt; u.getEmail() != null &amp;amp;&amp;amp; u.getEmail().contains(&amp;quot;@&amp;quot;));

    assertTrue(result.isPresent());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		如果通过过滤器测试，&lt;em&gt;result&lt;/em&gt; 对象会包含非空值。&lt;/p&gt;
&lt;h3 id=&#34;optional-类的链式方法&#34;&gt;&lt;em&gt;Optional&lt;/em&gt; 类的链式方法&lt;/h3&gt;
&lt;p&gt;​		为了更充分的使用 &lt;em&gt;Optional&lt;/em&gt;，你可以链接组合其大部分方法，因为它们都返回相同类似的对象。&lt;/p&gt;
&lt;p&gt;​		我们使用 &lt;em&gt;Optional&lt;/em&gt; 重写最早介绍的示例。&lt;/p&gt;
&lt;p&gt;​		首先，重构类，使其 getter 方法返回 &lt;em&gt;Optional&lt;/em&gt; 引用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class User {
    private Address address;

    public Optional&amp;lt;Address&amp;gt; getAddress() {
        return Optional.ofNullable(address);
    }

    // ...
}
public class Address {
    private Country country;

    public Optional&amp;lt;Country&amp;gt; getCountry() {
        return Optional.ofNullable(country);
    }

    // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		现在可以删除 &lt;em&gt;null&lt;/em&gt; 检查，替换为 &lt;em&gt;Optional&lt;/em&gt; 的方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void whenChaining_thenOk() {
    User user = new User(&amp;quot;anna@gmail.com&amp;quot;, &amp;quot;1234&amp;quot;);

    String result = Optional.ofNullable(user)
      .flatMap(u -&amp;gt; u.getAddress())
      .flatMap(a -&amp;gt; a.getCountry())
      .map(c -&amp;gt; c.getIsocode())
      .orElse(&amp;quot;default&amp;quot;);

    assertEquals(result, &amp;quot;default&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		上面的代码可以通过方法引用进一步缩减：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String result = Optional.ofNullable(user)
  .flatMap(User::getAddress)
  .flatMap(Address::getCountry)
  .map(Country::getIsocode)
  .orElse(&amp;quot;default&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果现在的代码看起来比之前采用条件分支的冗长代码简洁多了。&lt;/p&gt;
&lt;h3 id=&#34;java-9-增强&#34;&gt;Java 9 增强&lt;/h3&gt;
&lt;p&gt;​		我们介绍了 Java 8 的特性，Java 9 为 Optional 类添加了三个方法：&lt;em&gt;or()&lt;/em&gt;、&lt;em&gt;ifPresentOrElse()&lt;/em&gt; 和 &lt;em&gt;stream()&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;​		&lt;em&gt;or()&lt;/em&gt; 方法与 &lt;em&gt;orElse()&lt;/em&gt; 和 &lt;em&gt;orElseGet()&lt;/em&gt; 类似，它们都在对象为空的时候提供了替代情况。&lt;em&gt;or()&lt;/em&gt; 的返回值是由 &lt;em&gt;Supplier&lt;/em&gt; 参数产生的另一个 &lt;em&gt;Optional&lt;/em&gt; 对象。&lt;/p&gt;
&lt;p&gt;​		如果对象包含值，则 Lambda 表达式不会执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void whenEmptyOptional_thenGetValueFromOr() {
    User result = Optional.ofNullable(user)
      .or( () -&amp;gt; Optional.of(new User(&amp;quot;default&amp;quot;,&amp;quot;1234&amp;quot;))).get();

    assertEquals(result.getEmail(), &amp;quot;default&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		上面的示例中，如果 &lt;em&gt;user&lt;/em&gt; 变量是 null，它会返回一个 &lt;em&gt;Optional&lt;/em&gt;，它所包含的 &lt;em&gt;User&lt;/em&gt; 对象，其电子邮件为 “default”。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;ifPresentOrElse()&lt;/em&gt; 方法需要两个参数：一个 &lt;em&gt;Consumer&lt;/em&gt; 和一个 &lt;em&gt;Runnable&lt;/em&gt;。如果对象包含值，会执行 &lt;em&gt;Consumer&lt;/em&gt; 的动作，否则运行 &lt;em&gt;Runnable&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;​		如果你想在有值的时候执行某个动作，或者只是跟踪是否定义了某个值，那么这个方法非常有用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Optional.ofNullable(user).ifPresentOrElse( u -&amp;gt; logger.info(&amp;quot;User is:&amp;quot; + u.getEmail()),
  () -&amp;gt; logger.info(&amp;quot;User not found&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		最后介绍的是新的 &lt;em&gt;stream()&lt;/em&gt; 方法，它通过把实例转换为 &lt;em&gt;Stream&lt;/em&gt; 对象，让你从广大的 &lt;em&gt;Stream&lt;/em&gt; API 中受益。如果没有值，它会得到空的 &lt;em&gt;Stream&lt;/em&gt;；有值的情况下，&lt;em&gt;Stream&lt;/em&gt; 则会包含单一值。&lt;/p&gt;
&lt;p&gt;​		我们来看一个把 &lt;em&gt;Optional&lt;/em&gt; 处理成 &lt;em&gt;Stream&lt;/em&gt; 的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void whenGetStream_thenOk() {
    User user = new User(&amp;quot;john@gmail.com&amp;quot;, &amp;quot;1234&amp;quot;);
    List&amp;lt;String&amp;gt; emails = Optional.ofNullable(user)
      .stream()
      .filter(u -&amp;gt; u.getEmail() != null &amp;amp;&amp;amp; u.getEmail().contains(&amp;quot;@&amp;quot;))
      .map( u -&amp;gt; u.getEmail())
      .collect(Collectors.toList());

    assertTrue(emails.size() == 1);
    assertEquals(emails.get(0), user.getEmail());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		这里对 &lt;em&gt;Stream&lt;/em&gt; 的使用带来了其 &lt;em&gt;filter()、map()&lt;/em&gt; 和 &lt;em&gt;collect()&lt;/em&gt; 接口，以获取 &lt;em&gt;List&lt;/em&gt;。&lt;/p&gt;
&lt;h3 id=&#34;optional-应该怎样用&#34;&gt;&lt;em&gt;Optional&lt;/em&gt; 应该怎样用？&lt;/h3&gt;
&lt;p&gt;​		在使用 &lt;em&gt;Optional&lt;/em&gt; 的时候需要考虑一些事情，以决定什么时候怎样使用它。&lt;/p&gt;
&lt;p&gt;​		重要的一点是 &lt;em&gt;Optional&lt;/em&gt; 不是 &lt;em&gt;Serializable&lt;/em&gt;。因此，它不应该用作类的字段。&lt;/p&gt;
&lt;p&gt;​		如果你需要序列化的对象包含 &lt;em&gt;Optional&lt;/em&gt; 值，&lt;a href=&#34;https://stackify.com/java-xml-jackson/&#34;&gt;&lt;em&gt;Jackson&lt;/em&gt; 库&lt;/a&gt;支持把 &lt;em&gt;Optional&lt;/em&gt; 当作普通对象。也就是说，&lt;em&gt;Jackson&lt;/em&gt; 会把空对象看作 &lt;em&gt;null&lt;/em&gt;，而有值的对象则把其值看作对应域的值。这个功能在 &lt;a href=&#34;https://github.com/FasterXML/jackson-modules-java8&#34;&gt;jackson-modules-java8&lt;/a&gt; 项目中。&lt;/p&gt;
&lt;p&gt;​		它在另一种情况下也并不怎么有用，就是在将其类型用作方法或构建方法的参数时。这样做会让代码变得复杂，完全没有必要：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;User user = new User(&amp;quot;john@gmail.com&amp;quot;, &amp;quot;1234&amp;quot;, Optional.empty());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		使用重载方法来处理非要的参数要容易得多。&lt;/p&gt;
&lt;p&gt;​		&lt;em&gt;Optional&lt;/em&gt; 主要用作返回类型。在获取到这个类型的实例后，如果它有值，你可以取得这个值，否则可以进行一些替代行为。&lt;/p&gt;
&lt;p&gt;​		&lt;em&gt;Optional&lt;/em&gt; 类有一个非常有用的用例，就是将其与流或其它返回 &lt;em&gt;Optional&lt;/em&gt; 的方法结合，以构建流畅的API。&lt;/p&gt;
&lt;p&gt;​		我们来看一个示例，使用 &lt;em&gt;Stream&lt;/em&gt; 返回 &lt;em&gt;Optional&lt;/em&gt; 对象的 &lt;em&gt;findFirst()&lt;/em&gt; 方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Test
public void whenEmptyStream_thenReturnDefaultOptional() {
    List&amp;lt;User&amp;gt; users = new ArrayList&amp;lt;&amp;gt;();
    User user = users.stream().findFirst().orElse(new User(&amp;quot;default&amp;quot;, &amp;quot;1234&amp;quot;));

    assertEquals(user.getEmail(), &amp;quot;default&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;Optional&lt;/em&gt; 是 Java 语言的有益补充 —— 它旨在减少代码中的 &lt;em&gt;NullPointerExceptions&lt;/em&gt;，虽然还不能完全消除这些异常。&lt;/p&gt;
&lt;p&gt;它也是精心设计，自然融入 Java 8 函数式支持的功能。&lt;/p&gt;
&lt;p&gt;总的来说，这个简单而强大的类有助于创建简单、可读性更强、比对应程序错误更少的程序。&lt;/p&gt;
&lt;p&gt;转自 https://www.cnblogs.com/zhangboyu/p/7580262.html&lt;/p&gt;
">理解、学习与使用 JAVA 中的 OPTIONAL</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://https://chenm0.github.io/post/spring-data-rest/"" data-c="
          &lt;h3 id=&#34;什么是spring-data-rest&#34;&gt;什么是Spring Data REST&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;​		Spring Data REST是基于Spring Data的repository之上，可以把 repository 自动输出为REST资源，目前支持Spring Data JPA、Spring Data &lt;a href=&#34;https://cloud.tencent.com/product/mongodb?from=10680&#34;&gt;MongoDB&lt;/a&gt;、Spring Data Neo4j、Spring Data GemFire、Spring Data Cassandra的 repository 自动转换成REST服务。注意是自动。简单点说，Spring Data REST把我们需要编写的大量REST模版接口做了自动化实现.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;restful-api&#34;&gt;restful api&lt;/h3&gt;
&lt;p&gt;​		REST是一种设计风格(与具体的语言无关)，它的URL主体是资源，是个名词。而且也仅支持HTTP协议，规定了使用HTTP Method表达本次要做的动作，类型一般也不超过那四五种。这些动作表达了对资源仅有的几种转化方式。&lt;/p&gt;
&lt;p&gt;​		常用的HTTP动词有下面五个（括号里是对应的SQL命令）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GET（SELECT）：从服务器取出资源（一项或多项）&lt;/li&gt;
&lt;li&gt;POST（CREATE）：在服务器新建一个资源。&lt;/li&gt;
&lt;li&gt;PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。&lt;/li&gt;
&lt;li&gt;PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。&lt;/li&gt;
&lt;li&gt;DELETE（DELETE）：从服务器删除资源。&lt;/li&gt;
&lt;li&gt;HEAD：获取资源的元数据。&lt;/li&gt;
&lt;li&gt;OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;实现&#34;&gt;实现&lt;/h3&gt;
&lt;h4 id=&#34;添加依赖&#34;&gt;添加依赖&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-data-rest&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;定义domain&#34;&gt;定义domain&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;package com.zyndev.springdatarestdemo.domain;

import lombok.Data;

import javax.persistence.*;
import java.io.Serializable;
import java.util.Date;


@Data
@Entity
@Table(name = &amp;quot;tb_user&amp;quot;)
public class User implements Serializable {

    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;            // 用户id
    private String userName;    // 用户名称
    private String password;    // 用户密码
    private Integer active;     // 是否可用
    private Date lastLoginTime; // 最后登录时间
    private Date createTime;    // 账户创建时间
    private Date updateTime;    // 最后更新时间
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;定义-repository&#34;&gt;定义 Repository&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;package com.zyndev.springdatarestdemo.controller;

import com.zyndev.springdatarestdemo.domain.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.rest.core.annotation.RepositoryRestResource;

@RepositoryRestResource(path=&amp;quot;user&amp;quot;)
public interface UserRepository extends JpaRepository&amp;lt;User, Long&amp;gt; {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;配置&#34;&gt;配置&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;server:
  port: 8080

spring:
  jpa:
    hibernate:
      ddl-auto: update
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;通过设置 &lt;code&gt;spring.jpa.hibernate.ddl-auto=update&lt;/code&gt; 来自动创建表，如果你已经根据domain建好表，可忽略，配置中省略了数据库的配置，请根据情况自行添加&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;测试&#34;&gt;测试&lt;/h4&gt;
&lt;p&gt;启动项目:&lt;/p&gt;
&lt;p&gt;​		&lt;strong&gt;1. GET 访问 localhost:8080/user&lt;/strong&gt;这里我已经添加了一条数据&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
    &amp;quot;_embedded&amp;quot;: {
        &amp;quot;users&amp;quot;: [
            {
                &amp;quot;userName&amp;quot;: &amp;quot;abc&amp;quot;,
                &amp;quot;password&amp;quot;: &amp;quot;abc&amp;quot;,
                &amp;quot;active&amp;quot;: 1,
                &amp;quot;lastLoginTime&amp;quot;: null,
                &amp;quot;createTime&amp;quot;: null,
                &amp;quot;updateTime&amp;quot;: null,
                &amp;quot;_links&amp;quot;: {
                    &amp;quot;self&amp;quot;: {
                        &amp;quot;href&amp;quot;: &amp;quot;http://localhost:8080/user/1&amp;quot;
                    },
                    &amp;quot;user&amp;quot;: {
                        &amp;quot;href&amp;quot;: &amp;quot;http://localhost:8080/user/1&amp;quot;
                    }
                }
            }
        ]
    },
    &amp;quot;_links&amp;quot;: {
        &amp;quot;self&amp;quot;: {
            &amp;quot;href&amp;quot;: &amp;quot;http://localhost:8080/user{?page,size,sort}&amp;quot;,
            &amp;quot;templated&amp;quot;: true
        },
        &amp;quot;profile&amp;quot;: {
            &amp;quot;href&amp;quot;: &amp;quot;http://localhost:8080/profile/user&amp;quot;
        }
    },
    &amp;quot;page&amp;quot;: {
        &amp;quot;size&amp;quot;: 20,
        &amp;quot;totalElements&amp;quot;: 1,
        &amp;quot;totalPages&amp;quot;: 1,
        &amp;quot;number&amp;quot;: 0
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		&lt;strong&gt;2. GET 访问 localhost:8080/user/1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​		通过上面可以看出 &lt;code&gt;1&lt;/code&gt; 是存在的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
    &amp;quot;userName&amp;quot;: &amp;quot;abc&amp;quot;,
    &amp;quot;password&amp;quot;: &amp;quot;abc&amp;quot;,
    &amp;quot;active&amp;quot;: 1,
    &amp;quot;lastLoginTime&amp;quot;: null,
    &amp;quot;createTime&amp;quot;: null,
    &amp;quot;updateTime&amp;quot;: null,
    &amp;quot;_links&amp;quot;: {
        &amp;quot;self&amp;quot;: {
            &amp;quot;href&amp;quot;: &amp;quot;http://localhost:8080/user/1&amp;quot;
        },
        &amp;quot;user&amp;quot;: {
            &amp;quot;href&amp;quot;: &amp;quot;http://localhost:8080/user/1&amp;quot;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		&lt;strong&gt;3. GET 访问 localhost:8080/user/2&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​		因为 &lt;code&gt;2&lt;/code&gt; 并不存在，这时返回 &lt;code&gt;404&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;​		&lt;strong&gt;4. POST localhost:8080/user 创建一个资源&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​		设置 &lt;code&gt;Content-Type=application/json&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;​		&lt;strong&gt;body:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
    &amp;quot;userName&amp;quot;: &amp;quot;abcdfasdfe&amp;quot;,
    &amp;quot;password&amp;quot;: &amp;quot;abc&amp;quot;,
    &amp;quot;active&amp;quot;: 1,
    &amp;quot;lastLoginTime&amp;quot;: null,
    &amp;quot;createTime&amp;quot;: null,
    &amp;quot;updateTime&amp;quot;: null
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;返回状态码 &lt;code&gt;201&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;返回数据：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
    &amp;quot;userName&amp;quot;: &amp;quot;abcdfasdfe&amp;quot;,
    &amp;quot;password&amp;quot;: &amp;quot;abc&amp;quot;,
    &amp;quot;active&amp;quot;: 1,
    &amp;quot;lastLoginTime&amp;quot;: null,
    &amp;quot;createTime&amp;quot;: null,
    &amp;quot;updateTime&amp;quot;: null,
    &amp;quot;_links&amp;quot;: {
        &amp;quot;self&amp;quot;: {
            &amp;quot;href&amp;quot;: &amp;quot;http://localhost:8080/user/4&amp;quot;
        },
        &amp;quot;user&amp;quot;: {
            &amp;quot;href&amp;quot;: &amp;quot;http://localhost:8080/user/4&amp;quot;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		&lt;strong&gt;5. 再次访问 GET 访问 localhost:8080/user&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​		这时可以看出 users 的数量为 2 说明已经创建成功&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
    &amp;quot;_embedded&amp;quot;: {
        &amp;quot;users&amp;quot;: [
            {
                &amp;quot;userName&amp;quot;: &amp;quot;abc&amp;quot;,
                &amp;quot;password&amp;quot;: &amp;quot;abc&amp;quot;,
                &amp;quot;active&amp;quot;: 1,
                &amp;quot;lastLoginTime&amp;quot;: null,
                &amp;quot;createTime&amp;quot;: null,
                &amp;quot;updateTime&amp;quot;: null,
                &amp;quot;_links&amp;quot;: {
                    &amp;quot;self&amp;quot;: {
                        &amp;quot;href&amp;quot;: &amp;quot;http://localhost:8080/user/1&amp;quot;
                    },
                    &amp;quot;user&amp;quot;: {
                        &amp;quot;href&amp;quot;: &amp;quot;http://localhost:8080/user/1&amp;quot;
                    }
                }
            },
            {
                &amp;quot;userName&amp;quot;: &amp;quot;abcdfasdfe&amp;quot;,
                &amp;quot;password&amp;quot;: &amp;quot;abc&amp;quot;,
                &amp;quot;active&amp;quot;: 1,
                &amp;quot;lastLoginTime&amp;quot;: null,
                &amp;quot;createTime&amp;quot;: null,
                &amp;quot;updateTime&amp;quot;: null,
                &amp;quot;_links&amp;quot;: {
                    &amp;quot;self&amp;quot;: {
                        &amp;quot;href&amp;quot;: &amp;quot;http://localhost:8080/user/4&amp;quot;
                    },
                    &amp;quot;user&amp;quot;: {
                        &amp;quot;href&amp;quot;: &amp;quot;http://localhost:8080/user/4&amp;quot;
                    }
                }
            }
        ]
    },
    &amp;quot;_links&amp;quot;: {
        &amp;quot;self&amp;quot;: {
            &amp;quot;href&amp;quot;: &amp;quot;http://localhost:8080/user{?page,size,sort}&amp;quot;,
            &amp;quot;templated&amp;quot;: true
        },
        &amp;quot;profile&amp;quot;: {
            &amp;quot;href&amp;quot;: &amp;quot;http://localhost:8080/profile/user&amp;quot;
        }
    },
    &amp;quot;page&amp;quot;: {
        &amp;quot;size&amp;quot;: 20,
        &amp;quot;totalElements&amp;quot;: 2,
        &amp;quot;totalPages&amp;quot;: 1,
        &amp;quot;number&amp;quot;: 0
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		&lt;strong&gt;6. delete 访问 localhost:8080/user/1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;返回状态码： &lt;code&gt;204&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;再次访问 GET 访问 localhost:8080/user 会发现 users 的数量已经为1，说明已经删除成功&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;可以使用 postman 测试，这里为了不贴图，就按上面的写了，希望理解&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;# 小功能&lt;/p&gt;
&lt;p&gt;为了方便查看和测试api,可以集成 &lt;code&gt;hal browser&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在 pom 文件添加依赖即可&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.data&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-data-rest-hal-browser&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重启项目并访问： &lt;code&gt;http://127.0.0.1:8080/browser/index.html#/&lt;/code&gt;&lt;/p&gt;
">Spring Data REST 快速构建 restful api 应用</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://https://chenm0.github.io/post/java10-var/"" data-c="
          &lt;p&gt;​		2018 年 3 月 21 日，Java 10 如约而至。虽然这一版本带来的特性并不是非常多，但其中有一项仍然成为大家关注的热点，它就是局部变量类型推断（JEP 286）。JEP 286 引入了 var，用于声明局部变量，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var users = new ArrayList&amp;lt;User&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		事情就是这么简单。不过，这篇文章将会讨论更多有关 var 的内容，比如什么时候可以用 var、什么时候不能用 var、var 对可读性的影响，以及为什么没有使用 val。&lt;/p&gt;
&lt;h3 id=&#34;使用-var-代替类型声明&#34;&gt;使用 var 代替类型声明&lt;/h3&gt;
&lt;p&gt;​		作为 Java 开发者，在声明一个变量时，我们总是习惯了敲打两次变量类型，第一次用于声明变量类型，第二次用于构造函数，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;		URL codefx = new URL(&amp;quot;http://codefx.org&amp;quot;)
		URLConnection connection = codefx.openConnection();
		Reader reader = new BufferedReader(
  			new InputStreamReader(connection.getInputStream()));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		URL codefx = new URL(&amp;quot;http://codefx.org&amp;quot;)`我们也经常声明一种变量，它只会被使用一次，而且是用在下一行代码中，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;URL codefx = new URL(&amp;quot;http://codefx.org&amp;quot;)
URLConnection connection = codefx.openConnection();
Reader reader = new BufferedReader(
  new InputStreamReader(connection.getInputStream()));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		这样也不算太糟糕，就是有点啰嗦。尽管 IDE 可以帮我们自动完成这些代码，但当变量总是跳来跳去的时候，可读性还是会受到影响，因为变量类型的名称由各种不同长度的字符组成。而且，有时候开发人员会尽力避免声明中间变量，因为太多的类型声明只会分散注意力，不会带来额外的好处。&lt;/p&gt;
&lt;p&gt;​		从Java10开始,开发人员可以使用 var 让编译器自己去推断类型：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	var codefx = new URL(&amp;quot;http://codefx.org&amp;quot;);
	var connection = codefx.openConnection();
  var reader = new BufferedReader(
  new InputStreamReader(connection.getInputStream()));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		在处理 var 时，编译器先是查看表达式右边部分，也就是所谓的构造器，并将它作为变量的类型，然后将该类型写入字节码当中。&lt;/p&gt;
&lt;p&gt;​		这样可以少敲几个字，但更重要的是，它避免了信息冗余，而且对齐了变量名，更容易阅读。当然，这也需要付出一点代价：有些变量，比如例子当中的 connection，就无法立即知道它是什么类型的。虽说 IDE 可以辅助显示出这些变量的类型，但在其他场景下可能就不行了，比如在代码评审的时候。&lt;/p&gt;
&lt;p&gt;​		另外，你不需要担心变量名或方法名会与 var 发生冲突，因为 var 实际上并不是一个关键字，而是一个类型名，只有在编译器需要知道类型的地方才需要用到它。除此之外，它就是一个普通合法的标识符。也就是说，除了不能用它作为类名，其他的都可以，但极少人会用它作为类名。&lt;/p&gt;
&lt;p&gt;​		局部变量类型推断是一个非常直观的特性，不过你可能会想：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这到底是 Java 还是 JavaScript？&lt;/li&gt;
&lt;li&gt;可以在哪些地方使用 var？&lt;/li&gt;
&lt;li&gt;var 会影响可读性吗？&lt;/li&gt;
&lt;li&gt;为什么没有 val 或 let？&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;不这不是-javascript&#34;&gt;不，这不是 JavaScript&lt;/h2&gt;
&lt;p&gt;​		首先我要说明的是，var 并不会改变 Java 是一门静态类型语言的事实。编译器负责推断出类型，并把结果写入字节码文件，就好像是开发人员自己敲入类型一样。&lt;/p&gt;
&lt;p&gt;​		下面是使用 IntelliJ（实际上是 Fernflower 的反编译器）反编译器反编译出的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	URL codefx = new URL(&amp;quot;http://codefx.org&amp;quot;);
	URLConnection connection = codefx.openConnection();
	BufferedReader reader = new BufferedReader(
  new InputStreamReader(connection.getInputStream()));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		从代码来看，就好像之前已经声明了这些类型一样。事实上，这一特性只发生在编译阶段，与运行时无关，所以对运行时的性能不会产生任何影响。所以请放心，这不是 JavaScript。&lt;/p&gt;
&lt;p&gt;​		如果你仍然担心不显式声明类型会让代码变得更糟糕，那么我倒要问你了，你在使用 lambda 表达式的时候会声明参数的类型吗？&lt;/p&gt;
&lt;p&gt;​		&lt;mark&gt;&lt;code&gt;rhetoricalQuestion.answer(yes -&amp;gt; &amp;quot;see my point?&amp;quot;);&lt;/code&gt;## 哪些地方可以使用 var（或哪些地方不能使用 var）&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;​		JEP 286 的标题“局部变量类型推断”就已经暗示了哪些地方可以使用 var：局部变量。更准确地说，是那些带有构造器的局部变量声明。但像这样的就不行了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	// 不行
	var foo;
	foo = &amp;quot;Foo&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;必须写成：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;var foo = &amp;quot;Foo&amp;quot;;&lt;/code&gt;除此之外，var 也不能用在“多元表达式”中，如 lambda 和方法引用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 这些都不行
var ints = {0, 1, 2};
var appendSpace = a -&amp;gt; a + &amp;quot; &amp;quot;;
var compareString = String::compareTo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;除了局部变量，for 循环是唯一可以使用 var 的地方：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var numbers = List.of(&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;);
for (var nr : numbers)
  System.out.print(nr + &amp;quot; &amp;quot;);
for (var i = 0; i &amp;lt; numbers.size(); i++)
  System.out.print(numbers.get(i) + &amp;quot; &amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也就是说，字段、方法签名和 catch 代码块仍然需要显式声明类型。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 这样也是不行的
private var getFoo() {
  return &amp;quot;foo&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;避免action-at-a-distance错误&#34;&gt;避免“Action At A Distance”错误&lt;/h2&gt;
&lt;p&gt;​		将 var 限定在局部变量上并非技术方面的局限，而是设计上的决定。确实，如果能够像下面这样岂不更好？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;		// 编译器推断出类型 List&amp;lt;User&amp;gt;
		var users = new ArrayList&amp;lt;User&amp;gt;();
		// 这样就不行了，会出现编译错误
		users = new LinkedList&amp;lt;&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		按照预期，编译器应该能够找出最具体的那个类型，但实际上它不会。JDK 团队想要避免“Action At A Distance”错误（AAD），也就是说，他们希望在某处修改了代码不会影响到其他很“远”的地方。比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	// id 被推推为`int`
	var id = 123;
	if (id &amp;lt; 100) {
  	// 此处省略了很长的代码
  	// 调用了其他类的方法
	} else {
  	// 此处也省略了很长的代码
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		现在，我们加入一行：&lt;/p&gt;
&lt;p&gt;​		&lt;code&gt;id = &amp;quot;124&amp;quot;&lt;/code&gt;这样会发生什么？if 代码块会抛出一个错误，因为 id 变成了字符串类型，所有不能使用小于号进行比较操作。这个错误距离代码修改的地方很“远”，而其根源就是因为对一个变量重新赋值。&lt;/p&gt;
&lt;p&gt;​		这么看来，将类型推断限定在带有构造器的局部变量声明上是有它的道理的。&lt;/p&gt;
&lt;h2 id=&#34;为什么不推断字段和方法的类型&#34;&gt;为什么不推断字段和方法的类型？&lt;/h2&gt;
&lt;p&gt;​		字段和方法的作用域比局部变量大得多，所以更有可能出现 AAD 错误。在最糟糕的情况下，修改一个方法的参数类型可能导致二进制文件的不兼容和运行时错误。&lt;/p&gt;
&lt;p&gt;​		因为非 private 的字段和方法是类契约的一部分，它们的类型不能通过推断来获得。不过，private 的字段和方法似乎可以使用类型推断，但问题是这样会让这个特性看起来非常奇怪。&lt;/p&gt;
&lt;p&gt;​		局部变量属于实现细节，通常不会在很“远”的地方引用这些变量，所以就没有必要严格、显式和啰嗦地给它们声明类型了。&lt;/p&gt;
&lt;h2 id=&#34;为什么要使用-var&#34;&gt;为什么要使用 var？&lt;/h2&gt;
&lt;p&gt;​		相比其他年轻的编程语言，Java 代码的啰嗦是开发人员最大的痛点之一，也是饱受 Java 开发人员诟病的一个地方。为此，Amber 项目开发了 var，旨在“开发出一些小的 Java 语言特性，以便提高效率”，其目标是降低 Java 代码编写和阅读的繁琐程度。&lt;/p&gt;
&lt;p&gt;​		局部变量类型推断正好迎合了这一目标。在编写代码时，声明变量的方式更简单了，尽管这类代码有大半可以使用 IDE 生成，或者使用 IDE 的重构功能进行修改。&lt;/p&gt;
&lt;p&gt;​		除了让变量声明变得更简单，修改起来也很容易。这话怎么说？有些变量的类型真的很难看，比如那些带有泛型的企业级类名：&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;InternationalCustomerOrderProcessor&amp;gt; orderProcessor = 				createInternationalOrderProcessor(customer, order);`因为类型名称太长了，结果把变量名推到了代码的右边。如果限定了每行只能容纳 150 个字符，那么变量名还有可能被推到下一行显示。这些对于可读性来说都是一种伤害。

`var orderProcessor = createInternationalOrderProcessor(customer, order);`使用 var 就显得不那么累赘了，一眼就能看到头。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		总之，使用 var 的意义不在于减少字符数量，而是为了不那么啰嗦和累赘。&lt;/p&gt;
&lt;h2 id=&#34;对可读性的影响&#34;&gt;对可读性的影响&lt;/h2&gt;
&lt;p&gt;​		现在让我们来讲讲可读性。确实，类型的缺失会让事情变得更糟糕，不是吗？一般来说，确实是的。在阅读代码时，类型是很重要的一个因素。尽管 IDE 可以帮助显示出推断的类型，但如果这些类型直接显示在代码中看起来不是更方便吗？&lt;/p&gt;
&lt;p&gt;​		这是 var 在可读性方面的一个不足，不过，它却带来了另一个优势，那就是变量名对齐：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	// 显式类型
	No no = new No();
	AmountIncrease&amp;lt;BigDecimal&amp;gt; more = new BigDecimalAmountIncrease();
	HorizontalConnection&amp;lt;LinePosition, LinePosition&amp;gt; jumping =
  	new HorizontalLinePositionConnection();
	Variable variable = new Constant(5);
	List&amp;lt;String&amp;gt; names = List.of(&amp;quot;Max&amp;quot;, &amp;quot;Maria&amp;quot;);
	// 推断类型
	var no = new No();
	var more = new BigDecimalAmountIncrease();
  var jumping = new HorizontalLinePositionConnection();
	var variable = new Constant(5);
	var names = List.of(&amp;quot;Max&amp;quot;, &amp;quot;Maria&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​		虽说类型名称很重要，但好的变量名也是有过之而无不及。类型用于描述 Java 生态系统（JDK 的类）、一般场景（类库或框架）或业务领域（应用程序）的一般性概念，所以类型一般会有通用的名字。而变量名处在很小的上下文中，它们的名字应该要更精确一些。&lt;/p&gt;
&lt;p&gt;​		这种可读性方面的改进可能会导致出现更多带有构造器的局部变量声明，因为这样在编写代码和阅读代码时会更加方便。&lt;/p&gt;
&lt;h2 id=&#34;为什么没有使用-valconstlet&#34;&gt;为什么没有使用 val/const/let？&lt;/h2&gt;
&lt;p&gt;​		其他很多使用了 var 的编程语言也会为不可变变量提供一个额外的关键字，比如 val、const 或 let。但 Java 10 没有使用这些关键字，所以我们必须使用 final var 来声明不可变变量。究其原因，可能是因为：&lt;/p&gt;
&lt;p&gt;​		1.虽说不变性很重要,但对于局部变量来说,这种重要性程度没有那么高.&lt;/p&gt;
&lt;p&gt;​		2.Java 8 引入了“隐式”final的概念,所以在我们看来,局部变量就已经是不可变的.&lt;/p&gt;
&lt;p&gt;​		3.大部分人同意使用var（74% 的人强烈同意，12% 的人基本同意），而对 var/val 和 var/let 的反馈则显得有点含糊不清。&lt;/p&gt;
&lt;p&gt;​		我同意前面两点，至于第三点只能勉强接受，但对结果还是感到有点失望。或许等到了有一天，我们不得不使用 final var 的时候，是不是可以考虑使用 val 或 let？&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;​		在声明局部变量时，可以使用 var 代替具体的类名或接口名，让编译器自己去推断变量的类型。当然，只有在声明并且立即初始化变量的情况下才能使用 var。for 循环中的下标也可以使用 var 来声明。编译器会把推断出来的类型写入字节码，不影响运行时。Java 仍然是一门静态类型的语言。&lt;/p&gt;
&lt;p&gt;​		除了局部变量，var 不能被用于字段或方法上，这样做是为了避免 AAD 错误。&lt;/p&gt;
&lt;p&gt;​		虽说 var 有可能让代码变得更糟，但作为 Java 开发者，应该尝试在变量声明和嵌套表达式或链式表达式之间做出权衡，写出可读性更高的代码。&lt;/p&gt;
">Java 10 var 关键字深度解读</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://https://chenm0.github.io/post/sql-yu-ju-xing-neng-you-hua-ce-lue/"" data-c="
          &lt;p&gt;1、对查询进行优化，应尽量避免全表扫描，首先应考虑在where及order by涉及的列上建立索引。&lt;/p&gt;
&lt;p&gt;2、应尽量避免在where子句中对字段进行null值判断，创建表时NULL是默认值，但大多数时候应该使用NOT NULL，或者使用一个特殊的值，如0，-1作为默认值。&lt;/p&gt;
&lt;p&gt;3、应尽量避免在where子句中使用!=或&amp;lt;&amp;gt;操作符，MySQL只有对以下操作符才使用索引：&amp;lt;，&amp;lt;=，=，&amp;gt;，&amp;gt;=，BETWEEN，IN，以及某些时候的LIKE。&lt;/p&gt;
&lt;p&gt;4、应尽量避免在where子句中使用or来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，可以使用UNION合并查询：select id from t where num=10 union all select id from t where num=20。&lt;/p&gt;
&lt;p&gt;5、in和not in也要慎用，否则会导致全表扫描，对于连续的数值，能用between就不要用in了：Select id from t where num between 1 and 3。&lt;/p&gt;
&lt;p&gt;6、下面的查询也将导致全表扫描：select id from t where name like‘%abc%’或者select id from t where name like‘%abc’若要提高效率，可以考虑全文检索。而select id from t where name like‘abc%’才用到索引。&lt;/p&gt;
&lt;p&gt;7、如果在where子句中使用参数，也会导致全表扫描。&lt;/p&gt;
&lt;p&gt;8、应尽量避免在where子句中对字段进行表达式操作，应尽量避免在where子句中对字段进行函数操作。&lt;/p&gt;
&lt;p&gt;9、很多时候用exists代替in是一个好的选择：select num from a where num in(select num from b)。用下面的语句替换：select num from a where exists(select 1 from b where num=a.num)。&lt;/p&gt;
&lt;p&gt;10、索引固然可以提高相应的select的效率，但同时也降低了insert及update的效率，因为insert或update时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。关于索引可以关注公众号Java技术栈搜索阅读更多详细教程。&lt;/p&gt;
&lt;p&gt;11、应尽可能的避免更新clustered索引数据列， 因为clustered索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新clustered索引数据列，那么需要考虑是否应将该索引建为clustered索引。&lt;/p&gt;
&lt;p&gt;12、尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。&lt;/p&gt;
&lt;p&gt;13、尽可能的使用varchar/nvarchar代替char/nchar，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。&lt;/p&gt;
&lt;p&gt;14、最好不要使用”“返回所有：select from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。具体可以阅读《别再 select * 了》这篇文章。&lt;/p&gt;
&lt;p&gt;15、尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。&lt;/p&gt;
&lt;p&gt;16、使用表的别名(Alias)：当在SQL语句中连接多个表时，请使用表的别名并把别名前缀于每个Column上。这样一来，就可以减少解析的时间并减少那些由Column歧义引起的语法错误。&lt;/p&gt;
&lt;p&gt;17、使用“临时表”暂存中间结果 ：&lt;/p&gt;
&lt;p&gt;简化SQL语句的重要方法就是采用临时表暂存中间结果，但是临时表的好处远远不止这些，将临时结果暂存在临时表，后面的查询就在tempdb中了，这可以避免程序中多次扫描主表，也大大减少了程序执行中“共享锁”阻塞“更新锁”，减少了阻塞，提高了并发性能。&lt;/p&gt;
&lt;p&gt;18、一些SQL查询语句应加上nolock，读、写是会相互阻塞的，为了提高并发性能，对于一些查询，可以加上nolock，这样读的时候可以允许写，但缺点是可能读到未提交的脏数据。&lt;/p&gt;
&lt;p&gt;使用nolock有3条原则：&lt;/p&gt;
&lt;p&gt;查询的结果用于“插、删、改”的不能加nolock；&lt;br&gt;
查询的表属于频繁发生页分裂的，慎用nolock ；&lt;br&gt;
使用临时表一样可以保存“数据前影”，起到类似Oracle的undo表空间的功能，能采用临时表提高并发性能的，不要用nolock。&lt;/p&gt;
&lt;p&gt;19、常见的简化规则如下：&lt;/p&gt;
&lt;p&gt;不要有超过5个以上的表连接（JOIN），考虑使用临时表或表变量存放中间结果。少用子查询，视图嵌套不要过深，一般视图嵌套不要超过2个为宜。&lt;/p&gt;
&lt;p&gt;20、将需要查询的结果预先计算好放在表中，查询的时候再Select。这在SQL7.0以前是最重要的手段，例如医院的住院费计算。&lt;/p&gt;
&lt;p&gt;21、用OR的字句可以分解成多个查询，并且通过UNION 连接多个查询。他们的速度只同是否使用索引有关，如果查询需要用到联合索引，用UNION all执行的效率更高。多个OR的字句没有用到索引，改写成UNION的形式再试图与索引匹配。一个关键的问题是否用到索引。&lt;/p&gt;
&lt;p&gt;22、在IN后面值的列表中，将出现最频繁的值放在最前面，出现得最少的放在最后面，减少判断的次数。&lt;/p&gt;
&lt;p&gt;23、尽量将数据的处理工作放在服务器上，减少网络的开销，如使用存储过程。&lt;/p&gt;
&lt;p&gt;存储过程是编译好、优化过、并且被组织到一个执行规划里、且存储在数据库中的SQL语句，是控制流语言的集合，速度当然快。反复执行的动态SQL，可以使用临时存储过程，该过程（临时表）被放在Tempdb中。&lt;/p&gt;
&lt;p&gt;24、当服务器的内存够多时，配制线程数量 = 最大连接数+5，这样能发挥最大的效率；否则使用 配制线程数量&amp;lt;最大连接数启用SQL SERVER的线程池来解决，如果还是数量 = 最大连接数+5，严重的损害服务器的性能。&lt;/p&gt;
&lt;p&gt;25、查询的关联同写的顺序 ：&lt;/p&gt;
&lt;p&gt;select a.personMemberID, * from chineseresume a,personmember b where personMemberID = b.referenceid and a.personMemberID = ‘JCNPRH39681’ （A = B ,B = ‘号码’）&lt;/p&gt;
&lt;p&gt;select a.personMemberID, * from chineseresume a,personmember b where a.personMemberID = b.referenceid and a.personMemberID = ‘JCNPRH39681’ and b.referenceid = ‘JCNPRH39681’ （A = B ,B = ‘号码’， A = ‘号码’）&lt;/p&gt;
&lt;p&gt;select a.personMemberID, * from chineseresume a,personmember b where b.referenceid = ‘JCNPRH39681’ and a.personMemberID = ‘JCNPRH39681’ （B = ‘号码’， A = ‘号码’）&lt;/p&gt;
&lt;p&gt;26、尽量使用exists代替select count(1)来判断是否存在记录，count函数只有在统计表中所有行数时使用，而且count(1)比count(*)更有效率。&lt;/p&gt;
&lt;p&gt;27、尽量使用“&amp;gt;=”，不要使用“&amp;gt;”。&lt;/p&gt;
&lt;p&gt;28、索引的使用规范：&lt;/p&gt;
&lt;p&gt;索引的创建要与应用结合考虑，建议大的OLTP表不要超过6个索引；&lt;br&gt;
尽可能的使用索引字段作为查询条件，尤其是聚簇索引，必要时可以通过index index_name来强制指定索引；&lt;br&gt;
避免对大表查询时进行table scan，必要时考虑新建索引；&lt;br&gt;
在使用索引字段作为条件时，如果该索引是联合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用；&lt;br&gt;
要注意索引的维护，周期性重建索引，重新编译存储过程。&lt;/p&gt;
&lt;p&gt;29、下列SQL条件语句中的列都建有恰当的索引，但执行速度却非常慢：&lt;/p&gt;
&lt;p&gt;SELECT * FROM record WHERE substrINg(card_no,1,4)=’5378’ (13秒)&lt;/p&gt;
&lt;p&gt;SELECT * FROM record WHERE amount/30&amp;lt; 1000 （11秒）&lt;/p&gt;
&lt;p&gt;SELECT * FROM record WHERE convert(char(10),date,112)=’19991201’ （10秒）&lt;/p&gt;
&lt;p&gt;分析：&lt;/p&gt;
&lt;p&gt;WHERE子句中对列的任何操作结果都是在SQL运行时逐列计算得到的，因此它不得不进行表搜索，而没有使用该列上面的索引。&lt;/p&gt;
&lt;p&gt;如果这些结果在查询编译时就能得到，那么就可以被SQL优化器优化，使用索引，避免表搜索，因此将SQL重写成下面这样：&lt;/p&gt;
&lt;p&gt;SELECT * FROM record WHERE card_no like ‘5378%’ （&amp;lt; 1秒）&lt;/p&gt;
&lt;p&gt;SELECT * FROM record WHERE amount&amp;lt; 1000*30 （&amp;lt; 1秒）&lt;/p&gt;
&lt;p&gt;SELECT * FROM record WHERE date= ‘1999/12/01’ （&amp;lt; 1秒）&lt;/p&gt;
&lt;p&gt;30、当有一批处理的插入或更新时，用批量插入或批量更新，绝不会一条条记录的去更新。批量插入的方法请关注公众号Java技术栈然后搜索阅读。&lt;/p&gt;
&lt;p&gt;31、在所有的存储过程中，能够用SQL语句的，我绝不会用循环去实现。&lt;br&gt;
例如：列出上个月的每一天，我会用connect by去递归查询一下，绝不会去用循环从上个月第一天到最后一天。&lt;/p&gt;
&lt;p&gt;32、选择最有效率的表名顺序（只在基于规则的优化器中有效）：&lt;/p&gt;
&lt;p&gt;Oracle的解析器按照从右到左的顺序处理FROM子句中的表名，FROM子句中写在最后的表（基础表 driving table）将被最先处理，在FROM子句中包含多个表的情况下，你必须选择记录条数最少的表作为基础表。&lt;/p&gt;
&lt;p&gt;如果有3个以上的表连接查询，那就需要选择交叉表（intersection table）作为基础表，交叉表是指那个被其他表所引用的表。&lt;/p&gt;
&lt;p&gt;33、提高GROUP BY语句的效率，可以通过将不需要的记录在GROUP BY之前过滤掉。下面两个查询返回相同结果，但第二个明显就快了许多。&lt;/p&gt;
&lt;p&gt;低效：&lt;/p&gt;
&lt;p&gt;SELECT JOB , AVG(SAL)&lt;br&gt;
FROM EMP&lt;br&gt;
GROUP BY JOB&lt;br&gt;
HAVING JOB =’PRESIDENT’&lt;br&gt;
OR JOB =’MANAGER’&lt;/p&gt;
&lt;p&gt;高效:&lt;/p&gt;
&lt;p&gt;SELECT JOB , AVG(SAL)&lt;br&gt;
FROM EMP&lt;br&gt;
WHERE JOB =’PRESIDENT’&lt;br&gt;
OR JOB =’MANAGER’&lt;br&gt;
GROUP BY JOB&lt;/p&gt;
&lt;p&gt;34、SQL语句用大写，因为Oracle总是先解析SQL语句，把小写的字母转换成大写的再执行。&lt;/p&gt;
&lt;p&gt;35、别名的使用，别名是大型数据库的应用技巧，就是表名、列名在查询中以一个字母为别名，查询速度要比建连接表快1.5倍。&lt;/p&gt;
&lt;p&gt;36、避免死锁，在你的存储过程和触发器中访问同一个表时总是以相同的顺序；事务应经可能地缩短，在一个事务中应尽可能减少涉及到的数据量；永远不要在事务中等待用户输入。&lt;/p&gt;
&lt;p&gt;37、避免使用临时表，除非却有需要，否则应尽量避免使用临时表，相反，可以使用表变量代替；大多数时候(99%)，表变量驻扎在内存中，因此速度比临时表更快，临时表驻扎在TempDb数据库中，因此临时表上的操作需要跨数据库通信，速度自然慢。&lt;/p&gt;
&lt;p&gt;38、最好不要使用触发器：&lt;/p&gt;
&lt;p&gt;触发一个触发器，执行一个触发器事件本身就是一个耗费资源的过程；&lt;br&gt;
如果能够使用约束实现的，尽量不要使用触发器；&lt;br&gt;
不要为不同的触发事件(Insert，Update和Delete)使用相同的触发器；&lt;br&gt;
不要在触发器中使用事务型代码。&lt;/p&gt;
&lt;p&gt;39、索引创建规则：&lt;/p&gt;
&lt;p&gt;表的主键、外键必须有索引；&lt;br&gt;
数据量超过300的表应该有索引；&lt;br&gt;
经常与其他表进行连接的表，在连接字段上应该建立索引；&lt;br&gt;
经常出现在Where子句中的字段，特别是大表的字段，应该建立索引；&lt;br&gt;
索引应该建在选择性高的字段上；&lt;br&gt;
索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；&lt;br&gt;
复合索引的建立需要进行仔细分析，尽量考虑用单字段索引代替；&lt;br&gt;
正确选择复合索引中的主列字段，一般是选择性较好的字段；&lt;br&gt;
复合索引的几个字段是否经常同时以AND方式出现在Where子句中？单字段查询是否极少甚至没有？如果是，则可以建立复合索引；否则考虑单字段索引；&lt;br&gt;
如果复合索引中包含的字段经常单独出现在Where子句中，则分解为多个单字段索引；&lt;br&gt;
如果复合索引所包含的字段超过3个，那么仔细考虑其必要性，考虑减少复合的字段；&lt;br&gt;
如果既有单字段索引，又有这几个字段上的复合索引，一般可以删除复合索引；&lt;br&gt;
频繁进行数据操作的表，不要建立太多的索引；&lt;br&gt;
删除无用的索引，避免对执行计划造成负面影响；&lt;br&gt;
表上建立的每个索引都会增加存储开销，索引对于插入、删除、更新操作也会增加处理上的开销。另外，过多的复合索引，在有单字段索引的情况下，一般都是没有存在价值的；相反，还会降低数据增加删除时的性能，特别是对频繁更新的表来说，负面影响更大。&lt;br&gt;
尽量不要对数据库中某个含有大量重复的值的字段建立索引。MySQL开发 36 条军规，推荐看下。&lt;/p&gt;
&lt;p&gt;40、MySQL查询优化总结：&lt;/p&gt;
&lt;p&gt;使用慢查询日志去发现慢查询，使用执行计划去判断查询是否正常运行，总是去测试你的查询看看是否他们运行在最佳状态下。关注公众号Java技术栈回复面试，可以获取 MySQL 及更多面试题。&lt;/p&gt;
&lt;p&gt;久而久之性能总会变化，避免在整个表上使用count(*)，它可能锁住整张表，使查询保持一致以便后续相似的查询可以使用查询缓存，在适当的情形下使用GROUP BY而不是DISTINCT，在WHERE、GROUP BY和ORDER BY子句中使用有索引的列，保持索引简单，不在多个索引中包含同一个列。&lt;/p&gt;
&lt;p&gt;有时候MySQL会使用错误的索引，对于这种情况使用USE INDEX，检查使用SQL_MODE=STRICT的问题，对于记录数小于5的索引字段，在UNION的时候使用LIMIT不是是用OR。&lt;/p&gt;
&lt;p&gt;为了避免在更新前SELECT，使用INSERT ON DUPLICATE KEY或者INSERT IGNORE，不要用UPDATE去实现，不要使用MAX，使用索引字段和ORDER BY子句，LIMIT M，N实际上可以减缓查询在某些情况下，有节制地使用，在WHERE子句中使用UNION代替子查询，在重新启动的MySQL，记得来温暖你的数据库，以确保数据在内存和查询速度快，考虑持久连接，而不是多个连接，以减少开销。&lt;/p&gt;
&lt;p&gt;基准查询，包括使用服务器上的负载，有时一个简单的查询可以影响其他查询，当负载增加在服务器上，使用SHOW PROCESSLIST查看慢的和有问题的查询，在开发环境中产生的镜像数据中测试的所有可疑的查询。&lt;/p&gt;
&lt;p&gt;41、MySQL备份过程：&lt;/p&gt;
&lt;p&gt;从二级复制服务器上进行备份；&lt;br&gt;
在进行备份期间停止复制，以避免在数据依赖和外键约束上出现不一致；&lt;br&gt;
彻底停止MySQL，从数据库文件进行备份；&lt;br&gt;
如果使用MySQL dump进行备份，请同时备份二进制日志文件 – 确保复制没有中断；&lt;br&gt;
不要信任LVM快照，这很可能产生数据不一致，将来会给你带来麻烦；&lt;br&gt;
为了更容易进行单表恢复，以表为单位导出数据——如果数据是与其他表隔离的。&lt;br&gt;
当使用mysqldump时请使用–opt；&lt;br&gt;
在备份之前检查和优化表；&lt;br&gt;
为了更快的进行导入，在导入时临时禁用外键约束。；&lt;br&gt;
为了更快的进行导入，在导入时临时禁用唯一性检测；&lt;br&gt;
在每一次备份后计算数据库，表以及索引的尺寸，以便更够监控数据尺寸的增长；&lt;br&gt;
通过自动调度脚本监控复制实例的错误和延迟；&lt;br&gt;
定期执行备份。&lt;/p&gt;
&lt;p&gt;42、查询缓冲并不自动处理空格，因此，在写SQL语句时，应尽量减少空格的使用，尤其是在SQL首和尾的空格（因为查询缓冲并不自动截取首尾空格）。&lt;/p&gt;
&lt;p&gt;43、member用mid做标准进行分表方便查询么？一般的业务需求中基本上都是以username为查询依据，正常应当是username做hash取模来分表。&lt;/p&gt;
&lt;p&gt;而分表的话MySQL的partition功能就是干这个的，对代码是透明的；在代码层面去实现貌似是不合理的。&lt;/p&gt;
&lt;p&gt;44、我们应该为数据库里的每张表都设置一个ID做为其主键，而且最好的是一个INT型的（推荐使用UNSIGNED），并设置上自动增加的AUTO_INCREMENT标志。&lt;/p&gt;
&lt;p&gt;45、在所有的存储过程和触发器的开始处设置SET NOCOUNT ON，在结束时设置SET NOCOUNT OFF。无需在执行存储过程和触发器的每个语句后向客户端发送DONE_IN_PROC消息。&lt;/p&gt;
&lt;p&gt;46、MySQL查询可以启用高速查询缓存。这是提高数据库性能的有效MySQL优化方法之一。当同一个查询被执行多次时，从缓存中提取数据和直接从数据库中返回数据快很多。&lt;/p&gt;
&lt;p&gt;47、EXPLAIN SELECT查询用来跟踪查看效果：&lt;/p&gt;
&lt;p&gt;使用EXPLAIN关键字可以让你知道MySQL是如何处理你的SQL语句的。这可以帮你分析你的查询语句或是表结构的性能瓶颈。EXPLAIN的查询结果还会告诉你你的索引主键被如何利用的，你的数据表是如何被搜索和排序的。&lt;/p&gt;
&lt;p&gt;48、当只要一行数据时使用LIMIT 1 ：&lt;/p&gt;
&lt;p&gt;当你查询表的有些时候，你已经知道结果只会有一条结果，但因为你可能需要去fetch游标，或是你也许会去检查返回的记录数。&lt;/p&gt;
&lt;p&gt;在这种情况下，加上LIMIT 1可以增加性能。这样一来，MySQL数据库引擎会在找到一条数据后停止搜索，而不是继续往后查少下一条符合记录的数据。&lt;/p&gt;
&lt;p&gt;49、选择表合适存储引擎：&lt;/p&gt;
&lt;p&gt;myisam：应用时以读和插入操作为主，只有少量的更新和删除，并且对事务的完整性，并发性要求不是很高的。&lt;br&gt;
InnoDB：事务处理，以及并发条件下要求数据的一致性。除了插入和查询外，包括很多的更新和删除。（InnoDB有效地降低删除和更新导致的锁定）。&lt;br&gt;
对于支持事务的InnoDB类型的表来说，影响速度的主要原因是AUTOCOMMIT默认设置是打开的，而且程序没有显式调用BEGIN 开始事务，导致每插入一条都自动提交，严重影响了速度。可以在执行SQL前调用begin，多条SQL形成一个事物（即使autocommit打开也可以），将大大提高性能。&lt;/p&gt;
&lt;p&gt;50、优化表的数据类型，选择合适的数据类型：&lt;/p&gt;
&lt;p&gt;原则：更小通常更好，简单就好，所有字段都得有默认值，尽量避免null。&lt;/p&gt;
&lt;p&gt;例如：数据库表设计时候更小的占磁盘空间尽可能使用更小的整数类型。(mediumint就比int更合适)&lt;/p&gt;
&lt;p&gt;比如时间字段：datetime和timestamp，datetime占用8个字节，而timestamp占用4个字节，只用了一半，而timestamp表示的范围是1970—2037适合做更新时间&lt;/p&gt;
&lt;p&gt;MySQL可以很好的支持大数据量的存取，但是一般说来，数据库中的表越小，在它上面执行的查询也就会越快。&lt;/p&gt;
&lt;p&gt;因此，在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度设得尽可能小。&lt;/p&gt;
&lt;p&gt;例如：在定义邮政编码这个字段时，如果将其设置为CHAR(255)，显然给数据库增加了不必要的空间。甚至使用VARCHAR这种类型也是多余的，因为CHAR(6)就可以很好的完成任务了。&lt;/p&gt;
&lt;p&gt;同样的，如果可以的话，我们应该使用MEDIUMINT而不是BIGIN来定义整型字段，应该尽量把字段设置为NOT NULL，这样在将来执行查询的时候，数据库不用去比较NULL值。&lt;/p&gt;
&lt;p&gt;对于某些文本字段，例如“省份”或者“性别”，我们可以将它们定义为ENUM类型。因为在MySQL中，ENUM类型被当作数值型数据来处理，而数值型数据被处理起来的速度要比文本类型快得多。这样，我们又可以提高数据库的性能。&lt;/p&gt;
&lt;p&gt;51、字符串数据类型：char，varchar，text选择区别。&lt;/p&gt;
&lt;p&gt;52、任何对列的操作都将导致表扫描，它包括数据库函数、计算表达式等等，查询时要尽可能将操作移至等号右边。&lt;/p&gt;
">SQL 语句性能优化策略</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://https://chenm0.github.io/post/about/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://https://chenm0.github.io//post-images/1618881224746.jpeg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
JAVA PROGRAMMER👨‍💻&lt;/p&gt;
">关于</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  !function () {
    let times = document.querySelectorAll('.publish-time');
    for (let i = 0; i < times.length; i++) {
      let date = times[i].dataset.t;
      let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
      if (time < 60) {
        str = time + '秒之前';
      } else if (time < 3600) {
        str = Math.floor(time / 60) + '分钟之前';
      } else if (time >= 3600 && time < 86400) {
        str = Math.floor(time / 3600) + '小时之前';
      } else if (time >= 86400 && time < 259200) {
        str = Math.floor(time / 86400) + '天之前';
      } else {
        str = times[i].textContent;
      }
      times[i].textContent = str;
    }
  }();
</script>

<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }
  //拿来主义(真香)^_^，Clipboard 实现摘自掘金 https://juejin.im/post/5aefeb6e6fb9a07aa43c20af
  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>


<script src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
<script>
  var scroll = new SmoothScroll('a[href*="#"]', {
    speed: 200
  });
</script>


<script src="/media/js/mouse/love.js"></script>


<script src="/media/js/cool.js"></script>



  <div class="snow-container"></div>
  <script src="/media/js/bg/canvas-nest.js"></script>
  <script>
  const config = {
    color: '255,0,0',
    count: 88,
  };
  // Using config rendering effect at 'element'.
  const cn = new CanvasNest(document.querySelector('.snow-container'), config);
  </script>

</html>