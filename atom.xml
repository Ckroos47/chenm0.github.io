<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://cm940324.github.io</id>
    <title>Oasis</title>
    <updated>2021-04-22T06:10:57.619Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://cm940324.github.io"/>
    <link rel="self" href="https://cm940324.github.io/atom.xml"/>
    <subtitle>&lt;a href=&quot;https://cm940324.github.io/&quot; target=&quot;_blank&quot;&gt;code blog&lt;/a&gt;</subtitle>
    <logo>https://cm940324.github.io/images/avatar.png</logo>
    <icon>https://cm940324.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Oasis</rights>
    <entry>
        <title type="html"><![CDATA[Spring Data REST 快速构建 restful api 应用]]></title>
        <id>https://cm940324.github.io/post/spring-data-rest/</id>
        <link href="https://cm940324.github.io/post/spring-data-rest/">
        </link>
        <updated>2021-04-22T06:00:24.000Z</updated>
        <content type="html"><![CDATA[<h3 id="什么是spring-data-rest">什么是Spring Data REST</h3>
<blockquote>
<p>​		Spring Data REST是基于Spring Data的repository之上，可以把 repository 自动输出为REST资源，目前支持Spring Data JPA、Spring Data <a href="https://cloud.tencent.com/product/mongodb?from=10680">MongoDB</a>、Spring Data Neo4j、Spring Data GemFire、Spring Data Cassandra的 repository 自动转换成REST服务。注意是自动。简单点说，Spring Data REST把我们需要编写的大量REST模版接口做了自动化实现.</p>
</blockquote>
<h3 id="restful-api">restful api</h3>
<p>​		REST是一种设计风格(与具体的语言无关)，它的URL主体是资源，是个名词。而且也仅支持HTTP协议，规定了使用HTTP Method表达本次要做的动作，类型一般也不超过那四五种。这些动作表达了对资源仅有的几种转化方式。</p>
<p>​		常用的HTTP动词有下面五个（括号里是对应的SQL命令）。</p>
<ul>
<li>GET（SELECT）：从服务器取出资源（一项或多项）</li>
<li>POST（CREATE）：在服务器新建一个资源。</li>
<li>PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。</li>
<li>PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。</li>
<li>DELETE（DELETE）：从服务器删除资源。</li>
<li>HEAD：获取资源的元数据。</li>
<li>OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。</li>
</ul>
<h3 id="实现">实现</h3>
<h4 id="添加依赖">添加依赖</h4>
<pre><code class="language-javascript">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-rest&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h4 id="定义domain">定义domain</h4>
<pre><code class="language-javascript">package com.zyndev.springdatarestdemo.domain;

import lombok.Data;

import javax.persistence.*;
import java.io.Serializable;
import java.util.Date;


@Data
@Entity
@Table(name = &quot;tb_user&quot;)
public class User implements Serializable {

    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;            // 用户id
    private String userName;    // 用户名称
    private String password;    // 用户密码
    private Integer active;     // 是否可用
    private Date lastLoginTime; // 最后登录时间
    private Date createTime;    // 账户创建时间
    private Date updateTime;    // 最后更新时间
}
</code></pre>
<h4 id="定义-repository">定义 Repository</h4>
<pre><code class="language-javascript">package com.zyndev.springdatarestdemo.controller;

import com.zyndev.springdatarestdemo.domain.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.rest.core.annotation.RepositoryRestResource;

@RepositoryRestResource(path=&quot;user&quot;)
public interface UserRepository extends JpaRepository&lt;User, Long&gt; {
}
</code></pre>
<h4 id="配置">配置</h4>
<pre><code class="language-javascript">server:
  port: 8080

spring:
  jpa:
    hibernate:
      ddl-auto: update
</code></pre>
<blockquote>
<p>通过设置 <code>spring.jpa.hibernate.ddl-auto=update</code> 来自动创建表，如果你已经根据domain建好表，可忽略，配置中省略了数据库的配置，请根据情况自行添加</p>
</blockquote>
<h4 id="测试">测试</h4>
<p>启动项目:</p>
<p>​		<strong>1. GET 访问 localhost:8080/user</strong>这里我已经添加了一条数据</p>
<pre><code class="language-javascript">{
    &quot;_embedded&quot;: {
        &quot;users&quot;: [
            {
                &quot;userName&quot;: &quot;abc&quot;,
                &quot;password&quot;: &quot;abc&quot;,
                &quot;active&quot;: 1,
                &quot;lastLoginTime&quot;: null,
                &quot;createTime&quot;: null,
                &quot;updateTime&quot;: null,
                &quot;_links&quot;: {
                    &quot;self&quot;: {
                        &quot;href&quot;: &quot;http://localhost:8080/user/1&quot;
                    },
                    &quot;user&quot;: {
                        &quot;href&quot;: &quot;http://localhost:8080/user/1&quot;
                    }
                }
            }
        ]
    },
    &quot;_links&quot;: {
        &quot;self&quot;: {
            &quot;href&quot;: &quot;http://localhost:8080/user{?page,size,sort}&quot;,
            &quot;templated&quot;: true
        },
        &quot;profile&quot;: {
            &quot;href&quot;: &quot;http://localhost:8080/profile/user&quot;
        }
    },
    &quot;page&quot;: {
        &quot;size&quot;: 20,
        &quot;totalElements&quot;: 1,
        &quot;totalPages&quot;: 1,
        &quot;number&quot;: 0
    }
}
</code></pre>
<p>​		<strong>2. GET 访问 localhost:8080/user/1</strong></p>
<p>​		通过上面可以看出 <code>1</code> 是存在的</p>
<pre><code class="language-javascript">{
    &quot;userName&quot;: &quot;abc&quot;,
    &quot;password&quot;: &quot;abc&quot;,
    &quot;active&quot;: 1,
    &quot;lastLoginTime&quot;: null,
    &quot;createTime&quot;: null,
    &quot;updateTime&quot;: null,
    &quot;_links&quot;: {
        &quot;self&quot;: {
            &quot;href&quot;: &quot;http://localhost:8080/user/1&quot;
        },
        &quot;user&quot;: {
            &quot;href&quot;: &quot;http://localhost:8080/user/1&quot;
        }
    }
}
</code></pre>
<p>​		<strong>3. GET 访问 localhost:8080/user/2</strong></p>
<p>​		因为 <code>2</code> 并不存在，这时返回 <code>404</code></p>
<p>​		<strong>4. POST localhost:8080/user 创建一个资源</strong></p>
<p>​		设置 <code>Content-Type=application/json</code></p>
<p>​		<strong>body:</strong></p>
<pre><code class="language-javascript">{
    &quot;userName&quot;: &quot;abcdfasdfe&quot;,
    &quot;password&quot;: &quot;abc&quot;,
    &quot;active&quot;: 1,
    &quot;lastLoginTime&quot;: null,
    &quot;createTime&quot;: null,
    &quot;updateTime&quot;: null
}
</code></pre>
<p>返回状态码 <code>201</code></p>
<p>返回数据：</p>
<pre><code class="language-javascript">{
    &quot;userName&quot;: &quot;abcdfasdfe&quot;,
    &quot;password&quot;: &quot;abc&quot;,
    &quot;active&quot;: 1,
    &quot;lastLoginTime&quot;: null,
    &quot;createTime&quot;: null,
    &quot;updateTime&quot;: null,
    &quot;_links&quot;: {
        &quot;self&quot;: {
            &quot;href&quot;: &quot;http://localhost:8080/user/4&quot;
        },
        &quot;user&quot;: {
            &quot;href&quot;: &quot;http://localhost:8080/user/4&quot;
        }
    }
}
</code></pre>
<p>​		<strong>5. 再次访问 GET 访问 localhost:8080/user</strong></p>
<p>​		这时可以看出 users 的数量为 2 说明已经创建成功</p>
<pre><code class="language-javascript">{
    &quot;_embedded&quot;: {
        &quot;users&quot;: [
            {
                &quot;userName&quot;: &quot;abc&quot;,
                &quot;password&quot;: &quot;abc&quot;,
                &quot;active&quot;: 1,
                &quot;lastLoginTime&quot;: null,
                &quot;createTime&quot;: null,
                &quot;updateTime&quot;: null,
                &quot;_links&quot;: {
                    &quot;self&quot;: {
                        &quot;href&quot;: &quot;http://localhost:8080/user/1&quot;
                    },
                    &quot;user&quot;: {
                        &quot;href&quot;: &quot;http://localhost:8080/user/1&quot;
                    }
                }
            },
            {
                &quot;userName&quot;: &quot;abcdfasdfe&quot;,
                &quot;password&quot;: &quot;abc&quot;,
                &quot;active&quot;: 1,
                &quot;lastLoginTime&quot;: null,
                &quot;createTime&quot;: null,
                &quot;updateTime&quot;: null,
                &quot;_links&quot;: {
                    &quot;self&quot;: {
                        &quot;href&quot;: &quot;http://localhost:8080/user/4&quot;
                    },
                    &quot;user&quot;: {
                        &quot;href&quot;: &quot;http://localhost:8080/user/4&quot;
                    }
                }
            }
        ]
    },
    &quot;_links&quot;: {
        &quot;self&quot;: {
            &quot;href&quot;: &quot;http://localhost:8080/user{?page,size,sort}&quot;,
            &quot;templated&quot;: true
        },
        &quot;profile&quot;: {
            &quot;href&quot;: &quot;http://localhost:8080/profile/user&quot;
        }
    },
    &quot;page&quot;: {
        &quot;size&quot;: 20,
        &quot;totalElements&quot;: 2,
        &quot;totalPages&quot;: 1,
        &quot;number&quot;: 0
    }
}
</code></pre>
<p>​		<strong>6. delete 访问 localhost:8080/user/1</strong></p>
<p>返回状态码： <code>204</code></p>
<p>再次访问 GET 访问 localhost:8080/user 会发现 users 的数量已经为1，说明已经删除成功</p>
<blockquote>
<p>可以使用 postman 测试，这里为了不贴图，就按上面的写了，希望理解</p>
</blockquote>
<p># 小功能</p>
<p>为了方便查看和测试api,可以集成 <code>hal browser</code></p>
<p>在 pom 文件添加依赖即可</p>
<pre><code class="language-javascript">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;
    &lt;artifactId&gt;spring-data-rest-hal-browser&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>重启项目并访问： <code>http://127.0.0.1:8080/browser/index.html#/</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 10 var 关键字深度解读]]></title>
        <id>https://cm940324.github.io/post/java10-var/</id>
        <link href="https://cm940324.github.io/post/java10-var/">
        </link>
        <updated>2021-04-22T02:39:38.000Z</updated>
        <content type="html"><![CDATA[<p>​		2018 年 3 月 21 日，Java 10 如约而至。虽然这一版本带来的特性并不是非常多，但其中有一项仍然成为大家关注的热点，它就是局部变量类型推断（JEP 286）。JEP 286 引入了 var，用于声明局部变量，例如：</p>
<pre><code>var users = new ArrayList&lt;User&gt;();
</code></pre>
<p>​		事情就是这么简单。不过，这篇文章将会讨论更多有关 var 的内容，比如什么时候可以用 var、什么时候不能用 var、var 对可读性的影响，以及为什么没有使用 val。</p>
<h3 id="使用-var-代替类型声明">使用 var 代替类型声明</h3>
<p>​		作为 Java 开发者，在声明一个变量时，我们总是习惯了敲打两次变量类型，第一次用于声明变量类型，第二次用于构造函数，比如：</p>
<pre><code>		URL codefx = new URL(&quot;http://codefx.org&quot;)
		URLConnection connection = codefx.openConnection();
		Reader reader = new BufferedReader(
  			new InputStreamReader(connection.getInputStream()));
</code></pre>
<p>​		URL codefx = new URL(&quot;http://codefx.org&quot;)`我们也经常声明一种变量，它只会被使用一次，而且是用在下一行代码中，比如：</p>
<pre><code>URL codefx = new URL(&quot;http://codefx.org&quot;)
URLConnection connection = codefx.openConnection();
Reader reader = new BufferedReader(
  new InputStreamReader(connection.getInputStream()));
</code></pre>
<p>​		这样也不算太糟糕，就是有点啰嗦。尽管 IDE 可以帮我们自动完成这些代码，但当变量总是跳来跳去的时候，可读性还是会受到影响，因为变量类型的名称由各种不同长度的字符组成。而且，有时候开发人员会尽力避免声明中间变量，因为太多的类型声明只会分散注意力，不会带来额外的好处。</p>
<p>​		从Java10开始,开发人员可以使用 var 让编译器自己去推断类型：</p>
<pre><code>	var codefx = new URL(&quot;http://codefx.org&quot;);
	var connection = codefx.openConnection();
  var reader = new BufferedReader(
  new InputStreamReader(connection.getInputStream()));
</code></pre>
<p>​		在处理 var 时，编译器先是查看表达式右边部分，也就是所谓的构造器，并将它作为变量的类型，然后将该类型写入字节码当中。</p>
<p>​		这样可以少敲几个字，但更重要的是，它避免了信息冗余，而且对齐了变量名，更容易阅读。当然，这也需要付出一点代价：有些变量，比如例子当中的 connection，就无法立即知道它是什么类型的。虽说 IDE 可以辅助显示出这些变量的类型，但在其他场景下可能就不行了，比如在代码评审的时候。</p>
<p>​		另外，你不需要担心变量名或方法名会与 var 发生冲突，因为 var 实际上并不是一个关键字，而是一个类型名，只有在编译器需要知道类型的地方才需要用到它。除此之外，它就是一个普通合法的标识符。也就是说，除了不能用它作为类名，其他的都可以，但极少人会用它作为类名。</p>
<p>​		局部变量类型推断是一个非常直观的特性，不过你可能会想：</p>
<ul>
<li>这到底是 Java 还是 JavaScript？</li>
<li>可以在哪些地方使用 var？</li>
<li>var 会影响可读性吗？</li>
<li>为什么没有 val 或 let？</li>
</ul>
<h2 id="不这不是-javascript">不，这不是 JavaScript</h2>
<p>​		首先我要说明的是，var 并不会改变 Java 是一门静态类型语言的事实。编译器负责推断出类型，并把结果写入字节码文件，就好像是开发人员自己敲入类型一样。</p>
<p>​		下面是使用 IntelliJ（实际上是 Fernflower 的反编译器）反编译器反编译出的代码：</p>
<pre><code>	URL codefx = new URL(&quot;http://codefx.org&quot;);
	URLConnection connection = codefx.openConnection();
	BufferedReader reader = new BufferedReader(
  new InputStreamReader(connection.getInputStream()));
</code></pre>
<p>​		从代码来看，就好像之前已经声明了这些类型一样。事实上，这一特性只发生在编译阶段，与运行时无关，所以对运行时的性能不会产生任何影响。所以请放心，这不是 JavaScript。</p>
<p>​		如果你仍然担心不显式声明类型会让代码变得更糟糕，那么我倒要问你了，你在使用 lambda 表达式的时候会声明参数的类型吗？</p>
<p>​		<mark><code>rhetoricalQuestion.answer(yes -&gt; &quot;see my point?&quot;);</code>## 哪些地方可以使用 var（或哪些地方不能使用 var）</mark></p>
<p>​		JEP 286 的标题“局部变量类型推断”就已经暗示了哪些地方可以使用 var：局部变量。更准确地说，是那些带有构造器的局部变量声明。但像这样的就不行了：</p>
<pre><code>	// 不行
	var foo;
	foo = &quot;Foo&quot;;
</code></pre>
<p>必须写成：</p>
<p><code>var foo = &quot;Foo&quot;;</code>除此之外，var 也不能用在“多元表达式”中，如 lambda 和方法引用：</p>
<pre><code>// 这些都不行
var ints = {0, 1, 2};
var appendSpace = a -&gt; a + &quot; &quot;;
var compareString = String::compareTo
</code></pre>
<p>除了局部变量，for 循环是唯一可以使用 var 的地方：</p>
<pre><code>var numbers = List.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
for (var nr : numbers)
  System.out.print(nr + &quot; &quot;);
for (var i = 0; i &lt; numbers.size(); i++)
  System.out.print(numbers.get(i) + &quot; &quot;);
</code></pre>
<p>也就是说，字段、方法签名和 catch 代码块仍然需要显式声明类型。</p>
<pre><code>// 这样也是不行的
private var getFoo() {
  return &quot;foo&quot;;
}
</code></pre>
<h2 id="避免action-at-a-distance错误">避免“Action At A Distance”错误</h2>
<p>​		将 var 限定在局部变量上并非技术方面的局限，而是设计上的决定。确实，如果能够像下面这样岂不更好？</p>
<pre><code>		// 编译器推断出类型 List&lt;User&gt;
		var users = new ArrayList&lt;User&gt;();
		// 这样就不行了，会出现编译错误
		users = new LinkedList&lt;&gt;();
</code></pre>
<p>​		按照预期，编译器应该能够找出最具体的那个类型，但实际上它不会。JDK 团队想要避免“Action At A Distance”错误（AAD），也就是说，他们希望在某处修改了代码不会影响到其他很“远”的地方。比如：</p>
<pre><code>	// id 被推推为`int`
	var id = 123;
	if (id &lt; 100) {
  	// 此处省略了很长的代码
  	// 调用了其他类的方法
	} else {
  	// 此处也省略了很长的代码
	}
</code></pre>
<p>​		现在，我们加入一行：</p>
<p>​		<code>id = &quot;124&quot;</code>这样会发生什么？if 代码块会抛出一个错误，因为 id 变成了字符串类型，所有不能使用小于号进行比较操作。这个错误距离代码修改的地方很“远”，而其根源就是因为对一个变量重新赋值。</p>
<p>​		这么看来，将类型推断限定在带有构造器的局部变量声明上是有它的道理的。</p>
<h2 id="为什么不推断字段和方法的类型">为什么不推断字段和方法的类型？</h2>
<p>​		字段和方法的作用域比局部变量大得多，所以更有可能出现 AAD 错误。在最糟糕的情况下，修改一个方法的参数类型可能导致二进制文件的不兼容和运行时错误。</p>
<p>​		因为非 private 的字段和方法是类契约的一部分，它们的类型不能通过推断来获得。不过，private 的字段和方法似乎可以使用类型推断，但问题是这样会让这个特性看起来非常奇怪。</p>
<p>​		局部变量属于实现细节，通常不会在很“远”的地方引用这些变量，所以就没有必要严格、显式和啰嗦地给它们声明类型了。</p>
<h2 id="为什么要使用-var">为什么要使用 var？</h2>
<p>​		相比其他年轻的编程语言，Java 代码的啰嗦是开发人员最大的痛点之一，也是饱受 Java 开发人员诟病的一个地方。为此，Amber 项目开发了 var，旨在“开发出一些小的 Java 语言特性，以便提高效率”，其目标是降低 Java 代码编写和阅读的繁琐程度。</p>
<p>​		局部变量类型推断正好迎合了这一目标。在编写代码时，声明变量的方式更简单了，尽管这类代码有大半可以使用 IDE 生成，或者使用 IDE 的重构功能进行修改。</p>
<p>​		除了让变量声明变得更简单，修改起来也很容易。这话怎么说？有些变量的类型真的很难看，比如那些带有泛型的企业级类名：</p>
<p>​</p>
<pre><code>InternationalCustomerOrderProcessor&gt; orderProcessor = 				createInternationalOrderProcessor(customer, order);`因为类型名称太长了，结果把变量名推到了代码的右边。如果限定了每行只能容纳 150 个字符，那么变量名还有可能被推到下一行显示。这些对于可读性来说都是一种伤害。

`var orderProcessor = createInternationalOrderProcessor(customer, order);`使用 var 就显得不那么累赘了，一眼就能看到头。
</code></pre>
<p>​		总之，使用 var 的意义不在于减少字符数量，而是为了不那么啰嗦和累赘。</p>
<h2 id="对可读性的影响">对可读性的影响</h2>
<p>​		现在让我们来讲讲可读性。确实，类型的缺失会让事情变得更糟糕，不是吗？一般来说，确实是的。在阅读代码时，类型是很重要的一个因素。尽管 IDE 可以帮助显示出推断的类型，但如果这些类型直接显示在代码中看起来不是更方便吗？</p>
<p>​		这是 var 在可读性方面的一个不足，不过，它却带来了另一个优势，那就是变量名对齐：</p>
<pre><code>	// 显式类型
	No no = new No();
	AmountIncrease&lt;BigDecimal&gt; more = new BigDecimalAmountIncrease();
	HorizontalConnection&lt;LinePosition, LinePosition&gt; jumping =
  	new HorizontalLinePositionConnection();
	Variable variable = new Constant(5);
	List&lt;String&gt; names = List.of(&quot;Max&quot;, &quot;Maria&quot;);
	// 推断类型
	var no = new No();
	var more = new BigDecimalAmountIncrease();
  var jumping = new HorizontalLinePositionConnection();
	var variable = new Constant(5);
	var names = List.of(&quot;Max&quot;, &quot;Maria&quot;);
</code></pre>
<p>​		虽说类型名称很重要，但好的变量名也是有过之而无不及。类型用于描述 Java 生态系统（JDK 的类）、一般场景（类库或框架）或业务领域（应用程序）的一般性概念，所以类型一般会有通用的名字。而变量名处在很小的上下文中，它们的名字应该要更精确一些。</p>
<p>​		这种可读性方面的改进可能会导致出现更多带有构造器的局部变量声明，因为这样在编写代码和阅读代码时会更加方便。</p>
<h2 id="为什么没有使用-valconstlet">为什么没有使用 val/const/let？</h2>
<p>​		其他很多使用了 var 的编程语言也会为不可变变量提供一个额外的关键字，比如 val、const 或 let。但 Java 10 没有使用这些关键字，所以我们必须使用 final var 来声明不可变变量。究其原因，可能是因为：</p>
<p>​		1.虽说不变性很重要,但对于局部变量来说,这种重要性程度没有那么高.</p>
<p>​		2.Java 8 引入了“隐式”final的概念,所以在我们看来,局部变量就已经是不可变的.</p>
<p>​		3.大部分人同意使用var（74% 的人强烈同意，12% 的人基本同意），而对 var/val 和 var/let 的反馈则显得有点含糊不清。</p>
<p>​		我同意前面两点，至于第三点只能勉强接受，但对结果还是感到有点失望。或许等到了有一天，我们不得不使用 final var 的时候，是不是可以考虑使用 val 或 let？</p>
<h2 id="总结">总结</h2>
<p>​		在声明局部变量时，可以使用 var 代替具体的类名或接口名，让编译器自己去推断变量的类型。当然，只有在声明并且立即初始化变量的情况下才能使用 var。for 循环中的下标也可以使用 var 来声明。编译器会把推断出来的类型写入字节码，不影响运行时。Java 仍然是一门静态类型的语言。</p>
<p>​		除了局部变量，var 不能被用于字段或方法上，这样做是为了避免 AAD 错误。</p>
<p>​		虽说 var 有可能让代码变得更糟，但作为 Java 开发者，应该尝试在变量声明和嵌套表达式或链式表达式之间做出权衡，写出可读性更高的代码。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring Security]]></title>
        <id>https://cm940324.github.io/post/spring-security/</id>
        <link href="https://cm940324.github.io/post/spring-security/">
        </link>
        <updated>2021-02-19T09:17:40.000Z</updated>
        <content type="html"><![CDATA[<p>Java 领域老牌的权限管理框架当属 Shiro 了。</p>
<p>Shiro 有着众多的优点，例如轻量、简单、易于集成等。</p>
<p>当然 Shiro 也有不足，例如对 OAuth2 支持不够，在 Spring Boot 面前无法充分展示自己的优势等等，特别是随着现在 Spring Boot 和 Spring Cloud 的流行，Spring Security 正在走向舞台舞台中央。</p>
<p>Spring Security 最早不叫 Spring Security ，叫 Acegi Security，叫 Acegi Security 并不是说它和 Spring 就没有关系了，它依然是为 Spring 框架提供安全支持的。事实上，Java 领域的框架，很少有框架能够脱离 Spring 框架独立存在。</p>
<p>Acegi Security 基于 Spring，可以帮助我们为项目建立丰富的角色与权限管理，但是最广为人诟病的则是它臃肿繁琐的配置，这一问题最终也遗传给了 Spring Security。</p>
<p>在 Acegi Security 时代，网上流传一句话：“每当有人要使用 Acegi Security，就会有一个精灵死去。”足见 Acegi Security 的配置是多么可怕。</p>
<p>当 Acegi Security 投入 Spring 怀抱之后，先把这个名字改了，这就是大家所见到的 Spring Security 了，然后配置也得到了极大的简化。</p>
<p>但是和 Shiro 相比，人们对 Spring Security 的评价依然中重量级、配置繁琐。</p>
<p>直到有一天 Spring Boot 像谜一般出现在江湖边缘，彻底颠覆了 JavaEE 的世界。一人得道鸡犬升天，Spring Security 也因此飞上枝头变凤凰。</p>
<p># <strong><strong>1.核心功能</strong></strong></p>
<p>对于一个权限管理框架而言，无论是 Shiro 还是 Spring Security，最最核心的功能，无非就是两方面：</p>
<p>```</p>
<p>​                  认证</p>
<p>​                  授权</p>
<p>```</p>
<p>通俗点说，认证就是我们常说的登录，授权就是权限鉴别，看看请求是否具备相应的权限。</p>
<p>虽然就是一个简简单单的登录，可是也能玩出很多花样来。</p>
<p>Spring Security 支持多种不同的认证方式，这些认证方式有的是 Spring Security 自己提供的认证功能，有的是第三方标准组织制订的，主要有如下一些：</p>
<p>一些比较常见的认证方式：</p>
<p>```</p>
<p>HTTP BASIC authentication headers：基于IETF RFC 标准。</p>
<p>HTTP Digest authentication headers：基于IETF RFC 标准。</p>
<p>HTTP X.509 client certificate exchange：基于IETF RFC 标准。</p>
<p>LDAP：跨平台身份验证。</p>
<p>Form-based authentication：基于表单的身份验证。</p>
<p>Run-as authentication：用户用户临时以某一个身份登录。</p>
<p>OpenID authentication：去中心化认证。</p>
<p>```</p>
<p>除了这些常见的认证方式之外，一些比较冷门的认证方式，Spring Security 也提供了支持。</p>
<p>```</p>
<p>Jasig Central Authentication Service：单点登录。</p>
<p>Automatic &quot;remember-me&quot; authentication：记住我登录（允许一些非敏感操作）。</p>
<p>Anonymous authentication：匿名登录。</p>
<p>......</p>
<p>```</p>
<p>作为一个开放的平台，Spring Security 提供的认证机制不仅仅是上面这些。如果上面这些认证机制依然无法满足你的需求，我们也可以自己定制认证逻辑。当我们需要和一些“老破旧”的系统进行集成时，自定义认证逻辑就显得非常重要了。</p>
<p>除了认证，剩下的就是授权了。</p>
<p>Spring Security 支持基于 URL 的请求授权、支持方法访问授权以及对象访问授权。</p>
<p># <strong><strong>2.基础入门</strong></strong></p>
<p>## <strong><strong>2.1. 新建项目</strong></strong></p>
<p>首先新建一个 Spring Boot 项目，创建时引入 Spring Security 依赖和 web 依赖，如下图：</p>
<figure data-type="image" tabindex="1"><img src="https://cm940324.github.io/post-images/1618997105251.webp" alt="" loading="lazy"></figure>
<p>项目创建成功后，Spring Security 的依赖就添加进来了，在 Spring Boot 中我们加入的是 spring-boot-starter-security ，其实主要是这两个：</p>
<figure data-type="image" tabindex="2"><img src="https://cm940324.github.io/post-images/1618997141497.webp" alt="" loading="lazy"></figure>
<p>项目创建成功后，我们添加一个测试的 HelloController，内容如下：</p>
<figure data-type="image" tabindex="3"><img src="https://cm940324.github.io/post-images/1618997324779.jpg" alt="" loading="lazy"></figure>
<p>接下来什么事情都不用做，我们直接来启动项目。</p>
<p>在项目启动过程中，我们会看到如下一行日志：</p>
<figure data-type="image" tabindex="4"><img src="https://cm940324.github.io/post-images/1618997378329.jpg" alt="" loading="lazy"></figure>
<p>这就是 Spring Security 为默认用户 user 生成的临时密码，是一个 UUID 字符串。</p>
<p>接下来我们去访问 http://localhost:8080/hello 接口，就可以看到自动重定向到登录页面了：</p>
<figure data-type="image" tabindex="5"><img src="https://cm940324.github.io/post-images/1618997430748.webp" alt="" loading="lazy"></figure>
<p>在登录页面，默认的用户名就是 user，默认的登录密码则是项目启动时控制台打印出来的密码，输入用户名密码之后，就登录成功了，登录成功后，我们就可以访问到 /hello 接口了。</p>
<p>在 Spring Security 中，默认的登录页面和登录接口，都是 /login ，只不过一个是 get 请求（登录页面），另一个是 post 请求（登录接口）。</p>
<p>大家可以看到，非常方便，一个依赖就保护了所有接口。</p>
<p>有人说，你怎么知道知道生成的默认密码是一个 UUID 呢？</p>
<p>这个其实很好判断。</p>
<p>和用户相关的自动化配置类在 UserDetailsServiceAutoConfiguration 里边，在该类的 getOrDeducePassword 方法中，我们看到如下一行日志：</p>
<figure data-type="image" tabindex="6"><img src="https://cm940324.github.io/post-images/1618997536347.png" alt="" loading="lazy"></figure>
<p>毫无疑问，我们在控制台看到的日志就是从这里打印出来的。打印的条件是 isPasswordGenerated 方法返回 true，即密码是默认生成的。</p>
<p>进而我们发现，user.getPassword 出现在 SecurityProperties 中，在 SecurityProperties 中我们看到如下定义：</p>
<figure data-type="image" tabindex="7"><img src="https://cm940324.github.io/post-images/1618997630300.jpg" alt="" loading="lazy"></figure>
<p>可以看到，默认的用户名就是 user，默认的密码则是 UUID，而默认情况下，passwordGenerated 也为 true。</p>
<p>## <strong><strong>2.2. 用户配置</strong></strong></p>
<p>默认的密码有一个问题就是每次重启项目都会变，这很不方便。</p>
<p>在正式介绍数据库连接之前，先和大家介绍两种非主流的用户名/密码配置方案。</p>
<p>### <strong><strong>2.2.1. 配置</strong></strong></p>
<p>我们可以在 application.properties 中配置默认的用户名密码。</p>
<p>怎么配置呢？大家还记得上一小节我们说的 SecurityProperties，默认的用户就定义在它里边，是一个静态内部类，我们如果要定义自己的用户名密码，必然是要去覆盖默认配置，我们先来看下 SecurityProperties 的定义：</p>
<figure data-type="image" tabindex="8"><img src="https://cm940324.github.io/post-images/1618997862541.png" alt="" loading="lazy"></figure>
<p>这就很清晰了，我们只需要以 spring.security.user 为前缀，去定义用户名密码即可：</p>
<figure data-type="image" tabindex="9"><img src="https://cm940324.github.io/post-images/1618997956875.png" alt="" loading="lazy"></figure>
<p>这就是我们新定义的用户名密码。</p>
<p>在 properties 中定义的用户名密码最终是通过 set 方法注入到属性中去的，这里我们顺便来看下 SecurityProperties.User #setPassword 方法:</p>
<figure data-type="image" tabindex="10"><img src="https://cm940324.github.io/post-images/1618999137418.png" alt="" loading="lazy"></figure>
<p>从这里我们可以看到，application.properties 中定义的密码在注入进来之后，还顺便设置了 passwordGenerated 属性为 false，这个属性设置为 false 之后，控制台就不会打印默认的密码了。</p>
<p>此时重启项目，就可以使用自己定义的用户名/密码登录了。</p>
<p>### <strong><strong>2.2.2. 配置类</strong></strong></p>
<p>除了上面的配置文件这种方式之外，我们也可以在配置类中配置用户名/密码。</p>
<p>在配置类中配置，我们就要指定 PasswordEncoder 了，这是一个非常关键的东西。</p>
<p>考虑到有的小伙伴对于 PasswordEncoder 还不太熟悉，因此，我这里先稍微给大家介绍一下 PasswordEncoder 到底是干嘛用的。要说 PasswordEncoder ，就得先说密码加密。</p>
<p>#### <strong><strong>2.2.2.1. 为什么要加密</strong></strong></p>
<p>2011 年 12 月 21 日，有人在网络上公开了一个包含 600 万个 CSDN 用户资料的数据库，数据全部为明文储存，包含用户名、密码以及注册邮箱。事件发生后 CSDN 在微博、官方网站等渠道发出了声明，解释说此数据库系 2009 年备份所用，因不明原因泄露，已经向警方报案，后又在官网发出了公开道歉信。在接下来的十多天里，金山、网易、京东、当当、新浪等多家公司被卷入到这次事件中。整个事件中最触目惊心的莫过于 CSDN 把用户密码明文存储，由于很多用户是多个网站共用一个密码，因此一个网站密码泄露就会造成很大的安全隐患。由于有了这么多前车之鉴，我们现在做系统时，密码都要加密处理。</p>
<p>这次泄密，也留下了一些有趣的事情，特别是对于广大程序员设置密码这一项。人们从 CSDN 泄密的文件中，发现了一些好玩的密码，例如如下这些：</p>
<p>- <code>ppnn13%dkstFeb.1st</code> 这段密码的中文解析是：娉娉袅袅十三余，豆蔻梢头二月初。</p>
<p>- <code>csbt34.ydhl12s</code> 这段密码的中文解析是：池上碧苔三四点，叶底黄鹂一两声</p>
<p>等等不一而足，你会发现很多程序员的人文素养还是非常高的，让人啧啧称奇。</p>
<p>#### <strong><strong>2.2.2.2. 加密方案</strong></strong></p>
<p>密码加密我们一般会用到散列函数，又称散列算法、哈希函数，这是一种从任何数据中创建数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来，然后将数据打乱混合，重新创建一个散列值。散列值通常用一个短的随机字母和数字组成的字符串来代表。好的散列函数在输入域中很少出现散列冲突。在散列表和数据处理中，不抑制冲突来区别数据，会使得数据库记录更难找到。我们常用的散列函数有 MD5 消息摘要算法、安全散列算法（Secure Hash Algorithm）。</p>
<p>但是仅仅使用散列函数还不够，为了增加密码的安全性，一般在密码加密过程中还需要加盐，所谓的盐可以是一个随机数也可以是用户名，加盐之后，即使密码明文相同的用户生成的密码密文也不相同，这可以极大的提高密码的安全性。但是传统的加盐方式需要在数据库中有专门的字段来记录盐值，这个字段可能是用户名字段（因为用户名唯一），也可能是一个专门记录盐值的字段，这样的配置比较繁琐。</p>
<p>不同于 Shiro 中需要自己处理密码加盐，在 Spring Security 中，BCryptPasswordEncoder 就自带了盐，处理起来非常方便。</p>
<p>而 BCryptPasswordEncoder 就是 PasswordEncoder 接口的实现类。</p>
<p>#### <strong><strong>2.2.2.3. PasswordEncoder</strong></strong></p>
<figure data-type="image" tabindex="11"><img src="https://cm940324.github.io/post-images/1619005005813.png" alt="" loading="lazy"></figure>
<p>\1. encode 方法用来对明文密码进行加密，返回加密之后的密文。</p>
<p>\2. matches 方法是一个密码校对方法，在用户登录的时候，将用户传来的明文密码和数据库中保存的密文密码作为参数，传入到这个方法中去，根据返回的 Boolean 值判断用户密码是否输入正确。</p>
<p>\3. upgradeEncoding 是否还要进行再次加密，这个一般来说就不用了。</p>
<p>通过下图我们可以看到 PasswordEncoder 的实现类：</p>
<figure data-type="image" tabindex="12"><img src="https://cm940324.github.io/post-images/1619005134025.webp" alt="" loading="lazy"></figure>
<p>#### <strong><strong>2.2.2.3. PasswordEncoder</strong></strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SQL 语句性能优化策略]]></title>
        <id>https://cm940324.github.io/post/sql-yu-ju-xing-neng-you-hua-ce-lue/</id>
        <link href="https://cm940324.github.io/post/sql-yu-ju-xing-neng-you-hua-ce-lue/">
        </link>
        <updated>2021-01-15T00:47:15.000Z</updated>
        <content type="html"><![CDATA[<p>1、对查询进行优化，应尽量避免全表扫描，首先应考虑在where及order by涉及的列上建立索引。</p>
<p>2、应尽量避免在where子句中对字段进行null值判断，创建表时NULL是默认值，但大多数时候应该使用NOT NULL，或者使用一个特殊的值，如0，-1作为默认值。</p>
<p>3、应尽量避免在where子句中使用!=或&lt;&gt;操作符，MySQL只有对以下操作符才使用索引：&lt;，&lt;=，=，&gt;，&gt;=，BETWEEN，IN，以及某些时候的LIKE。</p>
<p>4、应尽量避免在where子句中使用or来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，可以使用UNION合并查询：select id from t where num=10 union all select id from t where num=20。</p>
<p>5、in和not in也要慎用，否则会导致全表扫描，对于连续的数值，能用between就不要用in了：Select id from t where num between 1 and 3。</p>
<p>6、下面的查询也将导致全表扫描：select id from t where name like‘%abc%’或者select id from t where name like‘%abc’若要提高效率，可以考虑全文检索。而select id from t where name like‘abc%’才用到索引。</p>
<p>7、如果在where子句中使用参数，也会导致全表扫描。</p>
<p>8、应尽量避免在where子句中对字段进行表达式操作，应尽量避免在where子句中对字段进行函数操作。</p>
<p>9、很多时候用exists代替in是一个好的选择：select num from a where num in(select num from b)。用下面的语句替换：select num from a where exists(select 1 from b where num=a.num)。</p>
<p>10、索引固然可以提高相应的select的效率，但同时也降低了insert及update的效率，因为insert或update时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。关于索引可以关注公众号Java技术栈搜索阅读更多详细教程。</p>
<p>11、应尽可能的避免更新clustered索引数据列， 因为clustered索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新clustered索引数据列，那么需要考虑是否应将该索引建为clustered索引。</p>
<p>12、尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。</p>
<p>13、尽可能的使用varchar/nvarchar代替char/nchar，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p>
<p>14、最好不要使用”“返回所有：select from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。具体可以阅读《别再 select * 了》这篇文章。</p>
<p>15、尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。</p>
<p>16、使用表的别名(Alias)：当在SQL语句中连接多个表时，请使用表的别名并把别名前缀于每个Column上。这样一来，就可以减少解析的时间并减少那些由Column歧义引起的语法错误。</p>
<p>17、使用“临时表”暂存中间结果 ：</p>
<p>简化SQL语句的重要方法就是采用临时表暂存中间结果，但是临时表的好处远远不止这些，将临时结果暂存在临时表，后面的查询就在tempdb中了，这可以避免程序中多次扫描主表，也大大减少了程序执行中“共享锁”阻塞“更新锁”，减少了阻塞，提高了并发性能。</p>
<p>18、一些SQL查询语句应加上nolock，读、写是会相互阻塞的，为了提高并发性能，对于一些查询，可以加上nolock，这样读的时候可以允许写，但缺点是可能读到未提交的脏数据。</p>
<p>使用nolock有3条原则：</p>
<p>查询的结果用于“插、删、改”的不能加nolock；<br>
查询的表属于频繁发生页分裂的，慎用nolock ；<br>
使用临时表一样可以保存“数据前影”，起到类似Oracle的undo表空间的功能，能采用临时表提高并发性能的，不要用nolock。</p>
<p>19、常见的简化规则如下：</p>
<p>不要有超过5个以上的表连接（JOIN），考虑使用临时表或表变量存放中间结果。少用子查询，视图嵌套不要过深，一般视图嵌套不要超过2个为宜。</p>
<p>20、将需要查询的结果预先计算好放在表中，查询的时候再Select。这在SQL7.0以前是最重要的手段，例如医院的住院费计算。</p>
<p>21、用OR的字句可以分解成多个查询，并且通过UNION 连接多个查询。他们的速度只同是否使用索引有关，如果查询需要用到联合索引，用UNION all执行的效率更高。多个OR的字句没有用到索引，改写成UNION的形式再试图与索引匹配。一个关键的问题是否用到索引。</p>
<p>22、在IN后面值的列表中，将出现最频繁的值放在最前面，出现得最少的放在最后面，减少判断的次数。</p>
<p>23、尽量将数据的处理工作放在服务器上，减少网络的开销，如使用存储过程。</p>
<p>存储过程是编译好、优化过、并且被组织到一个执行规划里、且存储在数据库中的SQL语句，是控制流语言的集合，速度当然快。反复执行的动态SQL，可以使用临时存储过程，该过程（临时表）被放在Tempdb中。</p>
<p>24、当服务器的内存够多时，配制线程数量 = 最大连接数+5，这样能发挥最大的效率；否则使用 配制线程数量&lt;最大连接数启用SQL SERVER的线程池来解决，如果还是数量 = 最大连接数+5，严重的损害服务器的性能。</p>
<p>25、查询的关联同写的顺序 ：</p>
<p>select a.personMemberID, * from chineseresume a,personmember b where personMemberID = b.referenceid and a.personMemberID = ‘JCNPRH39681’ （A = B ,B = ‘号码’）</p>
<p>select a.personMemberID, * from chineseresume a,personmember b where a.personMemberID = b.referenceid and a.personMemberID = ‘JCNPRH39681’ and b.referenceid = ‘JCNPRH39681’ （A = B ,B = ‘号码’， A = ‘号码’）</p>
<p>select a.personMemberID, * from chineseresume a,personmember b where b.referenceid = ‘JCNPRH39681’ and a.personMemberID = ‘JCNPRH39681’ （B = ‘号码’， A = ‘号码’）</p>
<p>26、尽量使用exists代替select count(1)来判断是否存在记录，count函数只有在统计表中所有行数时使用，而且count(1)比count(*)更有效率。</p>
<p>27、尽量使用“&gt;=”，不要使用“&gt;”。</p>
<p>28、索引的使用规范：</p>
<p>索引的创建要与应用结合考虑，建议大的OLTP表不要超过6个索引；<br>
尽可能的使用索引字段作为查询条件，尤其是聚簇索引，必要时可以通过index index_name来强制指定索引；<br>
避免对大表查询时进行table scan，必要时考虑新建索引；<br>
在使用索引字段作为条件时，如果该索引是联合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用；<br>
要注意索引的维护，周期性重建索引，重新编译存储过程。</p>
<p>29、下列SQL条件语句中的列都建有恰当的索引，但执行速度却非常慢：</p>
<p>SELECT * FROM record WHERE substrINg(card_no,1,4)=’5378’ (13秒)</p>
<p>SELECT * FROM record WHERE amount/30&lt; 1000 （11秒）</p>
<p>SELECT * FROM record WHERE convert(char(10),date,112)=’19991201’ （10秒）</p>
<p>分析：</p>
<p>WHERE子句中对列的任何操作结果都是在SQL运行时逐列计算得到的，因此它不得不进行表搜索，而没有使用该列上面的索引。</p>
<p>如果这些结果在查询编译时就能得到，那么就可以被SQL优化器优化，使用索引，避免表搜索，因此将SQL重写成下面这样：</p>
<p>SELECT * FROM record WHERE card_no like ‘5378%’ （&lt; 1秒）</p>
<p>SELECT * FROM record WHERE amount&lt; 1000*30 （&lt; 1秒）</p>
<p>SELECT * FROM record WHERE date= ‘1999/12/01’ （&lt; 1秒）</p>
<p>30、当有一批处理的插入或更新时，用批量插入或批量更新，绝不会一条条记录的去更新。批量插入的方法请关注公众号Java技术栈然后搜索阅读。</p>
<p>31、在所有的存储过程中，能够用SQL语句的，我绝不会用循环去实现。<br>
例如：列出上个月的每一天，我会用connect by去递归查询一下，绝不会去用循环从上个月第一天到最后一天。</p>
<p>32、选择最有效率的表名顺序（只在基于规则的优化器中有效）：</p>
<p>Oracle的解析器按照从右到左的顺序处理FROM子句中的表名，FROM子句中写在最后的表（基础表 driving table）将被最先处理，在FROM子句中包含多个表的情况下，你必须选择记录条数最少的表作为基础表。</p>
<p>如果有3个以上的表连接查询，那就需要选择交叉表（intersection table）作为基础表，交叉表是指那个被其他表所引用的表。</p>
<p>33、提高GROUP BY语句的效率，可以通过将不需要的记录在GROUP BY之前过滤掉。下面两个查询返回相同结果，但第二个明显就快了许多。</p>
<p>低效：</p>
<p>SELECT JOB , AVG(SAL)<br>
FROM EMP<br>
GROUP BY JOB<br>
HAVING JOB =’PRESIDENT’<br>
OR JOB =’MANAGER’</p>
<p>高效:</p>
<p>SELECT JOB , AVG(SAL)<br>
FROM EMP<br>
WHERE JOB =’PRESIDENT’<br>
OR JOB =’MANAGER’<br>
GROUP BY JOB</p>
<p>34、SQL语句用大写，因为Oracle总是先解析SQL语句，把小写的字母转换成大写的再执行。</p>
<p>35、别名的使用，别名是大型数据库的应用技巧，就是表名、列名在查询中以一个字母为别名，查询速度要比建连接表快1.5倍。</p>
<p>36、避免死锁，在你的存储过程和触发器中访问同一个表时总是以相同的顺序；事务应经可能地缩短，在一个事务中应尽可能减少涉及到的数据量；永远不要在事务中等待用户输入。</p>
<p>37、避免使用临时表，除非却有需要，否则应尽量避免使用临时表，相反，可以使用表变量代替；大多数时候(99%)，表变量驻扎在内存中，因此速度比临时表更快，临时表驻扎在TempDb数据库中，因此临时表上的操作需要跨数据库通信，速度自然慢。</p>
<p>38、最好不要使用触发器：</p>
<p>触发一个触发器，执行一个触发器事件本身就是一个耗费资源的过程；<br>
如果能够使用约束实现的，尽量不要使用触发器；<br>
不要为不同的触发事件(Insert，Update和Delete)使用相同的触发器；<br>
不要在触发器中使用事务型代码。</p>
<p>39、索引创建规则：</p>
<p>表的主键、外键必须有索引；<br>
数据量超过300的表应该有索引；<br>
经常与其他表进行连接的表，在连接字段上应该建立索引；<br>
经常出现在Where子句中的字段，特别是大表的字段，应该建立索引；<br>
索引应该建在选择性高的字段上；<br>
索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；<br>
复合索引的建立需要进行仔细分析，尽量考虑用单字段索引代替；<br>
正确选择复合索引中的主列字段，一般是选择性较好的字段；<br>
复合索引的几个字段是否经常同时以AND方式出现在Where子句中？单字段查询是否极少甚至没有？如果是，则可以建立复合索引；否则考虑单字段索引；<br>
如果复合索引中包含的字段经常单独出现在Where子句中，则分解为多个单字段索引；<br>
如果复合索引所包含的字段超过3个，那么仔细考虑其必要性，考虑减少复合的字段；<br>
如果既有单字段索引，又有这几个字段上的复合索引，一般可以删除复合索引；<br>
频繁进行数据操作的表，不要建立太多的索引；<br>
删除无用的索引，避免对执行计划造成负面影响；<br>
表上建立的每个索引都会增加存储开销，索引对于插入、删除、更新操作也会增加处理上的开销。另外，过多的复合索引，在有单字段索引的情况下，一般都是没有存在价值的；相反，还会降低数据增加删除时的性能，特别是对频繁更新的表来说，负面影响更大。<br>
尽量不要对数据库中某个含有大量重复的值的字段建立索引。MySQL开发 36 条军规，推荐看下。</p>
<p>40、MySQL查询优化总结：</p>
<p>使用慢查询日志去发现慢查询，使用执行计划去判断查询是否正常运行，总是去测试你的查询看看是否他们运行在最佳状态下。关注公众号Java技术栈回复面试，可以获取 MySQL 及更多面试题。</p>
<p>久而久之性能总会变化，避免在整个表上使用count(*)，它可能锁住整张表，使查询保持一致以便后续相似的查询可以使用查询缓存，在适当的情形下使用GROUP BY而不是DISTINCT，在WHERE、GROUP BY和ORDER BY子句中使用有索引的列，保持索引简单，不在多个索引中包含同一个列。</p>
<p>有时候MySQL会使用错误的索引，对于这种情况使用USE INDEX，检查使用SQL_MODE=STRICT的问题，对于记录数小于5的索引字段，在UNION的时候使用LIMIT不是是用OR。</p>
<p>为了避免在更新前SELECT，使用INSERT ON DUPLICATE KEY或者INSERT IGNORE，不要用UPDATE去实现，不要使用MAX，使用索引字段和ORDER BY子句，LIMIT M，N实际上可以减缓查询在某些情况下，有节制地使用，在WHERE子句中使用UNION代替子查询，在重新启动的MySQL，记得来温暖你的数据库，以确保数据在内存和查询速度快，考虑持久连接，而不是多个连接，以减少开销。</p>
<p>基准查询，包括使用服务器上的负载，有时一个简单的查询可以影响其他查询，当负载增加在服务器上，使用SHOW PROCESSLIST查看慢的和有问题的查询，在开发环境中产生的镜像数据中测试的所有可疑的查询。</p>
<p>41、MySQL备份过程：</p>
<p>从二级复制服务器上进行备份；<br>
在进行备份期间停止复制，以避免在数据依赖和外键约束上出现不一致；<br>
彻底停止MySQL，从数据库文件进行备份；<br>
如果使用MySQL dump进行备份，请同时备份二进制日志文件 – 确保复制没有中断；<br>
不要信任LVM快照，这很可能产生数据不一致，将来会给你带来麻烦；<br>
为了更容易进行单表恢复，以表为单位导出数据——如果数据是与其他表隔离的。<br>
当使用mysqldump时请使用–opt；<br>
在备份之前检查和优化表；<br>
为了更快的进行导入，在导入时临时禁用外键约束。；<br>
为了更快的进行导入，在导入时临时禁用唯一性检测；<br>
在每一次备份后计算数据库，表以及索引的尺寸，以便更够监控数据尺寸的增长；<br>
通过自动调度脚本监控复制实例的错误和延迟；<br>
定期执行备份。</p>
<p>42、查询缓冲并不自动处理空格，因此，在写SQL语句时，应尽量减少空格的使用，尤其是在SQL首和尾的空格（因为查询缓冲并不自动截取首尾空格）。</p>
<p>43、member用mid做标准进行分表方便查询么？一般的业务需求中基本上都是以username为查询依据，正常应当是username做hash取模来分表。</p>
<p>而分表的话MySQL的partition功能就是干这个的，对代码是透明的；在代码层面去实现貌似是不合理的。</p>
<p>44、我们应该为数据库里的每张表都设置一个ID做为其主键，而且最好的是一个INT型的（推荐使用UNSIGNED），并设置上自动增加的AUTO_INCREMENT标志。</p>
<p>45、在所有的存储过程和触发器的开始处设置SET NOCOUNT ON，在结束时设置SET NOCOUNT OFF。无需在执行存储过程和触发器的每个语句后向客户端发送DONE_IN_PROC消息。</p>
<p>46、MySQL查询可以启用高速查询缓存。这是提高数据库性能的有效MySQL优化方法之一。当同一个查询被执行多次时，从缓存中提取数据和直接从数据库中返回数据快很多。</p>
<p>47、EXPLAIN SELECT查询用来跟踪查看效果：</p>
<p>使用EXPLAIN关键字可以让你知道MySQL是如何处理你的SQL语句的。这可以帮你分析你的查询语句或是表结构的性能瓶颈。EXPLAIN的查询结果还会告诉你你的索引主键被如何利用的，你的数据表是如何被搜索和排序的。</p>
<p>48、当只要一行数据时使用LIMIT 1 ：</p>
<p>当你查询表的有些时候，你已经知道结果只会有一条结果，但因为你可能需要去fetch游标，或是你也许会去检查返回的记录数。</p>
<p>在这种情况下，加上LIMIT 1可以增加性能。这样一来，MySQL数据库引擎会在找到一条数据后停止搜索，而不是继续往后查少下一条符合记录的数据。</p>
<p>49、选择表合适存储引擎：</p>
<p>myisam：应用时以读和插入操作为主，只有少量的更新和删除，并且对事务的完整性，并发性要求不是很高的。<br>
InnoDB：事务处理，以及并发条件下要求数据的一致性。除了插入和查询外，包括很多的更新和删除。（InnoDB有效地降低删除和更新导致的锁定）。<br>
对于支持事务的InnoDB类型的表来说，影响速度的主要原因是AUTOCOMMIT默认设置是打开的，而且程序没有显式调用BEGIN 开始事务，导致每插入一条都自动提交，严重影响了速度。可以在执行SQL前调用begin，多条SQL形成一个事物（即使autocommit打开也可以），将大大提高性能。</p>
<p>50、优化表的数据类型，选择合适的数据类型：</p>
<p>原则：更小通常更好，简单就好，所有字段都得有默认值，尽量避免null。</p>
<p>例如：数据库表设计时候更小的占磁盘空间尽可能使用更小的整数类型。(mediumint就比int更合适)</p>
<p>比如时间字段：datetime和timestamp，datetime占用8个字节，而timestamp占用4个字节，只用了一半，而timestamp表示的范围是1970—2037适合做更新时间</p>
<p>MySQL可以很好的支持大数据量的存取，但是一般说来，数据库中的表越小，在它上面执行的查询也就会越快。</p>
<p>因此，在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度设得尽可能小。</p>
<p>例如：在定义邮政编码这个字段时，如果将其设置为CHAR(255)，显然给数据库增加了不必要的空间。甚至使用VARCHAR这种类型也是多余的，因为CHAR(6)就可以很好的完成任务了。</p>
<p>同样的，如果可以的话，我们应该使用MEDIUMINT而不是BIGIN来定义整型字段，应该尽量把字段设置为NOT NULL，这样在将来执行查询的时候，数据库不用去比较NULL值。</p>
<p>对于某些文本字段，例如“省份”或者“性别”，我们可以将它们定义为ENUM类型。因为在MySQL中，ENUM类型被当作数值型数据来处理，而数值型数据被处理起来的速度要比文本类型快得多。这样，我们又可以提高数据库的性能。</p>
<p>51、字符串数据类型：char，varchar，text选择区别。</p>
<p>52、任何对列的操作都将导致表扫描，它包括数据库函数、计算表达式等等，查询时要尽可能将操作移至等号右边。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于]]></title>
        <id>https://cm940324.github.io/post/about/</id>
        <link href="https://cm940324.github.io/post/about/">
        </link>
        <updated>2019-01-25T11:09:48.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://cm940324.github.io/post-images/1618881224746.jpeg" alt="" loading="lazy"><br>
JAVA PROGRAMMER👨‍💻</p>
]]></content>
    </entry>
</feed>