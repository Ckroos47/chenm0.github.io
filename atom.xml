<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://cm940324.github.io</id>
    <title>Oasis</title>
    <updated>2021-06-07T07:01:12.945Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://cm940324.github.io"/>
    <link rel="self" href="https://cm940324.github.io/atom.xml"/>
    <subtitle>&lt;a href=&quot;https://cm940324.github.io/&quot; target=&quot;_blank&quot;&gt;code blog&lt;/a&gt;</subtitle>
    <logo>https://cm940324.github.io/images/avatar.png</logo>
    <icon>https://cm940324.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Oasis</rights>
    <entry>
        <title type="html"><![CDATA[微服务：服务注册发现+ API 网关+配置中心+配置中心+服务跟踪]]></title>
        <id>https://cm940324.github.io/post/weifuwu-ques/</id>
        <link href="https://cm940324.github.io/post/weifuwu-ques/">
        </link>
        <updated>2021-06-07T07:00:17.000Z</updated>
        <content type="html"><![CDATA[<p><strong>服务注册发现</strong></p>
<p>服务注册就是维护一个登记簿，它管理系统内所有的服务地址。当新的服务启动后，它会向登记簿交待自己的地址信息。服务的依赖方直接向登记簿要 Service Provider 地址就行了。当下用于服务注册的工具非常多 ZooKeeper，Consul，Etcd, 还有 Netflix 家的 eureka 等。服务注册有两种:</p>
<p><strong>形式：客户端注册和第三方注册。</strong></p>
<p><strong>客户端注册（zookeeper</strong>）<br>
客户端注册是服务自身要负责注册与注销的工作。当服务启动后向注册中心注册自身，当服务下线时注销自己。期间还需要和注册中心保持心跳。心跳不一定要客户端来做，也可以由注册中心负责（这个过程叫探活）。这种方式的缺点是注册工作与服务耦合在一起，不同语言都要实现一套注册逻辑。</p>
<p><strong>第三方注册（独立的服务 Registrar）</strong></p>
<p>第三方注册由一个独立的服务Registrar负责注册与注销。当服务启动后以某种方式通知Registrar，然后 Registrar 负责向注册中心发起注册工作。同时注册中心要维护与服务之间的心跳，当服务不可用时，向注册中心注销服务。这种方式的缺点是 Registrar 必须是一个高可用的系统则注册工作没法进展。</p>
<p><strong>客户端发现</strong></p>
<p>客户端发现是指客户端负责查询可用服务地址，以及负载均衡的工作。这种方式最方便直接，而且也方便做负载均衡。再者一旦发现某个服务不可用立即换另外一个，非常直接。缺点也在于多语言时的重复工作，每个语言实现相同的逻辑。</p>
<p><strong>服务端发现</strong></p>
<p>服务端发现需要额外的 Router 服务，请求先打到 Router，然后 Router 负责查询服务与负载均衡。这种方式虽然没有客户端发现的缺点，但是它的缺点是保证 Router 的高可用。</p>
<p><strong>API 网关</strong><br>
API Gateway 是一个服务器，也可以说是进入系统的唯一节点。这跟面向对象设计模式中的<br>
Facade 模式很像。API Gateway 封装内部系统的架构，并且提供 API 给各个客户端。它还可能有其他功能，如授权、监控、负载均衡、缓存、请求分片和管理、静态响应处理等。下图展示了一个适应当前架构的 API Gateway。<br>
API Gateway 负责请求转发、合成和协议转换。所有来自客户端的请求都要先经过 API Gateway，然后路由这些请求到对应的微服务。API Gateway 将经常通过调用多个微服务来处理一个请求以及聚合多个服务的结果。它可以在 web 协议与内部使用的非 Web 友好型协议间进行转换，如HTTP 协议、WebSocket 协议。</p>
<p><strong>请求转发</strong></p>
<p>服务转发主要是对客户端的请求安装微服务的负载转发到不同的服务上</p>
<p><strong>响应合并</strong></p>
<p>把业务上需要调用多个服务接口才能完成的工作合并成一次调用对外统一提供服务。</p>
<p><strong>协议转换</strong></p>
<p>重点是支持 SOAP，JMS，Rest 间的协议转换。</p>
<p><strong>数据转换</strong></p>
<p>重点是支持 XML 和 Json 之间的报文格式转换能力（可选）</p>
<p><strong>安全认证</strong></p>
<ol>
<li>
<p>基于 Token 的客户端访问控制和安全策略</p>
</li>
<li>
<p>传输数据和报文加密，到服务端解密，需要在客户端有独立的 SDK 代理包</p>
</li>
<li>
<p>基于 Https 的传输加密，客户端和服务端数字证书支持</p>
</li>
<li>
<p>基于 OAuth2.0 的服务安全认证(授权码，客户端，密码模式等）</p>
</li>
</ol>
<p><strong>配置中心</strong><br>
配置中心一般用作系统的参数配置，它需要满足如下几个要求：高效获取、实时感知、分布式访问。</p>
<p><strong>zookeeper 配置中心</strong></p>
<p>采取数据加载到内存方式解决高效获取的问题，借助 zookeeper 的节点监听机制来实现实时感知。</p>
<p><strong>事件调度（kafka）</strong><br>
消息服务和事件的统一调度，常用用 kafka ，activemq 等。</p>
<p><strong>服务跟踪（starter-sleuth）</strong></p>
<p>随着微服务数量不断增长，需要跟踪一个请求从一个微服务到下一个微服务的传播过程， SpringCloud Sleuth 正是解决这个问题，它在日志中引入唯一 ID，以保证微服务调用之间的一致性，这样你就能跟踪某个请求是如何从一个微服务传递到下一个。</p>
<ol>
<li>
<p>为了实现请求跟踪，当请求发送到分布式系统的入口端点时，只需要服务跟踪框架为该请求创建一个唯一的跟踪标识，同时在分布式系统内部流转的时候，框架始终保持传递该唯一标识，直到返回给请求方为止，这个唯一标识就是前文中提到的 Trace ID。通过 Trace ID 的记录，我们就能将所有请求过程日志关联起来。</p>
</li>
<li>
<p>为了统计各处理单元的时间延迟，当请求达到各个服务组件时，或是处理逻辑到达某个状态时，也通过一个唯一标识来标记它的开始、具体过程以及结束，该标识就是我们前文中提到的 Span ID，对于每个 Span 来说，它必须有开始和结束两个节点，通过记录开始 Span 和结束 Span 的时间戳，就能统计出该 Span 的时间延迟，除了时间戳记录之外，它还可以包含一些其他元数据，比如：事件名称、请求信息等。</p>
</li>
<li>
<p>在快速入门示例中，我们轻松实现了日志级别的跟踪信息接入，这完全归功于spring-cloudstarter-sleuth 组件的实现。在 Spring Boot 应用中，通过在工程中引入 spring-cloud<br>
starter-sleuth 依赖之后， 它会自动的为当前应用构建起各通信通道的跟踪机制，比如：</p>
</li>
</ol>
<ul>
<li>通过诸如 RabbitMQ、Kafka（或者其他任何 Spring Cloud Stream 绑定器实现的消息<br>
中间件）传递的请求。</li>
<li>通过 Zuul 代理传递的请求。</li>
<li>通过 RestTemplate 发起的请求。</li>
</ul>
<p><strong>服务熔断（Hystrix）</strong><br>
在微服务架构中通常会有多个服务层调用，基础服务的故障可能会导致级联故障，进而造成整个系统不可用的情况，这种现象被称为服务雪崩效应。服务雪崩效应是一种因“服务提供者”的不可用导致“服务消费者”的不可用,并将不可用逐渐放大的过程。</p>
<p>熔断器的原理很简单，如同电力过载保护器。它可以实现快速失败，如果它在一段时间内侦测到许多类似的错误，会强迫其以后的多个调用快速失败，不再访问远程服务器，从而防止应用程序</p>
<p>不断地尝试执行可能会失败的操作，使得应用程序继续执行而不用等待修正错误，或者浪费 CPU时间去等到长时间的超时产生。熔断器也可以使应用程序能够诊断错误是否已经修正，如果已经修正，应用程序会再次尝试调用操作。</p>
<p><strong>Hystrix 断路器机制</strong></p>
<p>断路器很好理解, 当 Hystrix Command 请求后端服务失败数量超过一定比例(默认 50%), 断路器会切换到开路状态(Open). 这时所有请求会直接失败而不会发送到后端服务. 断路器保持在开路状态一段时间后(默认 5 秒), 自动切换到半开路状态(HALF-OPEN). 这时会判断下一次请求的返回情况,</p>
<p>如果请求成功, 断路器切回闭路状态(CLOSED), 否则重新切换到开路状态(OPEN). Hystrix 的断路器就像我们家庭电路中的保险丝, 一旦后端服务不可用, 断路器会直接切断请求链, 避免发送大量无效请求影响系统吞吐量, 并且断路器有自我检测并恢复的能力。</p>
<p><strong>API 管理</strong></p>
<p>SwaggerAPI 管理工具。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[hibernate CascadeType属性说明]]></title>
        <id>https://cm940324.github.io/post/hibernate-cascadetype/</id>
        <link href="https://cm940324.github.io/post/hibernate-cascadetype/">
        </link>
        <updated>2021-06-07T06:31:17.000Z</updated>
        <content type="html"><![CDATA[<h3 id="cascade属性-指定级联操作的行为可多选">cascade属性： 指定级联操作的行为(可多选)</h3>
<ul>
<li><strong>CascadeType.PERSIST 级联新增（又称级联保存）：</strong><br>
获取A对象里也同时也重新获取最新的B时的对象。即会重新查询数据库里的最新数据，并且，只有A类新增时，会级联B对象新增。若B对象在数据库存（跟新）在则抛异常（让B变为持久态），对应EntityManager的presist方法,调用JPA规范中的persist()，不适用于Hibernate的save()方法</li>
<li><strong>CascadeType.MERGE 级联合并（又称级联更新）</strong><br>
指A类新增或者变化，会级联B对象（新增或者变化） ，对应EntityManager的merge方法，调用JPA规范中merge()时，不适用于Hibernate的update()方法</li>
<li><strong>CascadeType.REMOVE 级联删除</strong><br>
只有A类删除时，会级联删除B类,即在设置的那一端进行删除时，另一端才会级联删除，对应EntityManager的remove方法，调用JPA规范中的remove()时，适用于Hibernate的delete()方法</li>
<li><strong>CascadeType.REFRESH 级联刷新</strong><br>
获取order（一或多）对象里也同时也重新获取最新的items（多）的对象，对应EntityManager的refresh(object)，调用JPA规范中的refresh()时，适用于Hibernate的flush()方法</li>
<li><strong>CascadeType.ALL</strong><br>
包含所有持久化方法</li>
</ul>
<p><strong>综上：大多数情况用CascadeType.MERGE就能达到级联跟新又不报错，用CascadeType.ALL时要斟酌下CascadeType.REMOVE</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PostgreSQL踩坑记录]]></title>
        <id>https://cm940324.github.io/post/postgresql-ques/</id>
        <link href="https://cm940324.github.io/post/postgresql-ques/">
        </link>
        <updated>2021-06-03T06:26:03.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>在进行数据库记录的迁移和复制数据后容易出现错误</li>
</ol>
<pre><code>DETAIL:  Key (id)=(1) already exists
</code></pre>
<p>解决方案：</p>
<pre><code>select setval('tablename_id_seq', max(id)) from tablename;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式的通俗理解]]></title>
        <id>https://cm940324.github.io/post/shejimoshi-tongsu/</id>
        <link href="https://cm940324.github.io/post/shejimoshi-tongsu/">
        </link>
        <updated>2021-05-27T00:56:09.000Z</updated>
        <content type="html"><![CDATA[<h3 id="工厂方法">工厂方法</h3>
<p>追 MM 少不了请吃饭了，麦当劳的鸡翅和肯德基的鸡翅都是 MM 爱吃的东西，虽然口味有所不同，但不管你带 MM 去麦当劳或肯德基，只管向服务员说「来四个鸡翅」就行了。麦当劳和肯德基就是生产鸡翅的 Factory 工厂模式：客户类和工厂类分开。</p>
<p>消费者任何时候需要某种产品，只需向工厂请求即可。消费者无须修改就可以接纳新产品。缺点是当产品修改时，工厂类也要做相应的修改。如：如何创建及如何向客户端提供。</p>
<h3 id="建造者模式">建造者模式</h3>
<p>MM 最爱听的就是「我爱你」这句话了，见到不同地方的 MM，要能够用她们的方言跟她说这句话哦，我有一个多种语言翻译机，上面每种语言都有一个按键，见到 MM 我只要按对应的键，它就能够用相应的语言说出「我爱你」这句话了，国外的 MM 也可以轻松搞掂，这就是我的「我爱你」builder。</p>
<p>建造模式：将产品的内部表象和产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象。建造模式使得产品内部表象可以独立的变化，客户不必知道产品内部组成的细节。建造模式可以强制实行一种分步骤进行的建造过程。</p>
<h3 id="抽象工厂">抽象工厂</h3>
<p>请 MM 去麦当劳吃汉堡，不同的 MM 有不同的口味，要每个都记住是一件烦人的事情，我一般采用 Factory Method 模式，带着 MM 到服务员那儿，说「要一个汉堡」，具体要什么样的汉堡呢，让 MM 直接跟服务员说就行了。</p>
<p>工厂方法模式：核心工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类去做，成为一个抽象工厂角色，仅负责给出具体工厂类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。</p>
<h3 id="原型模式">原型模式</h3>
<p>跟 MM 用 QQ 聊天，一定要说些深情的话语了，我搜集了好多肉麻的情话，需要时只要 copy 出来放到 QQ 里面就行了，这就是我的情话 prototype 了。（100 块钱一份，你要不要）</p>
<p>原始模型模式：通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的方法创建出更多同类型的对象。原始模型模式允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。缺点是每一个类都必须配备一个克隆方法。</p>
<h3 id="单态模式">单态模式</h3>
<p>俺有 6 个漂亮的老婆，她们的老公都是我，我就是我们家里的老公 Sigleton，她们只要说道「老公」，都是指的同一个人，那就是我 (刚才做了个梦啦，哪有这么好的事)</p>
<p>单例模式：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式。单例模式只应在有真正的 “单一实例” 的需求时才可使用</p>
<h3 id="适配器模式">适配器模式</h3>
<p>在朋友聚会上碰到了一个美女 Sarah，从香港来的，可我不会说粤语，她不会说普通话，只好求助于我的朋友 kent 了，他作为我和 Sarah 之间的 Adapter，让我和 Sarah 可以相互交谈了 (也不知道他会不会耍我)</p>
<p>适配器（变压器）模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。适配类可以根据参数返还一个合适的实例给客户端。</p>
<h3 id="桥梁模式">桥梁模式</h3>
<p>早上碰到 MM，要说早上好，晚上碰到 MM，要说晚上好；碰到 MM 穿了件新衣服，要说你的衣服好漂亮哦，碰到 MM 新做的发型，要说你的头发好漂亮哦。不要问我 “早上碰到 MM 新做了个发型怎么说” 这种问题，自己用 BRIDGE 组合一下不就行了</p>
<p>桥梁模式：将抽象化与实现化脱耦，使得二者可以独立的变化，也就是说将他们之间的强关联变成弱关联，也就是指在一个软件系统的抽象化和实现化之间使用组合 / 聚合关系而不是继承关系，从而使两者可以独立的变化。</p>
<h3 id="合成模式">合成模式</h3>
<p>Mary 今天过生日。“我过生日，你要送我一件礼物。”“嗯，好吧，去商店，你自己挑。”“这件 T 恤挺漂亮，买，这条裙子好看，买，这个包也不错，买。”“喂，买了三件了呀，我只答应送一件礼物的哦。”“什么呀，T 恤加裙子加包包，正好配成一套呀，小姐，麻烦你包起来。”“……”，MM 都会用 Composite 模式了，你会了没有？</p>
<p>合成模式：合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。合成模式使得客户端把一个个单独的成分对象和由他们复合而成的合成对象同等看待。</p>
<h3 id="装饰模式">装饰模式</h3>
<p>Mary 过完轮到 Sarly 过生日，还是不要叫她自己挑了，不然这个月伙食费肯定玩完，拿出我去年在华山顶上照的照片，在背面写上 “最好的的礼物，就是爱你的 Fita”，再到街上礼品店买了个像框（卖礼品的 MM 也很漂亮哦），再找隔壁搞美术设计的 Mike 设计了一个漂亮的盒子装起来……，我们都是 Decorator，最终都在修饰我这个人呀，怎么样，看懂了吗？</p>
<p>装饰模式：装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案，提供比继承更多的灵活性。动态给一个对象增加功能，这些功能可以再动态的撤消。增加由一些基本功能的排列组合而产生的非常大量的功能。</p>
<h3 id="门面模式">门面模式</h3>
<p>我有一个专业的 Nikon 相机，我就喜欢自己手动调光圈、快门，这样照出来的照片才专业，但 MM 可不懂这些，教了半天也不会。幸好相机有 Facade 设计模式，把相机调整到自动档，只要对准目标按快门就行了，一切由相机自动调整，这样 MM 也可以用这个相机给我拍张照片了。门面模式：外部与一个子系统的通信必须通过一个统一的门面对象进行。</p>
<p>门面模式提供一个高层次的接口，使得子系统更易于使用。每一个子系统只有一个门面类，而且此门面类只有一个实例，也就是说它是一个单例模式。但整个系统可以有多个门面类。</p>
<h3 id="享元模式">享元模式</h3>
<p>每天跟 MM 发短信，手指都累死了，最近买了个新手机，可以把一些常用的句子存在手机里，要用的时候，直接拿出来，在前面加上 MM 的名字就可以发送了，再不用一个字一个字敲了。共享的句子就是 Flyweight，MM 的名字就是提取出来的外部特征，根据上下文情况使用。享元模式：FLYWEIGHT 在拳击比赛中指最轻量级。</p>
<p>享元模式以共享的方式高效的支持大量的细粒度对象。享元模式能做到共享的关键是区分内蕴状态和外蕴状态。内蕴状态存储在享元内部，不会随环境的改变而有所不同。外蕴状态是随环境的改变而改变的。外蕴状态不能影响内蕴状态，它们是相互独立的。</p>
<p>将可以共享的状态和不可以共享的状态从常规类中区分开来，将不可以共享的状态从类里剔除出去。客户端不可以直接创建被共享的对象，而应当使用一个工厂对象负责创建被共享的对象。享元模式大幅度的降低内存中对象的数量。</p>
<h3 id="代理模式">代理模式</h3>
<p>跟 MM 在网上聊天，一开头总是 “hi, 你好”,“你从哪儿来呀？”“你多大了？”“身高多少呀？” 这些话，真烦人，写个程序做为我的 Proxy 吧，凡是接收到这些话都设置好了自己的回答，接收到其他的话时再通知我回答，怎么样，酷吧。</p>
<p>代理模式：代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用。代理就是一个人或一个机构代表另一个人或者一个机构采取行动。某些情况下，客户不想或者不能够直接引用一个对象，代理对象可以在客户和目标对象直接起到中介的作用。</p>
<p>客户端分辨不出代理主题对象与真实主题对象。代理模式可以并不知道真正的被代理对象，而仅仅持有一个被代理对象的接口，这时候代理对象不能够创建被代理对象，被代理对象必须有系统的其他角色代为创建并传入。</p>
<h3 id="责任链模式">责任链模式</h3>
<p>晚上去上英语课，为了好开溜坐到了最后一排，哇，前面坐了好几个漂亮的 MM 哎，找张纸条，写上 “Hi, 可以做我的女朋友吗？如果不愿意请向前传”，纸条就一个接一个的传上去了，糟糕，传到第一排的 MM 把纸条传给老师了，听说是个老处女呀，快跑！</p>
<p>责任链模式：在责任链模式中，很多对象由每一个对象对其下家的引用而接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。客户并不知道链上的哪一个对象最终处理这个请求，系统可以在不影响客户端的情况下动态的重新组织链和分配责任。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象所接受。</p>
<h3 id="命令模式">命令模式</h3>
<p>俺有一个 MM 家里管得特别严，没法见面，只好借助于她弟弟在我们俩之间传送信息，她对我有什么指示，就写一张纸条让她弟弟带给我。这不，她弟弟又传送过来一个 COMMAND，为了感谢他，我请他吃了碗杂酱面，哪知道他说：“我同时给我姐姐三个男朋友送 COMMAND，就数你最小气，才请我吃面。”</p>
<p>命令模式：命令模式把一个请求或者操作封装到一个对象中。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。命令模式允许请求的一方和发送的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否执行，何时被执行以及是怎么被执行的。系统支持命令的撤消。</p>
<h3 id="解释器模式">解释器模式</h3>
<p>俺有一个《泡 MM 真经》，上面有各种泡 MM 的攻略，比如说去吃西餐的步骤、去看电影的方法等等，跟 MM 约会时，只要做一个 Interpreter，照着上面的脚本执行就可以了。</p>
<p>解释器模式：给定一个语言后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。解释器模式将描述怎样在有了一个简单的文法后，使用模式设计解释这些语句。</p>
<p>在解释器模式里面提到的语言是指任何解释器对象能够解释的任何组合。在解释器模式中需要定义一个代表文法的命令类的等级结构，也就是一系列的组合规则。每一个命令对象都有一个解释方法，代表对命令对象的解释。命令对象的等级结构中的对象的任何排列组合都是一个语言。</p>
<h3 id="迭代模式">迭代模式</h3>
<p>我爱上了 Mary，不顾一切的向她求婚。Mary：“想要我跟你结婚，得答应我的条件” 我：“什么条件我都答应，你说吧” Mary：“我看上了那个一克拉的钻石” 我：“我买，我买，还有吗？” Mary：“我看上了湖边的那栋别墅” 我：“我买，我买，还有吗？” Mary：“我看上那辆法拉利跑车” 我脑袋嗡的一声，坐在椅子上，一咬牙：“我买，我买，还有吗？”</p>
<p>迭代模式：迭代模式可以顺序访问一个聚集中的元素而不必暴露聚集的内部表象。多个对象聚在一起形成的总体称之为聚集，聚集对象是能够包容一组对象的容器对象。迭代子模式将迭代逻辑封装到一个独立的子对象中，从而与聚集本身隔开。</p>
<p>迭代模式简化了聚集的界面。每一个聚集对象都可以有一个或一个以上的迭代子对象，每一个迭代子的迭代状态可以是彼此独立的。迭代算法可以独立于聚集角色变化。</p>
<h3 id="调停者模式">调停者模式</h3>
<p>四个 MM 打麻将，相互之间谁应该给谁多少钱算不清楚了，幸亏当时我在旁边，按照各自的筹码数算钱，赚了钱的从我这里拿，赔了钱的也付给我，一切就 OK 啦，俺得到了四个 MM 的电话。调停者模式：调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使他们可以松散偶合。</p>
<p>当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。保证这些作用可以彼此独立的变化。调停者模式将多对多的相互作用转化为一对多的相互作用。调停者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。</p>
<h3 id="备忘录模式">备忘录模式</h3>
<p>同时跟几个 MM 聊天时，一定要记清楚刚才跟 MM 说了些什么话，不然 MM 发现了会不高兴的哦，幸亏我有个备忘录，刚才与哪个 MM 说了什么话我都拷贝一份放到备忘录里面保存，这样可以随时察看以前的记录啦。</p>
<p>备忘录模式：备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。</p>
<h3 id="观察者模式">观察者模式</h3>
<p>想知道咱们公司最新 MM 情报吗？加入公司的 MM 情报邮件组就行了，tom 负责搜集情报，他发现的新情报不用一个一个通知我们，直接发布给邮件组，我们作为订阅者（观察者）就可以及时收到情报啦。</p>
<p>观察者模式：观察者模式定义了一种一队多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。</p>
<h3 id="状态模式">状态模式</h3>
<p>跟 MM 交往时，一定要注意她的状态哦，在不同的状态时她的行为会有不同，比如你约她今天晚上去看电影，对你没兴趣的 MM 就会说 “有事情啦”，对你不讨厌但还没喜欢上的 MM 就会说 “好啊，不过可以带上我同事么？”，已经喜欢上你的 MM 就会说 “几点钟？看完电影再去泡吧怎么样？”，当然你看电影过程中表现良好的话，也可以把 MM 的状态从不讨厌不喜欢变成喜欢哦。</p>
<p>状态模式：状态模式允许一个对象在其内部状态改变的时候改变行为。这个对象看上去象是改变了它的类一样。状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。</p>
<p>状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。</p>
<h3 id="策略模式">策略模式</h3>
<p>跟不同类型的 MM 约会，要用不同的策略，有的请电影比较好，有的则去吃小吃效果不错，有的去海边浪漫最合适，单目的都是为了得到 MM 的芳心，我的追 MM 锦囊中有好多 Strategy 哦。策略模式：策略模式针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。</p>
<p>策略模式使得算法可以在不影响到客户端的情况下发生变化。策略模把行为和环境分开。环境类负责维持和查询行为类，各种算法在具体的策略类中提供。由于算法和环境独立开来，算法的增减，修改都不会影响到环境和客户端</p>
<h3 id="模版方法模式">模版方法模式</h3>
<p>看过《如何说服女生上床》这部经典文章吗？女生从认识到上床的不变的步骤分为巧遇、打破僵局、展开追求、接吻、前戏、动手、爱抚、进去八大步骤 (Template method)，但每个步骤针对不同的情况，都有不一样的做法，这就要看你随机应变啦 (具体实现)；</p>
<p>模板方法模式：模板方法模式准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。</p>
<h3 id="访问者模式">访问者模式</h3>
<p>情人节到了，要给每个 MM 送一束鲜花和一张卡片，可是每个 MM 送的花都要针对她个人的特点，每张卡片也要根据个人的特点来挑，我一个人哪搞得清楚，还是找花店老板和礼品店老板做一下 Visitor，让花店老板根据 MM 的特点选一束花，让礼品店老板也根据每个人特点选一张卡，这样就轻松多了；</p>
<p>访问者模式：访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。访问者模式使得增加新的操作变的很容易，就是增加一个新的访问者类。</p>
<p>访问者模式将有关的行为集中到一个访问者对象中，而不是分散到一个个的节点类中。当使用访问者模式时，要将尽可能多的对象浏览逻辑放在访问者类中，而不是放到它的子类中。访问者模式可以跨过几个类的等级结构访问属于不同的等级结构的成员类。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Thymeleaf常用属性]]></title>
        <id>https://cm940324.github.io/post/thymeleaf/</id>
        <link href="https://cm940324.github.io/post/thymeleaf/">
        </link>
        <updated>2021-05-21T09:12:09.000Z</updated>
        <content type="html"><![CDATA[<p>如需了解Thymeleaf 基本表达式，请参考《<a href="http://www.cnblogs.com/hjwublog/p/5051632.html">Thymeleaf </a><a href="http://www.cnblogs.com/hjwublog/p/5051632.html">基本表达式</a>》一文</p>
<h1 id="thaction"><strong>th:action</strong></h1>
<p>定义后台控制器路径，类似<form>标签的action属性。</p>
<p>例如：</p>
<pre><code>&lt;form id=&quot;login-form&quot; th:action=&quot;@{/login}&quot;&gt;...&lt;/form&gt;
</code></pre>
<h1 id="theach"><strong>th:each</strong></h1>
<p>对象遍历，功能类似jstl中的&lt;c:forEach&gt;标签。</p>
<p>例如：</p>
<pre><code>public class StudentRequestBean {

private List&lt;Student&gt; students;

...

}

public class Student implements Serializable{

private String firstName;

private String school;

...}

@RequestMapping(value = &quot;/addStudent&quot;, method = RequestMethod.POST)

public String addStudent(@ModelAttribute(value = &quot;stuReqBean&quot;) 

StudentRequestBean stuReqBean，ModelMap model) {...}
</code></pre>
<form id="login-form" th:action="@{/addStudent}" 
```
th:object="${stuReqBean}" method="POST">
<div class="student" th:each="stuIter,rowStat:${stuReqBean.students}">
<p>&lt;input type=&quot;text&quot; class=&quot;firstName&quot; value=&quot;&quot;</p>
<p>th:field=&quot;*{students[<strong>${rowStat.index}</strong>].firstName}&quot;&gt;</input></p>
<p>&lt;input type=&quot;text&quot; class=&quot;school&quot; value=&quot;&quot;</p>
<p>th:field=&quot;*{students[<strong>${rowStat.index}</strong>].school}&quot;&gt;</input></p>
<p>...</p>
</div>
</form>
```
<p>上面的例子中通过选择表达式*{}既能将表单绑定到后台的StudentRequestBean中的集合属性students，也能将Servlet上下文中的StudentRequestBean中的List类型的students变量回显，回显时通过th:each进行遍历。</p>
<p>注意1：绑定集合属性元素下标的用法*{students[<strong>${rowStat.index}</strong>].firstName}</p>
<p>注意2：如果List<Student> students为null，页面将无法显示表单，后台必须给students初始化一个值，即:</p>
<pre><code>List&lt;Student &gt; stus = new ArrayList&lt;Student &gt;();

stus .add(new Student ());

StudentRequestBean.setStudents(stus );
</code></pre>
<p>注意3：stuIter代表students的迭代器</p>
<h1 id="thfield"><strong>th:field</strong></h1>
<p>常用于表单字段绑定。通常与th:object一起使用。 属性绑定、集合绑定。</p>
<p>如：</p>
<pre><code>public class LoginBean implements Serializable{...

private String username;

private List&lt;User&gt; user;

...}


public class User implements Serializable{...

private String username;;

...}


@RequestMapping(value = &quot;/login&quot;, method = RequestMethod.POST)

public String login(@ModelAttribute(value = &quot;loginBean&quot;) LoginBean loginBean，ModelMap model) {..}
</code></pre>
<pre><code>&lt;form id=&quot;login-form&quot; th:action=&quot;@{/login}&quot; th:object=&quot;${loginBean}&quot;&gt;...

&lt;input type=&quot;text&quot; value=&quot;&quot; th:field=&quot;*{username}&quot;&gt;&lt;/input&gt;

&lt;input type=&quot;text&quot; value=&quot;&quot; th:field=&quot;*{user[0].username}&quot;&gt;&lt;/input&gt;

&lt;/form&gt;
</code></pre>
<h1 id="thhref"><strong>th:href</strong></h1>
<p>定义超链接，类似<a>标签的href 属性。value形式为@{/logout}</p>
<p>例如：</p>
<pre><code>&lt;a th:href=&quot;@{/logout}&quot; class=&quot;signOut&quot;&gt;&lt;/a&gt;
</code></pre>
<h1 id="thid"><strong>th:id</strong></h1>
<p>div id声明，类似html标签中的id属性。</p>
<p>例如：</p>
<pre><code>&lt;div class=&quot;student&quot; th:id = &quot;stu+(${rowStat.index}+1)&quot;&gt;&lt;/div&gt;
</code></pre>
<h1 id="thif"><strong>th:if</strong></h1>
<p>条件判断。</p>
<p>例如：</p>
<pre><code>&lt;div th:if=&quot;${rowStat.index} == 0&quot;&gt;... do something ...&lt;/div&gt;
</code></pre>
<h1 id="thinclude"><strong>th:include</strong></h1>
<p>见th:fragment</p>
<h1 id="thfragment"><strong>th:fragment</strong></h1>
<p>声明定义该属性的div为模板片段，常用与头文件、页尾文件的引入。常与th:include，th:replace一起使用。</p>
<p>例如：</p>
<p>声明模板片段/WEBINF/templates/footer. html</p>
<pre><code>&lt;div th: fragment=&quot; copy&quot; &gt;

© 2011 The Good Thymes Virtual Grocery

&lt;/div&gt;
</code></pre>
<p>引入模板片段</p>
<pre><code>&lt;div th: include=&quot; /templates/footer : : copy&quot; &gt;&lt;/div&gt;

&lt;div th: replace=&quot; /templates/footer : : copy&quot; &gt;&lt;/div&gt;
</code></pre>
<h1 id="thobject"><strong>th:object</strong></h1>
<p>用于表单数据对象绑定，将表单绑定到后台controller的一个JavaBean参数。常与th:field一起使用进行表单数据绑定。</p>
<p>例如：</p>
<pre><code>public class LoginBean implements Serializable{...}


@RequestMapping(value = &quot;/login&quot;, method = RequestMethod.POST)

public String login(@ModelAttribute(value = &quot;loginBean&quot;) LoginBean loginBean，ModelMap model) {...}
</code></pre>
<pre><code>&lt;form id=&quot;login-form&quot; th:action=&quot;@{/login}&quot; th:object=&quot;${loginBean}&quot;&gt;...&lt;/form&gt;
</code></pre>
<h1 id="thsrc"><strong>th:src</strong></h1>
<p>用于外部资源引入，类似于<script>标签的src属性，常与@{}一起使用。</p>
<p>例如：</p>
<pre><code>&lt;script th:src=&quot;@{/resources/js/jquery/jquery.json-2.4.min.js}&quot;
</code></pre>
<h1 id="threplace"><strong>th:replace</strong></h1>
<p>见th:fragment</p>
<h1 id="thtext"><strong>th:text</strong></h1>
<p>文本显示。</p>
<p>例如：</p>
<pre><code>&lt;td class=&quot;text&quot; th:text=&quot;${username}&quot; &gt;&lt;/td&gt;
</code></pre>
<h1 id="thvalue"><strong>th:value</strong></h1>
<p>用于标签复制，类似<option>标签的value属性。</p>
<p>例如:</p>
<pre><code>&lt;option th:value=&quot;Adult&quot;&gt;Adult&lt;/option&gt;

&lt;input  id=&quot;msg&quot; type=&quot;hidden&quot; th:value=&quot;${msg}&quot; /&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[搭建内容管理系统CMS（1）：如何支持内容生产？]]></title>
        <id>https://cm940324.github.io/post/cms1/</id>
        <link href="https://cm940324.github.io/post/cms1/">
        </link>
        <updated>2021-05-21T06:52:55.000Z</updated>
        <content type="html"><![CDATA[<pre><code>内容管理系统是一种位于WEB 前端（Web 服务器）和后端办公系统或流程（内容创作、编辑）之间的软件系统，本文是对于内容管理系统CMS在内容生产环节的总结与分享。
</code></pre>
<p><em><strong>*关于CMS内容管理系统：*</strong></em></p>
<p>内容管理系统（content management system，CMS）是一种位于WEB 前端（Web 服务器）和后端办公系统或流程（内容创作、编辑）之间的软件系统。</p>
<p>“内容”是任何类型的数字信息，可以是文本、图形图像、Web页面、业务文档、数据库表单、视频、声音、XML文件等。</p>
<h3 id="1-关于cms搭建的思考">1. 关于CMS搭建的思考</h3>
<p>通常，设计一个产品之前，我们需要思考以下几个基本的问题：</p>
<p>**产品目标：**我们希望通过这个产品得到什么？</p>
<p>——这决定我们要做成一个什么类型的产品</p>
<p>**目标用户：**产品面向的目标用户具有什么特征？</p>
<p>——这决定我们去哪找什么样的用户</p>
<p>**用户需求：**我们的用户希望通过这个产品得到什么？</p>
<p>——这决定我们要设计哪些功能模块</p>
<p>**场景动机：**我们的用户在什么样的场景下会有使用产品的动机？</p>
<p>——这决定我们要怎么设计产品</p>
<p>**标准指标：**想法正确、方案合理、市场匹配的标准/指标是什么？</p>
<p>——这决定我们的目标是否达成</p>
<p>我们需要思考和梳理的内容，可概括为3点：对象、痛点、解决方案。</p>
<p><strong>对象：</strong></p>
<ul>
<li>
<p>内容的生产人员，例：运营、用户（由用户端满足需求）</p>
</li>
<li>
<p>内容的审核人员，例：运营、客服</p>
</li>
<li>
<p>内容的推广人员，例：运营、用户（由用户端满足需求）</p>
</li>
<li>
<p>相互作用的系统，例：过滤系统、推荐系统</p>
</li>
</ul>
<p><strong>痛点：</strong></p>
<ul>
<li>
<p>运营：高效地完成内容生产、便捷地审核用户推荐、特定需求的人工推荐、推荐系统的精准度优化、及时直观地获取到内容运营的数据情况；</p>
</li>
<li>
<p>客服：便捷地审核用户举报、问题用户的管理、推荐系统的精准度优化；</p>
</li>
<li>
<p>过滤系统：对内容完成智能过滤；</p>
</li>
<li>
<p>推荐系统：对内容完成智能推荐。</p>
</li>
</ul>
<p><strong>解决方案：</strong></p>
<ul>
<li>运营：好用的内容编辑、修改和发布工具；待审核的处理工作台；人工推荐配置支持、推荐系统的运作情况；内容运营数据的可视化呈现；</li>
<li>客服：待审核的处理工作台；用户标记管理、过滤系统的运作情况；</li>
<li>过滤系统：系统的搭建和持续优化方案；</li>
<li>推荐系统：系统的搭建和持续优化方案。</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://cm940324.github.io/post-images/1621580833843.png" alt="" loading="lazy"></figure>
<h3 id="2-内容的生产来源">2. 内容的生产(来源)</h3>
<p>CMS内容管理系统，从字面意思就能知道，管理的对象是“内容”，而“内容”的具体类型是什么、“管理”的具体范畴是什么，这些都是要依据具体的业务而定。</p>
<p>得有内容才有管理，没内容谈何管理呢？那问题来了，内容从哪里来呢？来源都有哪些？</p>
<h4 id="21-常见的内容生产模式">2.1 常见的内容生产模式</h4>
<p>介绍一下常见的内容生产模式，有以下三种：</p>
<p><strong>UGC模式：</strong></p>
<ul>
<li>全称：user generated content。即：用户输出内容。</li>
<li>产品代表：小红书。主要通过激励用户生产内容，形成社区氛围。</li>
</ul>
<p><strong>PGC模式：</strong></p>
<ul>
<li>全称：professionally generated content。即：专业输出内容。</li>
<li>产品代表：知乎。主要通过专业人员生产内容，提供给用户消费。</li>
</ul>
<p><strong>OGC模式：</strong></p>
<ul>
<li>
<p>全称：occupationally generated content。即：职业输出内容。</p>
</li>
<li>
<p>产品代表：新闻资讯类。主要通过具有一定知识和专业背景的行业人士生产内容，并领取相应报酬。</p>
</li>
</ul>
<p><strong>三者之间的区别：</strong></p>
<ul>
<li>
<p>UGC与PGC的区别：生产内容的人有无专业知识、资质；</p>
</li>
<li>
<p>PGC与OGC的区别：生产内容的人是否以此为职业，获得对应的报酬。</p>
</li>
</ul>
<p>往往PGC模式的内容生产者，也是产品的用户，还可能是种子用户、忠诚用户、意见领袖。</p>
<p>综上，我们可以将内容的来源分成4种：</p>
<ul>
<li>用户生产（UGC&amp;PGC）</li>
<li>运营生产（OGC）</li>
<li>技术爬取（通过技术手段去爬取内容）</li>
<li>授权使用（以付费的形式购买内容版权）</li>
</ul>
<p>其中：用户生产内容的产品支持，可由用户端的产品设计来满足。</p>
<p>技术爬取和授权使用，在需求明确的前提下，主要是由技术人员来实现和对接。</p>
<p>如果存在与多家平台有版权内容的授权对接工作，那建议可开发统一的内容接入接口。不同的版权内容平台，可能对接的方式有着大大小小的差异，这里可能涉及到一定的开发工作量。作为一名尽职的B端产品经理，本着为公司降本（降低开发成本）提效（提高版本效率）的一贯原则，最理想的状态是把统一的接口文档一发，就能把部分的开发工作量给转移了出去。但现实往往都是很骨感的，如果对方是“爸爸”，愿意把内容的版权给你就已经很难得了，那还是得乖乖自个儿开发接入。</p>
<p>以过来人的经验（踩过坑的那种），这部分的工作不要过分依赖开发，由其独自对接完成，需要加入必要的管理和规划，以免重复低效的工作占用太多的开发资源，或是人员离职变动带来的麻烦。至于价值、重要程度和优先级，需依据自己的项目、产品和团队情况，具体评估。</p>
<p>而内容管理系统（CMS）在生产环节主要服务的对象是负责内容生产的运营小伙伴。</p>
<p>一般情况下，内容运营除了管理官方账号外，可能同时还在运营着多个个人账号，如果运营同事也是依靠用户端来完成内容发布的工作，那就会存在频繁切换登录不同账号的麻烦。而切换登录这个需求对于普通用户可能根本就不存在。</p>
<p>除此之外，内容运营还存在用户需求之上的发布需求，比如可以预设定时发布等等。</p>
<h4 id="22-cms在生产环节的需求点">2.2 CMS在生产环节的需求点</h4>
<p>总结一下，内容管理系统（CMS）在生产环节的需求概要有：</p>
<p><strong>账号关联：</strong></p>
<ul>
<li>
<p>和CMS系统账号关联，支持系统账号和运营账号一对多的关系；</p>
</li>
<li>
<p>使用CMS系统发布内容时候，可选择对应的运营账号；</p>
</li>
<li>
<p>支持运营账号解除绑定或转移，以便应对人员调整或离职的变动。</p>
</li>
</ul>
<p><strong>生产工具：</strong></p>
<ul>
<li>提供便捷、好用的编辑功能；</li>
<li>支持效果预览；</li>
<li>可保存草稿。</li>
</ul>
<p>**素材管理：**如果对素材的复用度较高，可考虑增加素材管理，同时也方便随时随地有台电脑登录系统就能开展工作，避免素材要用起来才发现保存在某台电脑本地的尴尬。</p>
<p>**模板管理：**如果对特定内容的排版呈现有统一的要求，例如“每日推荐”等，只需要替换具体内容和素材即可，则可以增加模板管理，为运营减免重复不必要的排版布局工作。</p>
<p><strong>预设时间发布：</strong></p>
<ul>
<li>内容通常都是提前就会准备好的，尤其是针对一些节日主题或活动营销的内容，会提前思考、撰写，并对更新的节奏做好规划排期（就像产品经理做版本规划一样）。</li>
<li>如果有提供定时发布功能，那负责内容运营的同事就可以集中时间一次性地把准备好的内容提前设置好发布时间，使其更合理的安排工作时间和实施内容计划，提高工作效率。</li>
</ul>
<p>早期的版本，可仅提供基本的、必要的管理、编辑和发布功能，保证内容运营的顺利生产。而更能提高效率的工具和功能，则可与运营部门确认整体的内容工作规划，在不同的时期配合新增上线。</p>
<p>具体的功能设计可参考：微信公众平台、秀米编辑器、365编辑器。</p>
<p>以上，就是对于内容管理系统CMS在内容生产环节的总结与分享。后面，还会有CMS在内容过滤、内容呈现和内容举报环节的文章更新。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[AmazonS3工具类]]></title>
        <id>https://cm940324.github.io/post/amazons3-util/</id>
        <link href="https://cm940324.github.io/post/amazons3-util/">
        </link>
        <updated>2021-05-13T07:00:29.000Z</updated>
        <content type="html"><![CDATA[<pre><code>/**
 * @author chenmo
 * @Date: Created in 2021/5/12 5:05 下午
 * @Utils: Intellij Idea
 * @Description: TODO
 */
@Component
@RequiredArgsConstructor
public class AmazonS3Operator {

    private static final Logger LOGGER = LoggerFactory.getLogger(AmazonS3Operator.class);

    final AmazonS3Configuration amazonS3Configuration;

    //创建链接
    public AmazonS3 createConnection(){
        var credentials = new BasicAWSCredentials(amazonS3Configuration.getAccessKey(), amazonS3Configuration.getSecretKey());
        var conn = new AmazonS3Client(credentials);
        conn.setEndpoint(amazonS3Configuration.getEndPoint());
        var buckets = conn.listBuckets();
        LOGGER.info(&quot;amazonS3 bucket list ==========================================&quot;);
        for (Bucket bucket : buckets) {
            LOGGER.info(&quot;amazonS3 bucket =========&gt;&quot;+bucket.getName() + &quot;\t&quot; +
                    StringUtils.fromDate(bucket.getCreationDate()));
        }
        LOGGER.info(&quot;================================================================&quot;);
        return conn;
    }

    //创建Bucket
    public Bucket createBucket(String name){
        return createConnection().createBucket(name);
    }

    //上传一个文件
    public String uploadFileToBucket(MultipartFile multipartFile){
        var snowflake = new Snowflake(1,1);
        var key = snowflake.nextIdStr();
        FileInputStream fileInputStream = null;
        try {
            fileInputStream = (FileInputStream) multipartFile.getInputStream();
            createConnection().putObject(amazonS3Configuration.getBucket(),key,fileInputStream,new ObjectMetadata());
            LOGGER.info(&quot;上传文件&quot;+key+&quot;：&quot;+multipartFile.getName()+ &quot;到&quot;+amazonS3Configuration.getBucket()+&quot;成功！！！！&quot;);
            return key;
        }catch (FileNotFoundException e){
            LOGGER.info(&quot;上传文件&quot;+key+&quot;：&quot;+multipartFile.getName()+  &quot;到&quot;+amazonS3Configuration.getBucket()+&quot;失败，文件未找到&quot;);
            return null;
        }catch (IOException e){
            e.printStackTrace();
            return null;
        }finally {
            try {
                if(fileInputStream != null){
                    fileInputStream.close();
                }
            }catch (IOException e){
                LOGGER.debug(&quot;inputStream close IOException:&quot; + e.getMessage());
                e.printStackTrace();
            }
        }
    }

    //预览一个文件
    public String reviewFileFromBucket(String key){
        try {
            if(StringUtils.isNullOrEmpty(key)){
                return null;
            }
            var httpRequest = new GeneratePresignedUrlRequest(amazonS3Configuration.getBucket(), key);
            return createConnection().generatePresignedUrl(httpRequest).toString();
        }catch (Exception e){
            e.printStackTrace();
        }
        return null;
    }

}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式的学习]]></title>
        <id>https://cm940324.github.io/post/design-study/</id>
        <link href="https://cm940324.github.io/post/design-study/">
        </link>
        <updated>2021-05-09T09:21:27.000Z</updated>
        <content type="html"><![CDATA[<h3 id="设计模式的目的">设计模式的目的</h3>
<p>编写软件过程中，程序员面临着来自 耦合性，内聚性以及可维护性，可扩展性，重用性，灵活性 等多方面的挑战，设计模式是为了让程序(软件)具有更好的:</p>
<ol>
<li>
<p>代码重用性 (即：相同功能的代码，不用多次编写)</p>
</li>
<li>
<p>可读性 (即：编程规范性, 便于其他程序员的阅读和理解)</p>
</li>
<li>
<p>可扩展性 (即：当需要增加新的功能时，非常的方便，称为可维护)</p>
</li>
<li>
<p>可靠性 (即：当我们增加新的功能后，对原来的功能没有影响)</p>
</li>
<li>
<p>使程序呈现高内聚，低耦合的特性</p>
</li>
</ol>
<pre><code>“懂了设计模式，你就懂了面向对象分析和设计（OOA/D）的精要” ----设计模式包含了面向对象的精髓

“C++老手和 C++新手的区别就是前者手背上有很多伤疤” ----Scott Mayers 在其巨著《Effective C++》
</code></pre>
<h3 id="设计模式七大原则">设计模式七大原则</h3>
<p>设计模式原则，其实就是程序员在编程时，应当遵守的原则，也是各种设计模式的基础(即：设计模式为什么这样设计的依据)</p>
<p><mark>Ø 设计模式常用的七大原则有:</mark></p>
<ol>
<li>
<p>单一职责原则</p>
</li>
<li>
<p>接口隔离原则</p>
</li>
<li>
<p>依赖倒转(倒置)原则</p>
</li>
<li>
<p>里氏替换原则</p>
</li>
<li>
<p>开闭原则</p>
</li>
<li>
<p>迪米特法则</p>
</li>
<li>
<p>合成复用原则</p>
</li>
</ol>
<h4 id="单一职责原则">单一职责原则</h4>
<h5 id="基本介绍">基本介绍</h5>
<p>对类来说的，即一个类应该只负责一项职责。如类 A 负责两个不同职责：职责 1，职责 2。当职责 1 需求变更而改变 A 时，可能造成职责 2 执行错误，所以需要将类 A 的粒度分解为 A1，A2</p>
<h5 id="应用实例">应用实例</h5>
<p><strong>方案一:</strong></p>
<pre><code>// 1. 在方式 1 的 run 方法中，违反了单一职责原则
// 2. 解决的方案非常的简单，根据交通工具运行方法不同，分解成不同类即可
public class SingleResponsibility1{
	public static void main(String[] args){
		Vehicle vehicle = new Vehicle();
		vehicle.run(&quot;摩托车&quot;);
		vehicle.run(&quot;汽车&quot;);
		vehicle.run(&quot;飞机&quot;);
	}
}
class Vehicle {
	public void run(String vehicle) { 
			System.out.println(vehicle + &quot; 在公路上运行....&quot;);
	}
}

</code></pre>
<p><strong>方案二</strong></p>
<pre><code>//方案 2 的分析
//1. 遵守单一职责原则
//2. 但是这样做的改动很大，即将类分解，同时修改客户端
//3. 改进：直接修改 Vehicle 类，改动的代码会比较少=&gt;方案 3
public class SingleResponsibility1{
	public static void main(String[] args){
		RoadVehicle roadVehicle = new RoadVehicle();
		roadVehicle.run(&quot;摩托车&quot;);
		roadVehicle.run(&quot;汽车&quot;);
		AirVehicle airVehicle = new AirVehicle();
		airVehicle.run(&quot;飞机&quot;);
	}
}
class RoadVehicle {
	public void run(String vehicle) { 
		System.out.println(vehicle + &quot;公路运行&quot;);
	}
}


class AirVehicle {
	public void run(String vehicle) { 
		System.out.println(vehicle + &quot;天空运行&quot;);
	}
}

</code></pre>
<p><strong>方案三</strong></p>
<pre><code>//方式 3 的分析
//1. 这种修改方法没有对原来的类做大的修改，只是增加方法
//2. 这里虽然没有在类这个级别上遵守单一职责原则，但是在方法级别上，仍然是遵守单一职责
public class SingleResponsibility3 {
	public static void main(String[] args) {
		Vehicle2 vehicle2	= new Vehicle2();
		vehicle2.run(&quot;汽车&quot;);
		vehicle2.runWater(&quot;轮船&quot;);
		vehicle2.runAir(&quot;飞机&quot;);
	}
}
class Vehicle2 {
	public void run(String vehicle) {
		//处理
		System.out.println(vehicle + &quot; 在公路上运行....&quot;);
	}
	public void runAir(String vehicle) { 
		System.out.println(vehicle + &quot; 在天空上运行....&quot;);
	}
	public void runWater(String vehicle) { 
		System.out.println(vehicle + &quot; 在水中行....&quot;);
	}
}
</code></pre>
<pre><code>单一职责原则注意事项和细节
1)	降低类的复杂度，一个类只负责一项职责。
2)	提高类的可读性，可维护性
3)	降低变更引起的风险
4)	通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则
</code></pre>
<h4 id="接口隔离原则interface-segregation-principle">接口隔离原则(Interface Segregation Principle)</h4>
<h5 id="基本介绍-2">基本介绍</h5>
<ol>
<li>客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上</li>
<li>类 A 通过接口 Interface1 依赖类 B，类 C 通过接口 Interface1 依赖类 D，如果接口 Interface1 对于类 A 和类 C来说不是最小接口，那么类 B 和类 D 必须去实现他们不需要的方法。</li>
</ol>
<pre><code>public class Segregation1 {

public static void main(String[] args) {
// TODO Auto-generated method stub
}

}

//接口
interface Interface1 {
void operation1(); void operation2();
 

void operation3(); void operation4(); void operation5();
}


class B implements Interface1 { public void operation1() {
System.out.println(&quot;B 实现了 operation1&quot;);
}
public void operation2() {
System.out.println(&quot;B 实现了 operation2&quot;);
}
public void operation3() {
System.out.println(&quot;B 实现了 operation3&quot;);
}
public void operation4() {
System.out.println(&quot;B 实现了 operation4&quot;);
}
public void operation5() {
System.out.println(&quot;B 实现了 operation5&quot;);
}
}

class D implements Interface1 { public void operation1() {
System.out.println(&quot;D 实现了 operation1&quot;);
}
public void operation2() {
System.out.println(&quot;D 实现了 operation2&quot;);
}
public void operation3() {
System.out.println(&quot;D 实现了 operation3&quot;);
}
public void operation4() {
System.out.println(&quot;D 实现了  operation4&quot;);
}
public void  operation5()  { System.out.println(&quot;D 实现了  operation5&quot;);
}
}

class A { //A 类通过接口 Interface1 依赖(使用) B 类，但是只会用到 1,2,3 方法
public void depend1(Interface1 i) { i.operation1();
}
public void depend2(Interface1 i) { i.operation2();
}
public void depend3(Interface1 i) { i.operation3();
}
}

class C { //C 类通过接口 Interface1  依赖(使用) D 类，但是只会用到 1,4,5 方法
public void depend1(Interface1 i) { i.operation1();
}
public void depend4(Interface1 i) { i.operation4();
}
public void depend5(Interface1 i) { i.operation5();
}
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PostgreSQL自带全文检索]]></title>
        <id>https://cm940324.github.io/post/postgresql-jiansuo/</id>
        <link href="https://cm940324.github.io/post/postgresql-jiansuo/">
        </link>
        <updated>2021-05-06T08:38:50.000Z</updated>
        <content type="html"><![CDATA[<h3 id="相关文档">相关文档</h3>
<pre><code>文本搜索的函数与操作符中文说明: 
http://www.postgres.cn/docs/9.3.4/functions-textsearch.html
PostgreSQL 文本搜索文档 : 
https://www.postgresql.org/docs/9.4/textsearch-controls.html
</code></pre>
<h3 id="核心函数-关键字">核心函数、关键字</h3>
<p>全文搜索的思想主要分两步：</p>
<ul>
<li>
<p>将文本解析为对应的倒排索引</p>
</li>
<li>
<p>搜索索引来找到对应的文本</p>
</li>
</ul>
<p>要使用 PostgreSQL 的全文搜索, 那么就要了解到底是要用什么关键字和函数来<strong>构建索引</strong>和<strong>搜索</strong>， 这里主要涉及到<strong>一个关键字</strong>和<strong>四个函数</strong><br>
可以看上边的文档了解函数的具体参数</p>
<p><strong>关键字 tsvector:</strong><br>
tsvector 是 PostgreSQL 内置的一种字段类型, 用来保存的是分词后的结果 (文本向量) 它是由 [词，序列， 权重] 三个东西共同组成的， 权重可能会没有</p>
<p><strong>函数:</strong></p>
<ul>
<li>
<p>to_tsvector()</p>
<ul>
<li>分词用, 将文本转为向量。 用它可以将字符串转成上边说的 tsvector , 遗憾的是默认不支持中文分词</li>
</ul>
</li>
<li>
<p>to_tsquery()</p>
<ul>
<li>构建搜索的关键字， 支持各种符号表示条件。 详情查看文档</li>
</ul>
</li>
<li>
<p>setweight()</p>
<ul>
<li>设置关键词权重， 总共四个权重从高到低为 A-B-C-D</li>
</ul>
</li>
<li>
<p>ts_rank ()</p>
<ul>
<li>排序用， 可以根据 to_tsquery 和 tsvector 的匹配度计算</li>
</ul>
<pre><code>//查询表中包含 aaa 并且包含 BBB或CCC任意一个 的记录
  SELECT * FROM table
  WHERE to_tsvector('parser_name', field) @@ to_tsquery('aaa &amp; (bbb | ccc)')
</code></pre>
</li>
</ul>
<p><strong>索引:</strong></p>
<p>建立联合索引</p>
<pre><code>create index document_title_idx on encms.article using gin (to_tsvector('english',&quot;content&quot; || &quot;title&quot;) tsvector_ops)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[全面复盘：狗狗币是如何上涨400倍的？ ]]></title>
        <id>https://cm940324.github.io/post/doge/</id>
        <link href="https://cm940324.github.io/post/doge/">
        </link>
        <updated>2021-05-05T04:17:59.000Z</updated>
        <content type="html"><![CDATA[<pre><code>    ​
 4月20日，狗狗币纪念日。美国知名财经媒体在首页刊登了狗狗币相关报道，标题为《狗狗币交易赶上线上狂潮》，其中提到狗狗币在2021年的回报率超过8100%，是1998年以来标普500涨幅的2倍多，狗狗币市值大约为500亿美元，超过了万豪国际和福特汽车。
</code></pre>
<p>狗狗币2021年1月1日开盘报0.004619美元/枚，2021年4月16日最高报价已触及0.47美元/枚，日内暴涨200%，年内价格暴涨超100倍，仅耗时106天。自2020年3月12日最低价0.001158美元以来，最高涨幅超过了400倍。<br>
　　有观点认为，狗狗币的崛起反映了集体信念的力量以及对更理想形式的加密货币的渴望，预示着去中心化必将大兴其道。但狗狗币大涨400倍的背后，其实是名人的带动、散户的狂欢，以及韭菜的博傻心理，狗狗币的泡沫终将破灭。</p>
<h3 id="doge的前世今生">Doge的前世今生</h3>
<p>​		狗狗币是币圈一个独特的存在。2013年12月，美国IBM软件工程师Billy Markus和澳大利亚Adobe工程师Jackson Palmer共同在比特币代码基础上创造了Dogecoin。</p>
<p>极具讽刺的是，两位工程师当年推出狗狗币的目的却是为了“嘲笑”比特币。2013年，比特币价格极速上涨，从以前的一文不值迅速飙升到了几十美元。</p>
<p>如果说比特币是对传统金融体系的反叛，Dogecoin就是对比特币的反叛，它消解了比特币的一个主要特点——总量固定，不可超发。在Palmer和Marcus对比特币规则的修改下，Dogecoin第一年的发行量就有1000亿个，之后几乎每年都增发5%。目前，Dogecoin总量已经接近1300亿枚，是比特币的6000倍。</p>
<p>为了加大嘲讽，Palmer还顺手买了Dogecion.com以对标比特币的bitcoin.com的官网。Markus则给自己的推特取名为shibetoshi Nakaoto，用来讽刺比特币创始人中本聪（Satoshi Nakamoto）。</p>
<p>在今年2月CNET刊发的一篇采访中，Palmer笑道：“我们认为这是注定消亡的一个大玩笑。”</p>
<p>早在2019年4月，Palmer就清空了自己在Twitter账户上发布的内容，以及YouTube上的视频，消失在网络世界。而狗狗币的市值在诞生后的七年里一直排在200名之后。</p>
<p>进入2021年，狗狗币突然火了，而且是大火特火。数据统计回溯狗狗币价格发现，狗狗币2021年1月1日开盘报0.004619美元/枚，2021年4月16日最高报价已触及0.47美元/枚，日内暴涨200%，年内价格暴涨超100倍，仅耗时106天。自2020年3月12日最低价0.001158美元以来，最高涨幅超过了400倍。</p>
<h3 id="散户和马斯克">散户和马斯克</h3>
<p>​		目前看来，狗狗币的此次“出圈”有两大主要推手：一是社交媒体平台Reddit旗下WSB社区聚集的美国散户；二是特斯拉创始人埃隆马斯克。</p>
<p>今天1月，美股上演史上最大的“散户VS机构”大战，即GME（GameStop）保卫战。</p>
<p>WallStreetBets（简称WSB）散户集体把18美元的游戏零售商股票GME硬是推到了483美元，爆了华尔街一堆做空机构的大量仓位，在全球金融市场掀起轩然大波。</p>
<p>不久之后，WSB对股票市场的狂热蔓延至狗狗币。1月28日，推特用户“WSBChairman”问其75万关注者，“狗狗币曾经达到过1美元吗”，Reddit用户纷纷响应，呼吁大家要像买GME股票一样买Dogecoin，持币不售，目标是“1 Dogecoin=1美元”。随后，狗狗币出现了一个巨大的价格反弹，从0.01美元的低位升至0.087美元的峰值。</p>
<p>​		狗狗币价格狂涨，特斯拉CEO马斯克的“带货”同样功不可没。今年2月4日，马斯克突然发推“Doge”，狗狗币涨幅迅速攀升50%。随后他又连续发布多条与狗狗币有关的推文：“我们不需要成为亿万富翁就能拥有狗狗币，狗狗币才是人民的数字货币。”“我没喝多，也没情绪低落，心里只有狗狗币。”“狗狗币是世界上最有趣的加密货币。”</p>
<p>​		马斯克站台狗狗币，最早可以追溯至2019年4月，狗狗币官方账户在Twitter发起评选狗狗币CEO的投票，马斯克高票当选。随后，马斯克发推文称，狗狗币是他最喜欢的数字货币，并将自己的Twitter账户信息修改为“狗狗币前CEO”。</p>
<p>4月初，马斯克在推特上表示将使用SpaceX把一枚狗狗币带到月球上。消息一出，狗狗币直线拉升，当天大涨15%。</p>
<p>两个星期后，美国最大加密货币交易所Coinbase在纳斯达克交易所直接挂牌上市，成为美国加密货币平台第一股。Coinbase的成功上市带动密货币集体上涨，其中，狗狗币大涨近30%。</p>
<p>​		次日，马斯克发布推文，狗狗币朝着月亮吠叫，并附上了相关图片，狗狗币立马飙升，当日大涨50%。4月16日，狗狗币持续暴涨，24小时内涨幅一度达250%，最高触及0.47美元/枚，总市值一度突破600亿美元。</p>
<p>猛烈涨势之下，越来越多商家表示接受或考虑接受狗狗币支付。NBA球队达拉斯独行侠队从3月4日起开始接受狗狗币付款，球迷可以使用狗狗币购买比赛门票和球队商品。3月7日，该球队老板Mark Cuban发推文称：“达拉斯小牛队已经完成了超过20000个的狗狗币交易，使我们成为世界上最大的狗狗币商家。”4月15日，Mark Cuban再度发推文表示，小牛队将在资产负债表上永久持有狗狗币。目前，使用狗狗币购买球队商品的销售额已超12.2万枚。</p>
<p>​		可以看出的是，狗狗币在美国的社区基础相当牢固。其利用自己超过400倍的涨幅迅速出圈之后，继续获得更多商家支持。</p>
<p>3月30日，美联国际教育集团（METX.US）宣布，公司已启动区块链技术战略计划，并将在平台上为外籍教师引入狗狗币奖励机制。学生可以根据教师的教学表现奖励他们，教师也可以通过执行在公司平台上发布的教学和研究任务来获得狗狗币。此外，学生还可以通过完成学业和在平台上分享知识来获得狗狗币。</p>
<p>​		4月19日，士力架巧克力棒的官方推特账号发布了带有#doge day标签的推文，其中包含以狗狗币为主题的包装图。士力架公司还准备为狗狗币投资人推出限量版士力架巧克力棒，并称这只是一个“很酷的GIF图”。</p>
<p>4月20日，狗狗币迎来了自己的纪念日，利好消息不断。当日，知名在线零售商Newegg宣布，将接受狗狗币作为官方支付方式。Newegg高级品牌经理安德鲁·崔（Andrew Choi）表示：“我们致力于简化客户的购物流程，力求为他们提供最适合他们的购物方式，让他们可以选择最适合他们的付款方式来完成交易。为此，我们很高兴为持有狗狗币的粉丝提供方便的在线购买方式。”</p>
<p>​		美可味巧克力（Milky Way）则在推特上发布一条狗狗币与巧克力棒亲密接触消息，并把加密行业里常说的“To the Moon”改为了“To the Milky Way”。此外，超过13万人签署了Change.org上的一份请愿书，呼吁亚马逊接受狗狗币作为付款方式。</p>
<p>当天，美国饶舌巨星Snoop Dogg与Shiba-Inu（原始Doge表情中的那只狗）在YouTube上发布了一个名为“Snoop Dogg 420 DogeCoin Video”的音乐视频。这位歌手还在推特上艾特了马斯克这位狗狗币的最大推手，祝贺他参加4月20日“Doge Day”。</p>
<h3 id="泡沫终将破灭">泡沫终将破灭</h3>
<p>​		公开数据显示，今年以来，狗狗币的累计涨幅达到了7000%。4月21日，Coin Metrics联合创始人Nic Carter发推文称，在过去一周，有8.72亿枚5年多未移动的狗狗币（相当于2.87亿美元）重新进入流通。</p>
<p>这种数据表明，大户开始高位抛售，割韭菜的故事开始上演。自创历史新高的0.47美金之后，狗狗币价格一路下跌，4月26日约为0.27美金，较历史新高的跌幅高达42.6%。</p>
<p>狗狗币的大起大落引起了多位加密货币行业资深人士的质疑，认为它的泡沫实在太大，过多的被吹捧。他们告诫投资人，不该孤注一掷地押注于狗狗币，担心少数大型持有者控制了狗狗币的大部分供应。</p>
<p>实际上，狗狗币的筹码十分集中，近70%的狗狗币分布在世界各地约100个钱包中，其中最大的一个钱包控制了30%左右的狗狗币。</p>
<p>英国投资应用Freetrade的分析师David Kimberley认为，狗狗币的崛起是证明经济学博傻理论的一个经典例子。人们买狗狗币，不是因为他们认为狗狗币有任何意义或价值，而是因为他们希望其他人会涌入，推高价格，然后他们可以趁机卖出，迅速赚一笔钱。“当每个人都这么做的时候，泡沫最终会破裂，如果你不及时退出，就会被亏本。”</p>
<p>“由于马斯克的努力带货和鲸鱼对市场的操纵，狗狗币的价格已经变得非常高，这是一个泡沫。狗狗币的上涨是不可持续的，它将崩溃，大量散户资金将很快损失。”Cardano创始人Charles Hoskinson认为，在泡沫破裂后，狗狗币将成为监管者和立法者介入加密行业的催化剂，这不是一件好事。“狗狗币没有稳定的开发团队，也没有独创的技术。在必然来临的泡沫破裂之后，国会将展开调查，美国SEC将四处奔走，各种各样的监管机构会到处说：这证明加密货币无法控制自己，我们需要进来救你。”</p>
<p>根据coinmarketcap网站数据，目前全球仍有2109种数字货币在交易所交易，其中相当多的数字货币属于某一个企业所“研发”，它们背后拥有大股东的权力，违背了区块链的“去中心化”理念。</p>
<p>Real Vision创始人兼首席执行官Raoul Pal日前透露了自己持有的加密资产组合，“我现在的资产50%是比特币，30%是以太坊，20%是其他代币，我试图在整个加密领域中保持平衡，因为我真的不知道在这个领域中什么币会赢，什么币不会赢。”关于最近大热的狗狗币，Pal表示：“它会永远持续下去吗？谁知道呢？但是我买了一些狗狗币，因为人群在涌入。”</p>
<p>原标题：全面复盘：狗狗币是如何上涨400倍的？ 来源：链新</p>
]]></content>
    </entry>
</feed>