<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://cm940324.github.io</id>
    <title>Oasis</title>
    <updated>2021-05-13T07:05:40.452Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://cm940324.github.io"/>
    <link rel="self" href="https://cm940324.github.io/atom.xml"/>
    <subtitle>&lt;a href=&quot;https://cm940324.github.io/&quot; target=&quot;_blank&quot;&gt;code blog&lt;/a&gt;</subtitle>
    <logo>https://cm940324.github.io/images/avatar.png</logo>
    <icon>https://cm940324.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Oasis</rights>
    <entry>
        <title type="html"><![CDATA[AmazonS3工具类]]></title>
        <id>https://cm940324.github.io/post/amazons3-util/</id>
        <link href="https://cm940324.github.io/post/amazons3-util/">
        </link>
        <updated>2021-05-13T07:00:29.000Z</updated>
        <content type="html"><![CDATA[<pre><code>/**
 * @author chenmo
 * @Date: Created in 2021/5/12 5:05 下午
 * @Utils: Intellij Idea
 * @Description: TODO
 */
@Component
@RequiredArgsConstructor
public class AmazonS3Operator {

    private static final Logger LOGGER = LoggerFactory.getLogger(AmazonS3Operator.class);

    final AmazonS3Configuration amazonS3Configuration;

    //创建链接
    public AmazonS3 createConnection(){
        var credentials = new BasicAWSCredentials(amazonS3Configuration.getAccessKey(), amazonS3Configuration.getSecretKey());
        var conn = new AmazonS3Client(credentials);
        conn.setEndpoint(amazonS3Configuration.getEndPoint());
        var buckets = conn.listBuckets();
        LOGGER.info(&quot;amazonS3 bucket list ==========================================&quot;);
        for (Bucket bucket : buckets) {
            LOGGER.info(&quot;amazonS3 bucket =========&gt;&quot;+bucket.getName() + &quot;\t&quot; +
                    StringUtils.fromDate(bucket.getCreationDate()));
        }
        LOGGER.info(&quot;================================================================&quot;);
        return conn;
    }

    //创建Bucket
    public Bucket createBucket(String name){
        return createConnection().createBucket(name);
    }

    //上传一个文件
    public String uploadFileToBucket(MultipartFile multipartFile){
        var snowflake = new Snowflake(1,1);
        var key = snowflake.nextIdStr();
        FileInputStream fileInputStream = null;
        try {
            fileInputStream = (FileInputStream) multipartFile.getInputStream();
            createConnection().putObject(amazonS3Configuration.getBucket(),key,fileInputStream,new ObjectMetadata());
            LOGGER.info(&quot;上传文件&quot;+key+&quot;：&quot;+multipartFile.getName()+ &quot;到&quot;+amazonS3Configuration.getBucket()+&quot;成功！！！！&quot;);
            return key;
        }catch (FileNotFoundException e){
            LOGGER.info(&quot;上传文件&quot;+key+&quot;：&quot;+multipartFile.getName()+  &quot;到&quot;+amazonS3Configuration.getBucket()+&quot;失败，文件未找到&quot;);
            return null;
        }catch (IOException e){
            e.printStackTrace();
            return null;
        }finally {
            try {
                if(fileInputStream != null){
                    fileInputStream.close();
                }
            }catch (IOException e){
                LOGGER.debug(&quot;inputStream close IOException:&quot; + e.getMessage());
                e.printStackTrace();
            }
        }
    }

    //预览一个文件
    public String reviewFileFromBucket(String key){
        try {
            if(StringUtils.isNullOrEmpty(key)){
                return null;
            }
            var httpRequest = new GeneratePresignedUrlRequest(amazonS3Configuration.getBucket(), key);
            return createConnection().generatePresignedUrl(httpRequest).toString();
        }catch (Exception e){
            e.printStackTrace();
        }
        return null;
    }

}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式的学习]]></title>
        <id>https://cm940324.github.io/post/design-study/</id>
        <link href="https://cm940324.github.io/post/design-study/">
        </link>
        <updated>2021-05-09T09:21:27.000Z</updated>
        <content type="html"><![CDATA[<h3 id="设计模式的目的">设计模式的目的</h3>
<p>编写软件过程中，程序员面临着来自 耦合性，内聚性以及可维护性，可扩展性，重用性，灵活性 等多方面的挑战，设计模式是为了让程序(软件)具有更好的:</p>
<ol>
<li>
<p>代码重用性 (即：相同功能的代码，不用多次编写)</p>
</li>
<li>
<p>可读性 (即：编程规范性, 便于其他程序员的阅读和理解)</p>
</li>
<li>
<p>可扩展性 (即：当需要增加新的功能时，非常的方便，称为可维护)</p>
</li>
<li>
<p>可靠性 (即：当我们增加新的功能后，对原来的功能没有影响)</p>
</li>
<li>
<p>使程序呈现高内聚，低耦合的特性</p>
</li>
</ol>
<pre><code>“懂了设计模式，你就懂了面向对象分析和设计（OOA/D）的精要” ----设计模式包含了面向对象的精髓

“C++老手和 C++新手的区别就是前者手背上有很多伤疤” ----Scott Mayers 在其巨著《Effective C++》
</code></pre>
<h3 id="设计模式七大原则">设计模式七大原则</h3>
<p>设计模式原则，其实就是程序员在编程时，应当遵守的原则，也是各种设计模式的基础(即：设计模式为什么这样设计的依据)</p>
<p><mark>Ø 设计模式常用的七大原则有:</mark></p>
<ol>
<li>
<p>单一职责原则</p>
</li>
<li>
<p>接口隔离原则</p>
</li>
<li>
<p>依赖倒转(倒置)原则</p>
</li>
<li>
<p>里氏替换原则</p>
</li>
<li>
<p>开闭原则</p>
</li>
<li>
<p>迪米特法则</p>
</li>
<li>
<p>合成复用原则</p>
</li>
</ol>
<h4 id="单一职责原则">单一职责原则</h4>
<h5 id="基本介绍">基本介绍</h5>
<p>对类来说的，即一个类应该只负责一项职责。如类 A 负责两个不同职责：职责 1，职责 2。当职责 1 需求变更而改变 A 时，可能造成职责 2 执行错误，所以需要将类 A 的粒度分解为 A1，A2</p>
<h5 id="应用实例">应用实例</h5>
<p><strong>方案一:</strong></p>
<pre><code>// 1. 在方式 1 的 run 方法中，违反了单一职责原则
// 2. 解决的方案非常的简单，根据交通工具运行方法不同，分解成不同类即可
public class SingleResponsibility1{
	public static void main(String[] args){
		Vehicle vehicle = new Vehicle();
		vehicle.run(&quot;摩托车&quot;);
		vehicle.run(&quot;汽车&quot;);
		vehicle.run(&quot;飞机&quot;);
	}
}
class Vehicle {
	public void run(String vehicle) { 
			System.out.println(vehicle + &quot; 在公路上运行....&quot;);
	}
}

</code></pre>
<p><strong>方案二</strong></p>
<pre><code>//方案 2 的分析
//1. 遵守单一职责原则
//2. 但是这样做的改动很大，即将类分解，同时修改客户端
//3. 改进：直接修改 Vehicle 类，改动的代码会比较少=&gt;方案 3
public class SingleResponsibility1{
	public static void main(String[] args){
		RoadVehicle roadVehicle = new RoadVehicle();
		roadVehicle.run(&quot;摩托车&quot;);
		roadVehicle.run(&quot;汽车&quot;);
		AirVehicle airVehicle = new AirVehicle();
		airVehicle.run(&quot;飞机&quot;);
	}
}
class RoadVehicle {
	public void run(String vehicle) { 
		System.out.println(vehicle + &quot;公路运行&quot;);
	}
}


class AirVehicle {
	public void run(String vehicle) { 
		System.out.println(vehicle + &quot;天空运行&quot;);
	}
}

</code></pre>
<p><strong>方案三</strong></p>
<pre><code>//方式 3 的分析
//1. 这种修改方法没有对原来的类做大的修改，只是增加方法
//2. 这里虽然没有在类这个级别上遵守单一职责原则，但是在方法级别上，仍然是遵守单一职责
public class SingleResponsibility3 {
	public static void main(String[] args) {
		Vehicle2 vehicle2	= new Vehicle2();
		vehicle2.run(&quot;汽车&quot;);
		vehicle2.runWater(&quot;轮船&quot;);
		vehicle2.runAir(&quot;飞机&quot;);
	}
}
class Vehicle2 {
	public void run(String vehicle) {
		//处理
		System.out.println(vehicle + &quot; 在公路上运行....&quot;);
	}
	public void runAir(String vehicle) { 
		System.out.println(vehicle + &quot; 在天空上运行....&quot;);
	}
	public void runWater(String vehicle) { 
		System.out.println(vehicle + &quot; 在水中行....&quot;);
	}
}
</code></pre>
<pre><code>单一职责原则注意事项和细节
1)	降低类的复杂度，一个类只负责一项职责。
2)	提高类的可读性，可维护性
3)	降低变更引起的风险
4)	通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则
</code></pre>
<h4 id="接口隔离原则interface-segregation-principle">接口隔离原则(Interface Segregation Principle)</h4>
<h5 id="基本介绍-2">基本介绍</h5>
<ol>
<li>客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上</li>
<li>类 A 通过接口 Interface1 依赖类 B，类 C 通过接口 Interface1 依赖类 D，如果接口 Interface1 对于类 A 和类 C来说不是最小接口，那么类 B 和类 D 必须去实现他们不需要的方法。</li>
</ol>
<pre><code>public class Segregation1 {

public static void main(String[] args) {
// TODO Auto-generated method stub
}

}

//接口
interface Interface1 {
void operation1(); void operation2();
 

void operation3(); void operation4(); void operation5();
}


class B implements Interface1 { public void operation1() {
System.out.println(&quot;B 实现了 operation1&quot;);
}
public void operation2() {
System.out.println(&quot;B 实现了 operation2&quot;);
}
public void operation3() {
System.out.println(&quot;B 实现了 operation3&quot;);
}
public void operation4() {
System.out.println(&quot;B 实现了 operation4&quot;);
}
public void operation5() {
System.out.println(&quot;B 实现了 operation5&quot;);
}
}

class D implements Interface1 { public void operation1() {
System.out.println(&quot;D 实现了 operation1&quot;);
}
public void operation2() {
System.out.println(&quot;D 实现了 operation2&quot;);
}
public void operation3() {
System.out.println(&quot;D 实现了 operation3&quot;);
}
public void operation4() {
System.out.println(&quot;D 实现了  operation4&quot;);
}
public void  operation5()  { System.out.println(&quot;D 实现了  operation5&quot;);
}
}

class A { //A 类通过接口 Interface1 依赖(使用) B 类，但是只会用到 1,2,3 方法
public void depend1(Interface1 i) { i.operation1();
}
public void depend2(Interface1 i) { i.operation2();
}
public void depend3(Interface1 i) { i.operation3();
}
}

class C { //C 类通过接口 Interface1  依赖(使用) D 类，但是只会用到 1,4,5 方法
public void depend1(Interface1 i) { i.operation1();
}
public void depend4(Interface1 i) { i.operation4();
}
public void depend5(Interface1 i) { i.operation5();
}
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PostgreSQL自带全文检索]]></title>
        <id>https://cm940324.github.io/post/postgresql-jiansuo/</id>
        <link href="https://cm940324.github.io/post/postgresql-jiansuo/">
        </link>
        <updated>2021-05-06T08:38:50.000Z</updated>
        <content type="html"><![CDATA[<h3 id="相关文档">相关文档</h3>
<pre><code>文本搜索的函数与操作符中文说明: 
http://www.postgres.cn/docs/9.3.4/functions-textsearch.html
PostgreSQL 文本搜索文档 : 
https://www.postgresql.org/docs/9.4/textsearch-controls.html
</code></pre>
<h3 id="核心函数-关键字">核心函数、关键字</h3>
<p>全文搜索的思想主要分两步：</p>
<ul>
<li>
<p>将文本解析为对应的倒排索引</p>
</li>
<li>
<p>搜索索引来找到对应的文本</p>
</li>
</ul>
<p>要使用 PostgreSQL 的全文搜索, 那么就要了解到底是要用什么关键字和函数来<strong>构建索引</strong>和<strong>搜索</strong>， 这里主要涉及到<strong>一个关键字</strong>和<strong>四个函数</strong><br>
可以看上边的文档了解函数的具体参数</p>
<p><strong>关键字 tsvector:</strong><br>
tsvector 是 PostgreSQL 内置的一种字段类型, 用来保存的是分词后的结果 (文本向量) 它是由 [词，序列， 权重] 三个东西共同组成的， 权重可能会没有</p>
<p><strong>函数:</strong></p>
<ul>
<li>
<p>to_tsvector()</p>
<ul>
<li>分词用, 将文本转为向量。 用它可以将字符串转成上边说的 tsvector , 遗憾的是默认不支持中文分词</li>
</ul>
</li>
<li>
<p>to_tsquery()</p>
<ul>
<li>构建搜索的关键字， 支持各种符号表示条件。 详情查看文档</li>
</ul>
</li>
<li>
<p>setweight()</p>
<ul>
<li>设置关键词权重， 总共四个权重从高到低为 A-B-C-D</li>
</ul>
</li>
<li>
<p>ts_rank ()</p>
<ul>
<li>排序用， 可以根据 to_tsquery 和 tsvector 的匹配度计算</li>
</ul>
<pre><code>//查询表中包含 aaa 并且包含 BBB或CCC任意一个 的记录
  SELECT * FROM table
  WHERE to_tsvector('parser_name', field) @@ to_tsquery('aaa &amp; (bbb | ccc)')
</code></pre>
</li>
</ul>
<p><strong>索引:</strong></p>
<p>建立联合索引</p>
<pre><code>create index document_title_idx on encms.article using gin (to_tsvector('english',&quot;content&quot; || &quot;title&quot;) tsvector_ops)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[全面复盘：狗狗币是如何上涨400倍的？ ]]></title>
        <id>https://cm940324.github.io/post/doge/</id>
        <link href="https://cm940324.github.io/post/doge/">
        </link>
        <updated>2021-05-05T04:17:59.000Z</updated>
        <content type="html"><![CDATA[<pre><code>    ​
 4月20日，狗狗币纪念日。美国知名财经媒体在首页刊登了狗狗币相关报道，标题为《狗狗币交易赶上线上狂潮》，其中提到狗狗币在2021年的回报率超过8100%，是1998年以来标普500涨幅的2倍多，狗狗币市值大约为500亿美元，超过了万豪国际和福特汽车。
</code></pre>
<p>狗狗币2021年1月1日开盘报0.004619美元/枚，2021年4月16日最高报价已触及0.47美元/枚，日内暴涨200%，年内价格暴涨超100倍，仅耗时106天。自2020年3月12日最低价0.001158美元以来，最高涨幅超过了400倍。<br>
　　有观点认为，狗狗币的崛起反映了集体信念的力量以及对更理想形式的加密货币的渴望，预示着去中心化必将大兴其道。但狗狗币大涨400倍的背后，其实是名人的带动、散户的狂欢，以及韭菜的博傻心理，狗狗币的泡沫终将破灭。</p>
<h3 id="doge的前世今生">Doge的前世今生</h3>
<p>​		狗狗币是币圈一个独特的存在。2013年12月，美国IBM软件工程师Billy Markus和澳大利亚Adobe工程师Jackson Palmer共同在比特币代码基础上创造了Dogecoin。</p>
<p>极具讽刺的是，两位工程师当年推出狗狗币的目的却是为了“嘲笑”比特币。2013年，比特币价格极速上涨，从以前的一文不值迅速飙升到了几十美元。</p>
<p>如果说比特币是对传统金融体系的反叛，Dogecoin就是对比特币的反叛，它消解了比特币的一个主要特点——总量固定，不可超发。在Palmer和Marcus对比特币规则的修改下，Dogecoin第一年的发行量就有1000亿个，之后几乎每年都增发5%。目前，Dogecoin总量已经接近1300亿枚，是比特币的6000倍。</p>
<p>为了加大嘲讽，Palmer还顺手买了Dogecion.com以对标比特币的bitcoin.com的官网。Markus则给自己的推特取名为shibetoshi Nakaoto，用来讽刺比特币创始人中本聪（Satoshi Nakamoto）。</p>
<p>在今年2月CNET刊发的一篇采访中，Palmer笑道：“我们认为这是注定消亡的一个大玩笑。”</p>
<p>早在2019年4月，Palmer就清空了自己在Twitter账户上发布的内容，以及YouTube上的视频，消失在网络世界。而狗狗币的市值在诞生后的七年里一直排在200名之后。</p>
<p>进入2021年，狗狗币突然火了，而且是大火特火。数据统计回溯狗狗币价格发现，狗狗币2021年1月1日开盘报0.004619美元/枚，2021年4月16日最高报价已触及0.47美元/枚，日内暴涨200%，年内价格暴涨超100倍，仅耗时106天。自2020年3月12日最低价0.001158美元以来，最高涨幅超过了400倍。</p>
<h3 id="散户和马斯克">散户和马斯克</h3>
<p>​		目前看来，狗狗币的此次“出圈”有两大主要推手：一是社交媒体平台Reddit旗下WSB社区聚集的美国散户；二是特斯拉创始人埃隆马斯克。</p>
<p>今天1月，美股上演史上最大的“散户VS机构”大战，即GME（GameStop）保卫战。</p>
<p>WallStreetBets（简称WSB）散户集体把18美元的游戏零售商股票GME硬是推到了483美元，爆了华尔街一堆做空机构的大量仓位，在全球金融市场掀起轩然大波。</p>
<p>不久之后，WSB对股票市场的狂热蔓延至狗狗币。1月28日，推特用户“WSBChairman”问其75万关注者，“狗狗币曾经达到过1美元吗”，Reddit用户纷纷响应，呼吁大家要像买GME股票一样买Dogecoin，持币不售，目标是“1 Dogecoin=1美元”。随后，狗狗币出现了一个巨大的价格反弹，从0.01美元的低位升至0.087美元的峰值。</p>
<p>​		狗狗币价格狂涨，特斯拉CEO马斯克的“带货”同样功不可没。今年2月4日，马斯克突然发推“Doge”，狗狗币涨幅迅速攀升50%。随后他又连续发布多条与狗狗币有关的推文：“我们不需要成为亿万富翁就能拥有狗狗币，狗狗币才是人民的数字货币。”“我没喝多，也没情绪低落，心里只有狗狗币。”“狗狗币是世界上最有趣的加密货币。”</p>
<p>​		马斯克站台狗狗币，最早可以追溯至2019年4月，狗狗币官方账户在Twitter发起评选狗狗币CEO的投票，马斯克高票当选。随后，马斯克发推文称，狗狗币是他最喜欢的数字货币，并将自己的Twitter账户信息修改为“狗狗币前CEO”。</p>
<p>4月初，马斯克在推特上表示将使用SpaceX把一枚狗狗币带到月球上。消息一出，狗狗币直线拉升，当天大涨15%。</p>
<p>两个星期后，美国最大加密货币交易所Coinbase在纳斯达克交易所直接挂牌上市，成为美国加密货币平台第一股。Coinbase的成功上市带动密货币集体上涨，其中，狗狗币大涨近30%。</p>
<p>​		次日，马斯克发布推文，狗狗币朝着月亮吠叫，并附上了相关图片，狗狗币立马飙升，当日大涨50%。4月16日，狗狗币持续暴涨，24小时内涨幅一度达250%，最高触及0.47美元/枚，总市值一度突破600亿美元。</p>
<p>猛烈涨势之下，越来越多商家表示接受或考虑接受狗狗币支付。NBA球队达拉斯独行侠队从3月4日起开始接受狗狗币付款，球迷可以使用狗狗币购买比赛门票和球队商品。3月7日，该球队老板Mark Cuban发推文称：“达拉斯小牛队已经完成了超过20000个的狗狗币交易，使我们成为世界上最大的狗狗币商家。”4月15日，Mark Cuban再度发推文表示，小牛队将在资产负债表上永久持有狗狗币。目前，使用狗狗币购买球队商品的销售额已超12.2万枚。</p>
<p>​		可以看出的是，狗狗币在美国的社区基础相当牢固。其利用自己超过400倍的涨幅迅速出圈之后，继续获得更多商家支持。</p>
<p>3月30日，美联国际教育集团（METX.US）宣布，公司已启动区块链技术战略计划，并将在平台上为外籍教师引入狗狗币奖励机制。学生可以根据教师的教学表现奖励他们，教师也可以通过执行在公司平台上发布的教学和研究任务来获得狗狗币。此外，学生还可以通过完成学业和在平台上分享知识来获得狗狗币。</p>
<p>​		4月19日，士力架巧克力棒的官方推特账号发布了带有#doge day标签的推文，其中包含以狗狗币为主题的包装图。士力架公司还准备为狗狗币投资人推出限量版士力架巧克力棒，并称这只是一个“很酷的GIF图”。</p>
<p>4月20日，狗狗币迎来了自己的纪念日，利好消息不断。当日，知名在线零售商Newegg宣布，将接受狗狗币作为官方支付方式。Newegg高级品牌经理安德鲁·崔（Andrew Choi）表示：“我们致力于简化客户的购物流程，力求为他们提供最适合他们的购物方式，让他们可以选择最适合他们的付款方式来完成交易。为此，我们很高兴为持有狗狗币的粉丝提供方便的在线购买方式。”</p>
<p>​		美可味巧克力（Milky Way）则在推特上发布一条狗狗币与巧克力棒亲密接触消息，并把加密行业里常说的“To the Moon”改为了“To the Milky Way”。此外，超过13万人签署了Change.org上的一份请愿书，呼吁亚马逊接受狗狗币作为付款方式。</p>
<p>当天，美国饶舌巨星Snoop Dogg与Shiba-Inu（原始Doge表情中的那只狗）在YouTube上发布了一个名为“Snoop Dogg 420 DogeCoin Video”的音乐视频。这位歌手还在推特上艾特了马斯克这位狗狗币的最大推手，祝贺他参加4月20日“Doge Day”。</p>
<h3 id="泡沫终将破灭">泡沫终将破灭</h3>
<p>​		公开数据显示，今年以来，狗狗币的累计涨幅达到了7000%。4月21日，Coin Metrics联合创始人Nic Carter发推文称，在过去一周，有8.72亿枚5年多未移动的狗狗币（相当于2.87亿美元）重新进入流通。</p>
<p>这种数据表明，大户开始高位抛售，割韭菜的故事开始上演。自创历史新高的0.47美金之后，狗狗币价格一路下跌，4月26日约为0.27美金，较历史新高的跌幅高达42.6%。</p>
<p>狗狗币的大起大落引起了多位加密货币行业资深人士的质疑，认为它的泡沫实在太大，过多的被吹捧。他们告诫投资人，不该孤注一掷地押注于狗狗币，担心少数大型持有者控制了狗狗币的大部分供应。</p>
<p>实际上，狗狗币的筹码十分集中，近70%的狗狗币分布在世界各地约100个钱包中，其中最大的一个钱包控制了30%左右的狗狗币。</p>
<p>英国投资应用Freetrade的分析师David Kimberley认为，狗狗币的崛起是证明经济学博傻理论的一个经典例子。人们买狗狗币，不是因为他们认为狗狗币有任何意义或价值，而是因为他们希望其他人会涌入，推高价格，然后他们可以趁机卖出，迅速赚一笔钱。“当每个人都这么做的时候，泡沫最终会破裂，如果你不及时退出，就会被亏本。”</p>
<p>“由于马斯克的努力带货和鲸鱼对市场的操纵，狗狗币的价格已经变得非常高，这是一个泡沫。狗狗币的上涨是不可持续的，它将崩溃，大量散户资金将很快损失。”Cardano创始人Charles Hoskinson认为，在泡沫破裂后，狗狗币将成为监管者和立法者介入加密行业的催化剂，这不是一件好事。“狗狗币没有稳定的开发团队，也没有独创的技术。在必然来临的泡沫破裂之后，国会将展开调查，美国SEC将四处奔走，各种各样的监管机构会到处说：这证明加密货币无法控制自己，我们需要进来救你。”</p>
<p>根据coinmarketcap网站数据，目前全球仍有2109种数字货币在交易所交易，其中相当多的数字货币属于某一个企业所“研发”，它们背后拥有大股东的权力，违背了区块链的“去中心化”理念。</p>
<p>Real Vision创始人兼首席执行官Raoul Pal日前透露了自己持有的加密资产组合，“我现在的资产50%是比特币，30%是以太坊，20%是其他代币，我试图在整个加密领域中保持平衡，因为我真的不知道在这个领域中什么币会赢，什么币不会赢。”关于最近大热的狗狗币，Pal表示：“它会永远持续下去吗？谁知道呢？但是我买了一些狗狗币，因为人群在涌入。”</p>
<p>原标题：全面复盘：狗狗币是如何上涨400倍的？ 来源：链新</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[理解、学习与使用 JAVA 中的 OPTIONAL]]></title>
        <id>https://cm940324.github.io/post/java8-optional/</id>
        <link href="https://cm940324.github.io/post/java8-optional/">
        </link>
        <updated>2021-04-26T06:14:05.000Z</updated>
        <content type="html"><![CDATA[<p>​		从 Java 8 引入的一个很有趣的特性是 <em>Optional</em>  类。Optional 类主要解决的问题是臭名昭著的空指针异常（NullPointerException） —— 每个 Java 程序员都非常了解的异常。</p>
<p>​		本质上，这是一个包含有可选值的包装类，这意味着 Optional 类既可以含有对象也可以为空。Optional 是 Java 实现函数式编程的强劲一步，并且帮助在范式中实现。但是 Optional 的意义显然不止于此。</p>
<pre><code>if (user != null) {
    Address address = user.getAddress();
    if (address != null) {
        Country country = address.getCountry();
        if (country != null) {
            String isocode = country.getIsocode();
            if (isocode != null) {
                isocode = isocode.toUpperCase();
            }
        }
    }
}
</code></pre>
<p>​		你看到了，这很容易就变得冗长，难以维护。</p>
<p>​		为了简化这个过程，我们来看看用 <em>Optional</em> 类是怎么做的。从创建和验证实例，到使用其不同的方法，并与其它返回相同类型的方法相结合，下面是见证 <em>Optional</em>  奇迹的时刻。</p>
<h3 id="创建-optional-实例">创建 <em>Optional</em> 实例</h3>
<p>​		重申一下，这个类型的对象可能包含值，也可能为空。你可以使用同名方法创建一个空的 Optional.</p>
<pre><code>@Test(expected = NoSuchElementException.class)
public void whenCreateEmptyOptional_thenNull() {
    Optional&lt;User&gt; emptyOpt = Optional.empty();
    emptyOpt.get();
}
</code></pre>
<p>​		毫不奇怪，尝试访问 <em>emptyOpt</em> 变量的值会导致 <em>NoSuchElementException</em>。</p>
<p>​		你可以使用 <em>of()</em> 和 ofNullable() 方法创建包含值的 <em>Optional</em>。两个方法的不同之处在于如果你把 <em>null</em> 值作为参数传递进去，<em>of()</em> 方法会抛出 <em>NullPointerException</em>：</p>
<pre><code>@Test(expected = NullPointerException.class)
public void whenCreateOfEmptyOptional_thenNullPointerException() {
    Optional&lt;User&gt; opt = Optional.of(user);
}
</code></pre>
<p>​		你看，我们并没有完全摆脱 <em>NullPointerException</em>。因此，你应该明确对象不为 <em>null</em> 的时候使用 <em>of()</em>。</p>
<p>如果对象即可能是 <em>null</em> 也可能是非 null，你就应该使用 <em>ofNullable()</em> 方法：</p>
<pre><code>Optional&lt;User&gt; opt = Optional.ofNullable(user);
</code></pre>
<h3 id="访问-optional-对象的值">访问 <em>Optional</em> 对象的值</h3>
<p>​		从 <em>Optional</em> 实例中取回实际值对象的方法之一是使用 <em>get()</em> 方法：</p>
<pre><code>@Test
public void whenCreateOfNullableOptional_thenOk() {
    String name = &quot;John&quot;;
    Optional&lt;String&gt; opt = Optional.ofNullable(name);
    assertEquals(&quot;John&quot;, opt.get());
}
</code></pre>
<p>​		不过，你看到了，这个方法会在值为 <em>null</em> 的时候抛出异常。要避免异常，你可以选择首先验证是否有值：</p>
<pre><code>@Test
public void whenCheckIfPresent_thenOk() {
    User user = new User(&quot;john@gmail.com&quot;, &quot;1234&quot;);
    Optional&lt;User&gt; opt = Optional.ofNullable(user);
    assertTrue(opt.isPresent());
    assertEquals(user.getEmail(), opt.get().getEmail());
}
</code></pre>
<p>​		检查是否有值的另一个选择是 <em>ifPresent()</em> 方法。该方法除了执行检查，还接受一个<em>Consumer(消费者</em>) 参数，如果对象不是空的，就对执行传入的 Lambda 表达式：</p>
<pre><code>opt.ifPresent( u -&gt; assertEquals(user.getEmail(), u.getEmail()));
</code></pre>
<p>​		这个例子中，只有 user 用户不为 null 的时候才会执行断言。</p>
<p>​		接下来，我们来看看提供空值的方法。</p>
<h3 id="返回默认值">返回默认值</h3>
<p>​		<em>Optional</em> 类提供了 API 用以返回对象值，或者在对象为空的时候返回默认值。</p>
<p>​		这里你可以使用的第一个方法是 <em>orElse()</em>，它的工作方式非常直接，如果有值则返回该值，否则返回传递给它的参数值：</p>
<pre><code>@Test
public void whenEmptyValue_thenReturnDefault() {
    User user = null;
    User user2 = new User(&quot;anna@gmail.com&quot;, &quot;1234&quot;);
    User result = Optional.ofNullable(user).orElse(user2);

    assertEquals(user2.getEmail(), result.getEmail());
}
</code></pre>
<p>​		这里 <em>user</em> 对象是空的，所以返回了作为默认值的 <em>user2</em>。</p>
<p>​		如果对象的初始值不是 null，那么默认值会被忽略：</p>
<pre><code>@Test
public void whenValueNotNull_thenIgnoreDefault() {
    User user = new User(&quot;john@gmail.com&quot;,&quot;1234&quot;);
    User user2 = new User(&quot;anna@gmail.com&quot;, &quot;1234&quot;);
    User result = Optional.ofNullable(user).orElse(user2);

    assertEquals(&quot;john@gmail.com&quot;, result.getEmail());
}
</code></pre>
<p>​		第二个同类型的 API 是 <em>orElseGet()</em> —— 其行为略有不同。这个方法会在有值的时候返回值，如果没有值，它会执行作为参数传入的 <em>Supplier(供应者)</em> 函数式接口，并将返回其执行结果：</p>
<pre><code>User result = Optional.ofNullable(user).orElseGet( () -&gt; user2);
</code></pre>
<p>​		<em>orElse()</em> 和 <em>orElseGet()</em> 的不同之处</p>
<p>​		乍一看，这两种方法似乎起着同样的作用。然而事实并非如此。我们创建一些示例来突出二者行为上的异同。</p>
<p>我们先来看看对象为空时他们的行为：</p>
<pre><code>@Test
public void givenEmptyValue_whenCompare_thenOk() {
    User user = null
    logger.debug(&quot;Using orElse&quot;);
    User result = Optional.ofNullable(user).orElse(createNewUser());
    logger.debug(&quot;Using orElseGet&quot;);
    User result2 = Optional.ofNullable(user).orElseGet(() -&gt; createNewUser());
}

private User createNewUser() {
    logger.debug(&quot;Creating New User&quot;);
    return new User(&quot;extra@gmail.com&quot;, &quot;1234&quot;);
}
</code></pre>
<p>​		上面的代码中，两种方法都调用了 <em>createNewUser()</em> 方法，这个方法会记录一个消息并返回 <em>User</em> 对象。</p>
<p>代码输出如下：</p>
<pre><code>Using orElse
Creating New User
Using orElseGet
Creating New User
</code></pre>
<p>​		由此可见，当对象为空而返回默认对象时，行为并无差异。</p>
<p>​</p>
<p>​		我们接下来看一个类似的示例，但这里 <em>Optional</em>  不为空：</p>
<pre><code>@Test
public void givenPresentValue_whenCompare_thenOk() {
    User user = new User(&quot;john@gmail.com&quot;, &quot;1234&quot;);
    logger.info(&quot;Using orElse&quot;);
    User result = Optional.ofNullable(user).orElse(createNewUser());
    logger.info(&quot;Using orElseGet&quot;);
    User result2 = Optional.ofNullable(user).orElseGet(() -&gt; createNewUser());
}
</code></pre>
<p>​		这次的输出：</p>
<pre><code>Using orElse
Creating New User
Using orElseGet
</code></pre>
<p>​		这个示例中，两个 <em>Optional</em>  对象都包含非空值，两个方法都会返回对应的非空值。不过，<em>orElse()</em> 方法仍然创建了 <em>User</em> 对象。与之相反，<em>orElseGet()</em> 方法不创建 <em>User</em> 对象。</p>
<p>​		在执行较密集的调用时，比如调用 Web 服务或数据查询，这个差异会对性能产生重大影响。</p>
<h3 id="返回异常">返回异常</h3>
<p>​		除了 <em>orElse()</em> 和 <em>orElseGet()</em> 方法，Optional 还定义了 <em>orElseThrow()</em> API —— 它会在对象为空的时候抛出异常，而不是返回备选的值：</p>
<pre><code>@Test(expected = IllegalArgumentException.class)
public void whenThrowException_thenOk() {
    User result = Optional.ofNullable(user)
      .orElseThrow( () -&gt; new IllegalArgumentException());
}
</code></pre>
<p>​		这里，如果 <em>user</em> 值为 null，会抛出 <em>IllegalArgumentException</em>。</p>
<p>​		这个方法让我们有更丰富的语义，可以决定抛出什么样的异常，而不总是抛出 <em>NullPointerException</em>。</p>
<p>​		现在我们已经很好地理解了如何使用 Optional，我们来看看其它可以对 <em>Optional</em> 值进行转换和过滤的方法。</p>
<h3 id="转换值">转换值</h3>
<p>​		有很多种方法可以转换 <em>Optional</em> 的值。我们从 <em>map()</em> 和 <em>flatMap()</em> 方法开始。</p>
<p>先来看一个使用 <em>map()</em> API 的例子：</p>
<pre><code>@Test
public void whenMap_thenOk() {
    User user = new User(&quot;anna@gmail.com&quot;, &quot;1234&quot;);
    String email = Optional.ofNullable(user)
      .map(u -&gt; u.getEmail()).orElse(&quot;default@gmail.com&quot;);

    assertEquals(email, user.getEmail());
}
</code></pre>
<p>​		<em>map()</em> 对值应用(调用)作为参数的<em>函数</em>，然后将返回的值包装在 <em>Optional</em> 中。这就使对返回值进行链试调用的操作成为可能 —— 这里的下一环就是 <em>orElse()</em>。</p>
<p>​		相比这下，<em>flatMap()</em> 也需要<em>函数</em>作为参数，并对值调用这个函数，然后直接返回结果。</p>
<p>​		下面的操作中，我们给 <em>User</em> 类添加了一个方法，用来返回 <em>Optional</em>：</p>
<pre><code>public class User {    
    private String position;

    public Optional&lt;String&gt; getPosition() {
        return Optional.ofNullable(position);
    }

    //...
}
</code></pre>
<p>​		既然 getter 方法返回 String 值的 <em>Optional</em>，你可以在对 <em>User</em> <em>的 Optional</em> 对象调用 <em>flatMap()</em> 时，用它作为参数。其返回的值是解除包装的 String 值</p>
<pre><code>@Test
public void whenFlatMap_thenOk() {
    User user = new User(&quot;anna@gmail.com&quot;, &quot;1234&quot;);
    user.setPosition(&quot;Developer&quot;);
    String position = Optional.ofNullable(user)
      .flatMap(u -&gt; u.getPosition()).orElse(&quot;default&quot;);

    assertEquals(position, user.getPosition().get());
}
</code></pre>
<p>​		过滤值</p>
<p>​		除了转换值之外，<em>Optional</em> 类也提供了按条件“过滤”值的方法。<em>filter()</em> 接受一个 <em>Predicate</em> 参数，返回测试结果为 true 的值。如果测试结果为 false，会返回一个空的 <em>Optional</em>。</p>
<p>来看一个根据基本的电子邮箱验证来决定接受或拒绝 <em>User</em>*(用户)* 的示例：</p>
<pre><code>@Test
public void whenFilter_thenOk() {
    User user = new User(&quot;anna@gmail.com&quot;, &quot;1234&quot;);
    Optional&lt;User&gt; result = Optional.ofNullable(user)
      .filter(u -&gt; u.getEmail() != null &amp;&amp; u.getEmail().contains(&quot;@&quot;));

    assertTrue(result.isPresent());
}
</code></pre>
<p>​		如果通过过滤器测试，<em>result</em> 对象会包含非空值。</p>
<h3 id="optional-类的链式方法"><em>Optional</em> 类的链式方法</h3>
<p>​		为了更充分的使用 <em>Optional</em>，你可以链接组合其大部分方法，因为它们都返回相同类似的对象。</p>
<p>​		我们使用 <em>Optional</em> 重写最早介绍的示例。</p>
<p>​		首先，重构类，使其 getter 方法返回 <em>Optional</em> 引用</p>
<pre><code>public class User {
    private Address address;

    public Optional&lt;Address&gt; getAddress() {
        return Optional.ofNullable(address);
    }

    // ...
}
public class Address {
    private Country country;

    public Optional&lt;Country&gt; getCountry() {
        return Optional.ofNullable(country);
    }

    // ...
}
</code></pre>
<p>​		现在可以删除 <em>null</em> 检查，替换为 <em>Optional</em> 的方法</p>
<pre><code>@Test
public void whenChaining_thenOk() {
    User user = new User(&quot;anna@gmail.com&quot;, &quot;1234&quot;);

    String result = Optional.ofNullable(user)
      .flatMap(u -&gt; u.getAddress())
      .flatMap(a -&gt; a.getCountry())
      .map(c -&gt; c.getIsocode())
      .orElse(&quot;default&quot;);

    assertEquals(result, &quot;default&quot;);
}
</code></pre>
<p>​		上面的代码可以通过方法引用进一步缩减：</p>
<pre><code>String result = Optional.ofNullable(user)
  .flatMap(User::getAddress)
  .flatMap(Address::getCountry)
  .map(Country::getIsocode)
  .orElse(&quot;default&quot;);
</code></pre>
<p>结果现在的代码看起来比之前采用条件分支的冗长代码简洁多了。</p>
<h3 id="java-9-增强">Java 9 增强</h3>
<p>​		我们介绍了 Java 8 的特性，Java 9 为 Optional 类添加了三个方法：<em>or()</em>、<em>ifPresentOrElse()</em> 和 <em>stream()</em>。</p>
<p>​		<em>or()</em> 方法与 <em>orElse()</em> 和 <em>orElseGet()</em> 类似，它们都在对象为空的时候提供了替代情况。<em>or()</em> 的返回值是由 <em>Supplier</em> 参数产生的另一个 <em>Optional</em> 对象。</p>
<p>​		如果对象包含值，则 Lambda 表达式不会执行：</p>
<pre><code>@Test
public void whenEmptyOptional_thenGetValueFromOr() {
    User result = Optional.ofNullable(user)
      .or( () -&gt; Optional.of(new User(&quot;default&quot;,&quot;1234&quot;))).get();

    assertEquals(result.getEmail(), &quot;default&quot;);
}
</code></pre>
<p>​		上面的示例中，如果 <em>user</em> 变量是 null，它会返回一个 <em>Optional</em>，它所包含的 <em>User</em> 对象，其电子邮件为 “default”。</p>
<p><em>ifPresentOrElse()</em> 方法需要两个参数：一个 <em>Consumer</em> 和一个 <em>Runnable</em>。如果对象包含值，会执行 <em>Consumer</em> 的动作，否则运行 <em>Runnable</em>。</p>
<p>​		如果你想在有值的时候执行某个动作，或者只是跟踪是否定义了某个值，那么这个方法非常有用：</p>
<pre><code>Optional.ofNullable(user).ifPresentOrElse( u -&gt; logger.info(&quot;User is:&quot; + u.getEmail()),
  () -&gt; logger.info(&quot;User not found&quot;));
</code></pre>
<p>​		最后介绍的是新的 <em>stream()</em> 方法，它通过把实例转换为 <em>Stream</em> 对象，让你从广大的 <em>Stream</em> API 中受益。如果没有值，它会得到空的 <em>Stream</em>；有值的情况下，<em>Stream</em> 则会包含单一值。</p>
<p>​		我们来看一个把 <em>Optional</em> 处理成 <em>Stream</em> 的例子：</p>
<pre><code>@Test
public void whenGetStream_thenOk() {
    User user = new User(&quot;john@gmail.com&quot;, &quot;1234&quot;);
    List&lt;String&gt; emails = Optional.ofNullable(user)
      .stream()
      .filter(u -&gt; u.getEmail() != null &amp;&amp; u.getEmail().contains(&quot;@&quot;))
      .map( u -&gt; u.getEmail())
      .collect(Collectors.toList());

    assertTrue(emails.size() == 1);
    assertEquals(emails.get(0), user.getEmail());
}
</code></pre>
<p>​		这里对 <em>Stream</em> 的使用带来了其 <em>filter()、map()</em> 和 <em>collect()</em> 接口，以获取 <em>List</em>。</p>
<h3 id="optional-应该怎样用"><em>Optional</em> 应该怎样用？</h3>
<p>​		在使用 <em>Optional</em> 的时候需要考虑一些事情，以决定什么时候怎样使用它。</p>
<p>​		重要的一点是 <em>Optional</em> 不是 <em>Serializable</em>。因此，它不应该用作类的字段。</p>
<p>​		如果你需要序列化的对象包含 <em>Optional</em> 值，<a href="https://stackify.com/java-xml-jackson/"><em>Jackson</em> 库</a>支持把 <em>Optional</em> 当作普通对象。也就是说，<em>Jackson</em> 会把空对象看作 <em>null</em>，而有值的对象则把其值看作对应域的值。这个功能在 <a href="https://github.com/FasterXML/jackson-modules-java8">jackson-modules-java8</a> 项目中。</p>
<p>​		它在另一种情况下也并不怎么有用，就是在将其类型用作方法或构建方法的参数时。这样做会让代码变得复杂，完全没有必要：</p>
<pre><code>User user = new User(&quot;john@gmail.com&quot;, &quot;1234&quot;, Optional.empty());
</code></pre>
<p>​		使用重载方法来处理非要的参数要容易得多。</p>
<p>​		<em>Optional</em> 主要用作返回类型。在获取到这个类型的实例后，如果它有值，你可以取得这个值，否则可以进行一些替代行为。</p>
<p>​		<em>Optional</em> 类有一个非常有用的用例，就是将其与流或其它返回 <em>Optional</em> 的方法结合，以构建流畅的API。</p>
<p>​		我们来看一个示例，使用 <em>Stream</em> 返回 <em>Optional</em> 对象的 <em>findFirst()</em> 方法：</p>
<pre><code>@Test
public void whenEmptyStream_thenReturnDefaultOptional() {
    List&lt;User&gt; users = new ArrayList&lt;&gt;();
    User user = users.stream().findFirst().orElse(new User(&quot;default&quot;, &quot;1234&quot;));

    assertEquals(user.getEmail(), &quot;default&quot;);
}
</code></pre>
<h3 id="总结">总结</h3>
<p><em>Optional</em> 是 Java 语言的有益补充 —— 它旨在减少代码中的 <em>NullPointerExceptions</em>，虽然还不能完全消除这些异常。</p>
<p>它也是精心设计，自然融入 Java 8 函数式支持的功能。</p>
<p>总的来说，这个简单而强大的类有助于创建简单、可读性更强、比对应程序错误更少的程序。</p>
<p>转自 https://www.cnblogs.com/zhangboyu/p/7580262.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring Data REST 快速构建 restful api 应用]]></title>
        <id>https://cm940324.github.io/post/spring-data-rest/</id>
        <link href="https://cm940324.github.io/post/spring-data-rest/">
        </link>
        <updated>2021-04-22T06:00:24.000Z</updated>
        <content type="html"><![CDATA[<h3 id="什么是spring-data-rest">什么是Spring Data REST</h3>
<blockquote>
<p>​		Spring Data REST是基于Spring Data的repository之上，可以把 repository 自动输出为REST资源，目前支持Spring Data JPA、Spring Data <a href="https://cloud.tencent.com/product/mongodb?from=10680">MongoDB</a>、Spring Data Neo4j、Spring Data GemFire、Spring Data Cassandra的 repository 自动转换成REST服务。注意是自动。简单点说，Spring Data REST把我们需要编写的大量REST模版接口做了自动化实现.</p>
</blockquote>
<h3 id="restful-api">restful api</h3>
<p>​		REST是一种设计风格(与具体的语言无关)，它的URL主体是资源，是个名词。而且也仅支持HTTP协议，规定了使用HTTP Method表达本次要做的动作，类型一般也不超过那四五种。这些动作表达了对资源仅有的几种转化方式。</p>
<p>​		常用的HTTP动词有下面五个（括号里是对应的SQL命令）。</p>
<ul>
<li>GET（SELECT）：从服务器取出资源（一项或多项）</li>
<li>POST（CREATE）：在服务器新建一个资源。</li>
<li>PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。</li>
<li>PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。</li>
<li>DELETE（DELETE）：从服务器删除资源。</li>
<li>HEAD：获取资源的元数据。</li>
<li>OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。</li>
</ul>
<h3 id="实现">实现</h3>
<h4 id="添加依赖">添加依赖</h4>
<pre><code class="language-javascript">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-rest&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h4 id="定义domain">定义domain</h4>
<pre><code class="language-javascript">package com.zyndev.springdatarestdemo.domain;

import lombok.Data;

import javax.persistence.*;
import java.io.Serializable;
import java.util.Date;


@Data
@Entity
@Table(name = &quot;tb_user&quot;)
public class User implements Serializable {

    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;            // 用户id
    private String userName;    // 用户名称
    private String password;    // 用户密码
    private Integer active;     // 是否可用
    private Date lastLoginTime; // 最后登录时间
    private Date createTime;    // 账户创建时间
    private Date updateTime;    // 最后更新时间
}
</code></pre>
<h4 id="定义-repository">定义 Repository</h4>
<pre><code class="language-javascript">package com.zyndev.springdatarestdemo.controller;

import com.zyndev.springdatarestdemo.domain.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.rest.core.annotation.RepositoryRestResource;

@RepositoryRestResource(path=&quot;user&quot;)
public interface UserRepository extends JpaRepository&lt;User, Long&gt; {
}
</code></pre>
<h4 id="配置">配置</h4>
<pre><code class="language-javascript">server:
  port: 8080

spring:
  jpa:
    hibernate:
      ddl-auto: update
</code></pre>
<blockquote>
<p>通过设置 <code>spring.jpa.hibernate.ddl-auto=update</code> 来自动创建表，如果你已经根据domain建好表，可忽略，配置中省略了数据库的配置，请根据情况自行添加</p>
</blockquote>
<h4 id="测试">测试</h4>
<p>启动项目:</p>
<p>​		<strong>1. GET 访问 localhost:8080/user</strong>这里我已经添加了一条数据</p>
<pre><code class="language-javascript">{
    &quot;_embedded&quot;: {
        &quot;users&quot;: [
            {
                &quot;userName&quot;: &quot;abc&quot;,
                &quot;password&quot;: &quot;abc&quot;,
                &quot;active&quot;: 1,
                &quot;lastLoginTime&quot;: null,
                &quot;createTime&quot;: null,
                &quot;updateTime&quot;: null,
                &quot;_links&quot;: {
                    &quot;self&quot;: {
                        &quot;href&quot;: &quot;http://localhost:8080/user/1&quot;
                    },
                    &quot;user&quot;: {
                        &quot;href&quot;: &quot;http://localhost:8080/user/1&quot;
                    }
                }
            }
        ]
    },
    &quot;_links&quot;: {
        &quot;self&quot;: {
            &quot;href&quot;: &quot;http://localhost:8080/user{?page,size,sort}&quot;,
            &quot;templated&quot;: true
        },
        &quot;profile&quot;: {
            &quot;href&quot;: &quot;http://localhost:8080/profile/user&quot;
        }
    },
    &quot;page&quot;: {
        &quot;size&quot;: 20,
        &quot;totalElements&quot;: 1,
        &quot;totalPages&quot;: 1,
        &quot;number&quot;: 0
    }
}
</code></pre>
<p>​		<strong>2. GET 访问 localhost:8080/user/1</strong></p>
<p>​		通过上面可以看出 <code>1</code> 是存在的</p>
<pre><code class="language-javascript">{
    &quot;userName&quot;: &quot;abc&quot;,
    &quot;password&quot;: &quot;abc&quot;,
    &quot;active&quot;: 1,
    &quot;lastLoginTime&quot;: null,
    &quot;createTime&quot;: null,
    &quot;updateTime&quot;: null,
    &quot;_links&quot;: {
        &quot;self&quot;: {
            &quot;href&quot;: &quot;http://localhost:8080/user/1&quot;
        },
        &quot;user&quot;: {
            &quot;href&quot;: &quot;http://localhost:8080/user/1&quot;
        }
    }
}
</code></pre>
<p>​		<strong>3. GET 访问 localhost:8080/user/2</strong></p>
<p>​		因为 <code>2</code> 并不存在，这时返回 <code>404</code></p>
<p>​		<strong>4. POST localhost:8080/user 创建一个资源</strong></p>
<p>​		设置 <code>Content-Type=application/json</code></p>
<p>​		<strong>body:</strong></p>
<pre><code class="language-javascript">{
    &quot;userName&quot;: &quot;abcdfasdfe&quot;,
    &quot;password&quot;: &quot;abc&quot;,
    &quot;active&quot;: 1,
    &quot;lastLoginTime&quot;: null,
    &quot;createTime&quot;: null,
    &quot;updateTime&quot;: null
}
</code></pre>
<p>返回状态码 <code>201</code></p>
<p>返回数据：</p>
<pre><code class="language-javascript">{
    &quot;userName&quot;: &quot;abcdfasdfe&quot;,
    &quot;password&quot;: &quot;abc&quot;,
    &quot;active&quot;: 1,
    &quot;lastLoginTime&quot;: null,
    &quot;createTime&quot;: null,
    &quot;updateTime&quot;: null,
    &quot;_links&quot;: {
        &quot;self&quot;: {
            &quot;href&quot;: &quot;http://localhost:8080/user/4&quot;
        },
        &quot;user&quot;: {
            &quot;href&quot;: &quot;http://localhost:8080/user/4&quot;
        }
    }
}
</code></pre>
<p>​		<strong>5. 再次访问 GET 访问 localhost:8080/user</strong></p>
<p>​		这时可以看出 users 的数量为 2 说明已经创建成功</p>
<pre><code class="language-javascript">{
    &quot;_embedded&quot;: {
        &quot;users&quot;: [
            {
                &quot;userName&quot;: &quot;abc&quot;,
                &quot;password&quot;: &quot;abc&quot;,
                &quot;active&quot;: 1,
                &quot;lastLoginTime&quot;: null,
                &quot;createTime&quot;: null,
                &quot;updateTime&quot;: null,
                &quot;_links&quot;: {
                    &quot;self&quot;: {
                        &quot;href&quot;: &quot;http://localhost:8080/user/1&quot;
                    },
                    &quot;user&quot;: {
                        &quot;href&quot;: &quot;http://localhost:8080/user/1&quot;
                    }
                }
            },
            {
                &quot;userName&quot;: &quot;abcdfasdfe&quot;,
                &quot;password&quot;: &quot;abc&quot;,
                &quot;active&quot;: 1,
                &quot;lastLoginTime&quot;: null,
                &quot;createTime&quot;: null,
                &quot;updateTime&quot;: null,
                &quot;_links&quot;: {
                    &quot;self&quot;: {
                        &quot;href&quot;: &quot;http://localhost:8080/user/4&quot;
                    },
                    &quot;user&quot;: {
                        &quot;href&quot;: &quot;http://localhost:8080/user/4&quot;
                    }
                }
            }
        ]
    },
    &quot;_links&quot;: {
        &quot;self&quot;: {
            &quot;href&quot;: &quot;http://localhost:8080/user{?page,size,sort}&quot;,
            &quot;templated&quot;: true
        },
        &quot;profile&quot;: {
            &quot;href&quot;: &quot;http://localhost:8080/profile/user&quot;
        }
    },
    &quot;page&quot;: {
        &quot;size&quot;: 20,
        &quot;totalElements&quot;: 2,
        &quot;totalPages&quot;: 1,
        &quot;number&quot;: 0
    }
}
</code></pre>
<p>​		<strong>6. delete 访问 localhost:8080/user/1</strong></p>
<p>返回状态码： <code>204</code></p>
<p>再次访问 GET 访问 localhost:8080/user 会发现 users 的数量已经为1，说明已经删除成功</p>
<blockquote>
<p>可以使用 postman 测试，这里为了不贴图，就按上面的写了，希望理解</p>
</blockquote>
<p># 小功能</p>
<p>为了方便查看和测试api,可以集成 <code>hal browser</code></p>
<p>在 pom 文件添加依赖即可</p>
<pre><code class="language-javascript">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;
    &lt;artifactId&gt;spring-data-rest-hal-browser&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>重启项目并访问： <code>http://127.0.0.1:8080/browser/index.html#/</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 10 var 关键字深度解读]]></title>
        <id>https://cm940324.github.io/post/java10-var/</id>
        <link href="https://cm940324.github.io/post/java10-var/">
        </link>
        <updated>2021-04-22T02:39:38.000Z</updated>
        <content type="html"><![CDATA[<p>​		2018 年 3 月 21 日，Java 10 如约而至。虽然这一版本带来的特性并不是非常多，但其中有一项仍然成为大家关注的热点，它就是局部变量类型推断（JEP 286）。JEP 286 引入了 var，用于声明局部变量，例如：</p>
<pre><code>var users = new ArrayList&lt;User&gt;();
</code></pre>
<p>​		事情就是这么简单。不过，这篇文章将会讨论更多有关 var 的内容，比如什么时候可以用 var、什么时候不能用 var、var 对可读性的影响，以及为什么没有使用 val。</p>
<h3 id="使用-var-代替类型声明">使用 var 代替类型声明</h3>
<p>​		作为 Java 开发者，在声明一个变量时，我们总是习惯了敲打两次变量类型，第一次用于声明变量类型，第二次用于构造函数，比如：</p>
<pre><code>		URL codefx = new URL(&quot;http://codefx.org&quot;)
		URLConnection connection = codefx.openConnection();
		Reader reader = new BufferedReader(
  			new InputStreamReader(connection.getInputStream()));
</code></pre>
<p>​		URL codefx = new URL(&quot;http://codefx.org&quot;)`我们也经常声明一种变量，它只会被使用一次，而且是用在下一行代码中，比如：</p>
<pre><code>URL codefx = new URL(&quot;http://codefx.org&quot;)
URLConnection connection = codefx.openConnection();
Reader reader = new BufferedReader(
  new InputStreamReader(connection.getInputStream()));
</code></pre>
<p>​		这样也不算太糟糕，就是有点啰嗦。尽管 IDE 可以帮我们自动完成这些代码，但当变量总是跳来跳去的时候，可读性还是会受到影响，因为变量类型的名称由各种不同长度的字符组成。而且，有时候开发人员会尽力避免声明中间变量，因为太多的类型声明只会分散注意力，不会带来额外的好处。</p>
<p>​		从Java10开始,开发人员可以使用 var 让编译器自己去推断类型：</p>
<pre><code>	var codefx = new URL(&quot;http://codefx.org&quot;);
	var connection = codefx.openConnection();
  var reader = new BufferedReader(
  new InputStreamReader(connection.getInputStream()));
</code></pre>
<p>​		在处理 var 时，编译器先是查看表达式右边部分，也就是所谓的构造器，并将它作为变量的类型，然后将该类型写入字节码当中。</p>
<p>​		这样可以少敲几个字，但更重要的是，它避免了信息冗余，而且对齐了变量名，更容易阅读。当然，这也需要付出一点代价：有些变量，比如例子当中的 connection，就无法立即知道它是什么类型的。虽说 IDE 可以辅助显示出这些变量的类型，但在其他场景下可能就不行了，比如在代码评审的时候。</p>
<p>​		另外，你不需要担心变量名或方法名会与 var 发生冲突，因为 var 实际上并不是一个关键字，而是一个类型名，只有在编译器需要知道类型的地方才需要用到它。除此之外，它就是一个普通合法的标识符。也就是说，除了不能用它作为类名，其他的都可以，但极少人会用它作为类名。</p>
<p>​		局部变量类型推断是一个非常直观的特性，不过你可能会想：</p>
<ul>
<li>这到底是 Java 还是 JavaScript？</li>
<li>可以在哪些地方使用 var？</li>
<li>var 会影响可读性吗？</li>
<li>为什么没有 val 或 let？</li>
</ul>
<h2 id="不这不是-javascript">不，这不是 JavaScript</h2>
<p>​		首先我要说明的是，var 并不会改变 Java 是一门静态类型语言的事实。编译器负责推断出类型，并把结果写入字节码文件，就好像是开发人员自己敲入类型一样。</p>
<p>​		下面是使用 IntelliJ（实际上是 Fernflower 的反编译器）反编译器反编译出的代码：</p>
<pre><code>	URL codefx = new URL(&quot;http://codefx.org&quot;);
	URLConnection connection = codefx.openConnection();
	BufferedReader reader = new BufferedReader(
  new InputStreamReader(connection.getInputStream()));
</code></pre>
<p>​		从代码来看，就好像之前已经声明了这些类型一样。事实上，这一特性只发生在编译阶段，与运行时无关，所以对运行时的性能不会产生任何影响。所以请放心，这不是 JavaScript。</p>
<p>​		如果你仍然担心不显式声明类型会让代码变得更糟糕，那么我倒要问你了，你在使用 lambda 表达式的时候会声明参数的类型吗？</p>
<p>​		<mark><code>rhetoricalQuestion.answer(yes -&gt; &quot;see my point?&quot;);</code>## 哪些地方可以使用 var（或哪些地方不能使用 var）</mark></p>
<p>​		JEP 286 的标题“局部变量类型推断”就已经暗示了哪些地方可以使用 var：局部变量。更准确地说，是那些带有构造器的局部变量声明。但像这样的就不行了：</p>
<pre><code>	// 不行
	var foo;
	foo = &quot;Foo&quot;;
</code></pre>
<p>必须写成：</p>
<p><code>var foo = &quot;Foo&quot;;</code>除此之外，var 也不能用在“多元表达式”中，如 lambda 和方法引用：</p>
<pre><code>// 这些都不行
var ints = {0, 1, 2};
var appendSpace = a -&gt; a + &quot; &quot;;
var compareString = String::compareTo
</code></pre>
<p>除了局部变量，for 循环是唯一可以使用 var 的地方：</p>
<pre><code>var numbers = List.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
for (var nr : numbers)
  System.out.print(nr + &quot; &quot;);
for (var i = 0; i &lt; numbers.size(); i++)
  System.out.print(numbers.get(i) + &quot; &quot;);
</code></pre>
<p>也就是说，字段、方法签名和 catch 代码块仍然需要显式声明类型。</p>
<pre><code>// 这样也是不行的
private var getFoo() {
  return &quot;foo&quot;;
}
</code></pre>
<h2 id="避免action-at-a-distance错误">避免“Action At A Distance”错误</h2>
<p>​		将 var 限定在局部变量上并非技术方面的局限，而是设计上的决定。确实，如果能够像下面这样岂不更好？</p>
<pre><code>		// 编译器推断出类型 List&lt;User&gt;
		var users = new ArrayList&lt;User&gt;();
		// 这样就不行了，会出现编译错误
		users = new LinkedList&lt;&gt;();
</code></pre>
<p>​		按照预期，编译器应该能够找出最具体的那个类型，但实际上它不会。JDK 团队想要避免“Action At A Distance”错误（AAD），也就是说，他们希望在某处修改了代码不会影响到其他很“远”的地方。比如：</p>
<pre><code>	// id 被推推为`int`
	var id = 123;
	if (id &lt; 100) {
  	// 此处省略了很长的代码
  	// 调用了其他类的方法
	} else {
  	// 此处也省略了很长的代码
	}
</code></pre>
<p>​		现在，我们加入一行：</p>
<p>​		<code>id = &quot;124&quot;</code>这样会发生什么？if 代码块会抛出一个错误，因为 id 变成了字符串类型，所有不能使用小于号进行比较操作。这个错误距离代码修改的地方很“远”，而其根源就是因为对一个变量重新赋值。</p>
<p>​		这么看来，将类型推断限定在带有构造器的局部变量声明上是有它的道理的。</p>
<h2 id="为什么不推断字段和方法的类型">为什么不推断字段和方法的类型？</h2>
<p>​		字段和方法的作用域比局部变量大得多，所以更有可能出现 AAD 错误。在最糟糕的情况下，修改一个方法的参数类型可能导致二进制文件的不兼容和运行时错误。</p>
<p>​		因为非 private 的字段和方法是类契约的一部分，它们的类型不能通过推断来获得。不过，private 的字段和方法似乎可以使用类型推断，但问题是这样会让这个特性看起来非常奇怪。</p>
<p>​		局部变量属于实现细节，通常不会在很“远”的地方引用这些变量，所以就没有必要严格、显式和啰嗦地给它们声明类型了。</p>
<h2 id="为什么要使用-var">为什么要使用 var？</h2>
<p>​		相比其他年轻的编程语言，Java 代码的啰嗦是开发人员最大的痛点之一，也是饱受 Java 开发人员诟病的一个地方。为此，Amber 项目开发了 var，旨在“开发出一些小的 Java 语言特性，以便提高效率”，其目标是降低 Java 代码编写和阅读的繁琐程度。</p>
<p>​		局部变量类型推断正好迎合了这一目标。在编写代码时，声明变量的方式更简单了，尽管这类代码有大半可以使用 IDE 生成，或者使用 IDE 的重构功能进行修改。</p>
<p>​		除了让变量声明变得更简单，修改起来也很容易。这话怎么说？有些变量的类型真的很难看，比如那些带有泛型的企业级类名：</p>
<p>​</p>
<pre><code>InternationalCustomerOrderProcessor&gt; orderProcessor = 				createInternationalOrderProcessor(customer, order);`因为类型名称太长了，结果把变量名推到了代码的右边。如果限定了每行只能容纳 150 个字符，那么变量名还有可能被推到下一行显示。这些对于可读性来说都是一种伤害。

`var orderProcessor = createInternationalOrderProcessor(customer, order);`使用 var 就显得不那么累赘了，一眼就能看到头。
</code></pre>
<p>​		总之，使用 var 的意义不在于减少字符数量，而是为了不那么啰嗦和累赘。</p>
<h2 id="对可读性的影响">对可读性的影响</h2>
<p>​		现在让我们来讲讲可读性。确实，类型的缺失会让事情变得更糟糕，不是吗？一般来说，确实是的。在阅读代码时，类型是很重要的一个因素。尽管 IDE 可以帮助显示出推断的类型，但如果这些类型直接显示在代码中看起来不是更方便吗？</p>
<p>​		这是 var 在可读性方面的一个不足，不过，它却带来了另一个优势，那就是变量名对齐：</p>
<pre><code>	// 显式类型
	No no = new No();
	AmountIncrease&lt;BigDecimal&gt; more = new BigDecimalAmountIncrease();
	HorizontalConnection&lt;LinePosition, LinePosition&gt; jumping =
  	new HorizontalLinePositionConnection();
	Variable variable = new Constant(5);
	List&lt;String&gt; names = List.of(&quot;Max&quot;, &quot;Maria&quot;);
	// 推断类型
	var no = new No();
	var more = new BigDecimalAmountIncrease();
  var jumping = new HorizontalLinePositionConnection();
	var variable = new Constant(5);
	var names = List.of(&quot;Max&quot;, &quot;Maria&quot;);
</code></pre>
<p>​		虽说类型名称很重要，但好的变量名也是有过之而无不及。类型用于描述 Java 生态系统（JDK 的类）、一般场景（类库或框架）或业务领域（应用程序）的一般性概念，所以类型一般会有通用的名字。而变量名处在很小的上下文中，它们的名字应该要更精确一些。</p>
<p>​		这种可读性方面的改进可能会导致出现更多带有构造器的局部变量声明，因为这样在编写代码和阅读代码时会更加方便。</p>
<h2 id="为什么没有使用-valconstlet">为什么没有使用 val/const/let？</h2>
<p>​		其他很多使用了 var 的编程语言也会为不可变变量提供一个额外的关键字，比如 val、const 或 let。但 Java 10 没有使用这些关键字，所以我们必须使用 final var 来声明不可变变量。究其原因，可能是因为：</p>
<p>​		1.虽说不变性很重要,但对于局部变量来说,这种重要性程度没有那么高.</p>
<p>​		2.Java 8 引入了“隐式”final的概念,所以在我们看来,局部变量就已经是不可变的.</p>
<p>​		3.大部分人同意使用var（74% 的人强烈同意，12% 的人基本同意），而对 var/val 和 var/let 的反馈则显得有点含糊不清。</p>
<p>​		我同意前面两点，至于第三点只能勉强接受，但对结果还是感到有点失望。或许等到了有一天，我们不得不使用 final var 的时候，是不是可以考虑使用 val 或 let？</p>
<h2 id="总结">总结</h2>
<p>​		在声明局部变量时，可以使用 var 代替具体的类名或接口名，让编译器自己去推断变量的类型。当然，只有在声明并且立即初始化变量的情况下才能使用 var。for 循环中的下标也可以使用 var 来声明。编译器会把推断出来的类型写入字节码，不影响运行时。Java 仍然是一门静态类型的语言。</p>
<p>​		除了局部变量，var 不能被用于字段或方法上，这样做是为了避免 AAD 错误。</p>
<p>​		虽说 var 有可能让代码变得更糟，但作为 Java 开发者，应该尝试在变量声明和嵌套表达式或链式表达式之间做出权衡，写出可读性更高的代码。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SQL 语句性能优化策略]]></title>
        <id>https://cm940324.github.io/post/sql-yu-ju-xing-neng-you-hua-ce-lue/</id>
        <link href="https://cm940324.github.io/post/sql-yu-ju-xing-neng-you-hua-ce-lue/">
        </link>
        <updated>2021-01-15T00:47:15.000Z</updated>
        <content type="html"><![CDATA[<p>1、对查询进行优化，应尽量避免全表扫描，首先应考虑在where及order by涉及的列上建立索引。</p>
<p>2、应尽量避免在where子句中对字段进行null值判断，创建表时NULL是默认值，但大多数时候应该使用NOT NULL，或者使用一个特殊的值，如0，-1作为默认值。</p>
<p>3、应尽量避免在where子句中使用!=或&lt;&gt;操作符，MySQL只有对以下操作符才使用索引：&lt;，&lt;=，=，&gt;，&gt;=，BETWEEN，IN，以及某些时候的LIKE。</p>
<p>4、应尽量避免在where子句中使用or来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，可以使用UNION合并查询：select id from t where num=10 union all select id from t where num=20。</p>
<p>5、in和not in也要慎用，否则会导致全表扫描，对于连续的数值，能用between就不要用in了：Select id from t where num between 1 and 3。</p>
<p>6、下面的查询也将导致全表扫描：select id from t where name like‘%abc%’或者select id from t where name like‘%abc’若要提高效率，可以考虑全文检索。而select id from t where name like‘abc%’才用到索引。</p>
<p>7、如果在where子句中使用参数，也会导致全表扫描。</p>
<p>8、应尽量避免在where子句中对字段进行表达式操作，应尽量避免在where子句中对字段进行函数操作。</p>
<p>9、很多时候用exists代替in是一个好的选择：select num from a where num in(select num from b)。用下面的语句替换：select num from a where exists(select 1 from b where num=a.num)。</p>
<p>10、索引固然可以提高相应的select的效率，但同时也降低了insert及update的效率，因为insert或update时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。关于索引可以关注公众号Java技术栈搜索阅读更多详细教程。</p>
<p>11、应尽可能的避免更新clustered索引数据列， 因为clustered索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新clustered索引数据列，那么需要考虑是否应将该索引建为clustered索引。</p>
<p>12、尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。</p>
<p>13、尽可能的使用varchar/nvarchar代替char/nchar，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p>
<p>14、最好不要使用”“返回所有：select from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。具体可以阅读《别再 select * 了》这篇文章。</p>
<p>15、尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。</p>
<p>16、使用表的别名(Alias)：当在SQL语句中连接多个表时，请使用表的别名并把别名前缀于每个Column上。这样一来，就可以减少解析的时间并减少那些由Column歧义引起的语法错误。</p>
<p>17、使用“临时表”暂存中间结果 ：</p>
<p>简化SQL语句的重要方法就是采用临时表暂存中间结果，但是临时表的好处远远不止这些，将临时结果暂存在临时表，后面的查询就在tempdb中了，这可以避免程序中多次扫描主表，也大大减少了程序执行中“共享锁”阻塞“更新锁”，减少了阻塞，提高了并发性能。</p>
<p>18、一些SQL查询语句应加上nolock，读、写是会相互阻塞的，为了提高并发性能，对于一些查询，可以加上nolock，这样读的时候可以允许写，但缺点是可能读到未提交的脏数据。</p>
<p>使用nolock有3条原则：</p>
<p>查询的结果用于“插、删、改”的不能加nolock；<br>
查询的表属于频繁发生页分裂的，慎用nolock ；<br>
使用临时表一样可以保存“数据前影”，起到类似Oracle的undo表空间的功能，能采用临时表提高并发性能的，不要用nolock。</p>
<p>19、常见的简化规则如下：</p>
<p>不要有超过5个以上的表连接（JOIN），考虑使用临时表或表变量存放中间结果。少用子查询，视图嵌套不要过深，一般视图嵌套不要超过2个为宜。</p>
<p>20、将需要查询的结果预先计算好放在表中，查询的时候再Select。这在SQL7.0以前是最重要的手段，例如医院的住院费计算。</p>
<p>21、用OR的字句可以分解成多个查询，并且通过UNION 连接多个查询。他们的速度只同是否使用索引有关，如果查询需要用到联合索引，用UNION all执行的效率更高。多个OR的字句没有用到索引，改写成UNION的形式再试图与索引匹配。一个关键的问题是否用到索引。</p>
<p>22、在IN后面值的列表中，将出现最频繁的值放在最前面，出现得最少的放在最后面，减少判断的次数。</p>
<p>23、尽量将数据的处理工作放在服务器上，减少网络的开销，如使用存储过程。</p>
<p>存储过程是编译好、优化过、并且被组织到一个执行规划里、且存储在数据库中的SQL语句，是控制流语言的集合，速度当然快。反复执行的动态SQL，可以使用临时存储过程，该过程（临时表）被放在Tempdb中。</p>
<p>24、当服务器的内存够多时，配制线程数量 = 最大连接数+5，这样能发挥最大的效率；否则使用 配制线程数量&lt;最大连接数启用SQL SERVER的线程池来解决，如果还是数量 = 最大连接数+5，严重的损害服务器的性能。</p>
<p>25、查询的关联同写的顺序 ：</p>
<p>select a.personMemberID, * from chineseresume a,personmember b where personMemberID = b.referenceid and a.personMemberID = ‘JCNPRH39681’ （A = B ,B = ‘号码’）</p>
<p>select a.personMemberID, * from chineseresume a,personmember b where a.personMemberID = b.referenceid and a.personMemberID = ‘JCNPRH39681’ and b.referenceid = ‘JCNPRH39681’ （A = B ,B = ‘号码’， A = ‘号码’）</p>
<p>select a.personMemberID, * from chineseresume a,personmember b where b.referenceid = ‘JCNPRH39681’ and a.personMemberID = ‘JCNPRH39681’ （B = ‘号码’， A = ‘号码’）</p>
<p>26、尽量使用exists代替select count(1)来判断是否存在记录，count函数只有在统计表中所有行数时使用，而且count(1)比count(*)更有效率。</p>
<p>27、尽量使用“&gt;=”，不要使用“&gt;”。</p>
<p>28、索引的使用规范：</p>
<p>索引的创建要与应用结合考虑，建议大的OLTP表不要超过6个索引；<br>
尽可能的使用索引字段作为查询条件，尤其是聚簇索引，必要时可以通过index index_name来强制指定索引；<br>
避免对大表查询时进行table scan，必要时考虑新建索引；<br>
在使用索引字段作为条件时，如果该索引是联合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用；<br>
要注意索引的维护，周期性重建索引，重新编译存储过程。</p>
<p>29、下列SQL条件语句中的列都建有恰当的索引，但执行速度却非常慢：</p>
<p>SELECT * FROM record WHERE substrINg(card_no,1,4)=’5378’ (13秒)</p>
<p>SELECT * FROM record WHERE amount/30&lt; 1000 （11秒）</p>
<p>SELECT * FROM record WHERE convert(char(10),date,112)=’19991201’ （10秒）</p>
<p>分析：</p>
<p>WHERE子句中对列的任何操作结果都是在SQL运行时逐列计算得到的，因此它不得不进行表搜索，而没有使用该列上面的索引。</p>
<p>如果这些结果在查询编译时就能得到，那么就可以被SQL优化器优化，使用索引，避免表搜索，因此将SQL重写成下面这样：</p>
<p>SELECT * FROM record WHERE card_no like ‘5378%’ （&lt; 1秒）</p>
<p>SELECT * FROM record WHERE amount&lt; 1000*30 （&lt; 1秒）</p>
<p>SELECT * FROM record WHERE date= ‘1999/12/01’ （&lt; 1秒）</p>
<p>30、当有一批处理的插入或更新时，用批量插入或批量更新，绝不会一条条记录的去更新。批量插入的方法请关注公众号Java技术栈然后搜索阅读。</p>
<p>31、在所有的存储过程中，能够用SQL语句的，我绝不会用循环去实现。<br>
例如：列出上个月的每一天，我会用connect by去递归查询一下，绝不会去用循环从上个月第一天到最后一天。</p>
<p>32、选择最有效率的表名顺序（只在基于规则的优化器中有效）：</p>
<p>Oracle的解析器按照从右到左的顺序处理FROM子句中的表名，FROM子句中写在最后的表（基础表 driving table）将被最先处理，在FROM子句中包含多个表的情况下，你必须选择记录条数最少的表作为基础表。</p>
<p>如果有3个以上的表连接查询，那就需要选择交叉表（intersection table）作为基础表，交叉表是指那个被其他表所引用的表。</p>
<p>33、提高GROUP BY语句的效率，可以通过将不需要的记录在GROUP BY之前过滤掉。下面两个查询返回相同结果，但第二个明显就快了许多。</p>
<p>低效：</p>
<p>SELECT JOB , AVG(SAL)<br>
FROM EMP<br>
GROUP BY JOB<br>
HAVING JOB =’PRESIDENT’<br>
OR JOB =’MANAGER’</p>
<p>高效:</p>
<p>SELECT JOB , AVG(SAL)<br>
FROM EMP<br>
WHERE JOB =’PRESIDENT’<br>
OR JOB =’MANAGER’<br>
GROUP BY JOB</p>
<p>34、SQL语句用大写，因为Oracle总是先解析SQL语句，把小写的字母转换成大写的再执行。</p>
<p>35、别名的使用，别名是大型数据库的应用技巧，就是表名、列名在查询中以一个字母为别名，查询速度要比建连接表快1.5倍。</p>
<p>36、避免死锁，在你的存储过程和触发器中访问同一个表时总是以相同的顺序；事务应经可能地缩短，在一个事务中应尽可能减少涉及到的数据量；永远不要在事务中等待用户输入。</p>
<p>37、避免使用临时表，除非却有需要，否则应尽量避免使用临时表，相反，可以使用表变量代替；大多数时候(99%)，表变量驻扎在内存中，因此速度比临时表更快，临时表驻扎在TempDb数据库中，因此临时表上的操作需要跨数据库通信，速度自然慢。</p>
<p>38、最好不要使用触发器：</p>
<p>触发一个触发器，执行一个触发器事件本身就是一个耗费资源的过程；<br>
如果能够使用约束实现的，尽量不要使用触发器；<br>
不要为不同的触发事件(Insert，Update和Delete)使用相同的触发器；<br>
不要在触发器中使用事务型代码。</p>
<p>39、索引创建规则：</p>
<p>表的主键、外键必须有索引；<br>
数据量超过300的表应该有索引；<br>
经常与其他表进行连接的表，在连接字段上应该建立索引；<br>
经常出现在Where子句中的字段，特别是大表的字段，应该建立索引；<br>
索引应该建在选择性高的字段上；<br>
索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；<br>
复合索引的建立需要进行仔细分析，尽量考虑用单字段索引代替；<br>
正确选择复合索引中的主列字段，一般是选择性较好的字段；<br>
复合索引的几个字段是否经常同时以AND方式出现在Where子句中？单字段查询是否极少甚至没有？如果是，则可以建立复合索引；否则考虑单字段索引；<br>
如果复合索引中包含的字段经常单独出现在Where子句中，则分解为多个单字段索引；<br>
如果复合索引所包含的字段超过3个，那么仔细考虑其必要性，考虑减少复合的字段；<br>
如果既有单字段索引，又有这几个字段上的复合索引，一般可以删除复合索引；<br>
频繁进行数据操作的表，不要建立太多的索引；<br>
删除无用的索引，避免对执行计划造成负面影响；<br>
表上建立的每个索引都会增加存储开销，索引对于插入、删除、更新操作也会增加处理上的开销。另外，过多的复合索引，在有单字段索引的情况下，一般都是没有存在价值的；相反，还会降低数据增加删除时的性能，特别是对频繁更新的表来说，负面影响更大。<br>
尽量不要对数据库中某个含有大量重复的值的字段建立索引。MySQL开发 36 条军规，推荐看下。</p>
<p>40、MySQL查询优化总结：</p>
<p>使用慢查询日志去发现慢查询，使用执行计划去判断查询是否正常运行，总是去测试你的查询看看是否他们运行在最佳状态下。关注公众号Java技术栈回复面试，可以获取 MySQL 及更多面试题。</p>
<p>久而久之性能总会变化，避免在整个表上使用count(*)，它可能锁住整张表，使查询保持一致以便后续相似的查询可以使用查询缓存，在适当的情形下使用GROUP BY而不是DISTINCT，在WHERE、GROUP BY和ORDER BY子句中使用有索引的列，保持索引简单，不在多个索引中包含同一个列。</p>
<p>有时候MySQL会使用错误的索引，对于这种情况使用USE INDEX，检查使用SQL_MODE=STRICT的问题，对于记录数小于5的索引字段，在UNION的时候使用LIMIT不是是用OR。</p>
<p>为了避免在更新前SELECT，使用INSERT ON DUPLICATE KEY或者INSERT IGNORE，不要用UPDATE去实现，不要使用MAX，使用索引字段和ORDER BY子句，LIMIT M，N实际上可以减缓查询在某些情况下，有节制地使用，在WHERE子句中使用UNION代替子查询，在重新启动的MySQL，记得来温暖你的数据库，以确保数据在内存和查询速度快，考虑持久连接，而不是多个连接，以减少开销。</p>
<p>基准查询，包括使用服务器上的负载，有时一个简单的查询可以影响其他查询，当负载增加在服务器上，使用SHOW PROCESSLIST查看慢的和有问题的查询，在开发环境中产生的镜像数据中测试的所有可疑的查询。</p>
<p>41、MySQL备份过程：</p>
<p>从二级复制服务器上进行备份；<br>
在进行备份期间停止复制，以避免在数据依赖和外键约束上出现不一致；<br>
彻底停止MySQL，从数据库文件进行备份；<br>
如果使用MySQL dump进行备份，请同时备份二进制日志文件 – 确保复制没有中断；<br>
不要信任LVM快照，这很可能产生数据不一致，将来会给你带来麻烦；<br>
为了更容易进行单表恢复，以表为单位导出数据——如果数据是与其他表隔离的。<br>
当使用mysqldump时请使用–opt；<br>
在备份之前检查和优化表；<br>
为了更快的进行导入，在导入时临时禁用外键约束。；<br>
为了更快的进行导入，在导入时临时禁用唯一性检测；<br>
在每一次备份后计算数据库，表以及索引的尺寸，以便更够监控数据尺寸的增长；<br>
通过自动调度脚本监控复制实例的错误和延迟；<br>
定期执行备份。</p>
<p>42、查询缓冲并不自动处理空格，因此，在写SQL语句时，应尽量减少空格的使用，尤其是在SQL首和尾的空格（因为查询缓冲并不自动截取首尾空格）。</p>
<p>43、member用mid做标准进行分表方便查询么？一般的业务需求中基本上都是以username为查询依据，正常应当是username做hash取模来分表。</p>
<p>而分表的话MySQL的partition功能就是干这个的，对代码是透明的；在代码层面去实现貌似是不合理的。</p>
<p>44、我们应该为数据库里的每张表都设置一个ID做为其主键，而且最好的是一个INT型的（推荐使用UNSIGNED），并设置上自动增加的AUTO_INCREMENT标志。</p>
<p>45、在所有的存储过程和触发器的开始处设置SET NOCOUNT ON，在结束时设置SET NOCOUNT OFF。无需在执行存储过程和触发器的每个语句后向客户端发送DONE_IN_PROC消息。</p>
<p>46、MySQL查询可以启用高速查询缓存。这是提高数据库性能的有效MySQL优化方法之一。当同一个查询被执行多次时，从缓存中提取数据和直接从数据库中返回数据快很多。</p>
<p>47、EXPLAIN SELECT查询用来跟踪查看效果：</p>
<p>使用EXPLAIN关键字可以让你知道MySQL是如何处理你的SQL语句的。这可以帮你分析你的查询语句或是表结构的性能瓶颈。EXPLAIN的查询结果还会告诉你你的索引主键被如何利用的，你的数据表是如何被搜索和排序的。</p>
<p>48、当只要一行数据时使用LIMIT 1 ：</p>
<p>当你查询表的有些时候，你已经知道结果只会有一条结果，但因为你可能需要去fetch游标，或是你也许会去检查返回的记录数。</p>
<p>在这种情况下，加上LIMIT 1可以增加性能。这样一来，MySQL数据库引擎会在找到一条数据后停止搜索，而不是继续往后查少下一条符合记录的数据。</p>
<p>49、选择表合适存储引擎：</p>
<p>myisam：应用时以读和插入操作为主，只有少量的更新和删除，并且对事务的完整性，并发性要求不是很高的。<br>
InnoDB：事务处理，以及并发条件下要求数据的一致性。除了插入和查询外，包括很多的更新和删除。（InnoDB有效地降低删除和更新导致的锁定）。<br>
对于支持事务的InnoDB类型的表来说，影响速度的主要原因是AUTOCOMMIT默认设置是打开的，而且程序没有显式调用BEGIN 开始事务，导致每插入一条都自动提交，严重影响了速度。可以在执行SQL前调用begin，多条SQL形成一个事物（即使autocommit打开也可以），将大大提高性能。</p>
<p>50、优化表的数据类型，选择合适的数据类型：</p>
<p>原则：更小通常更好，简单就好，所有字段都得有默认值，尽量避免null。</p>
<p>例如：数据库表设计时候更小的占磁盘空间尽可能使用更小的整数类型。(mediumint就比int更合适)</p>
<p>比如时间字段：datetime和timestamp，datetime占用8个字节，而timestamp占用4个字节，只用了一半，而timestamp表示的范围是1970—2037适合做更新时间</p>
<p>MySQL可以很好的支持大数据量的存取，但是一般说来，数据库中的表越小，在它上面执行的查询也就会越快。</p>
<p>因此，在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度设得尽可能小。</p>
<p>例如：在定义邮政编码这个字段时，如果将其设置为CHAR(255)，显然给数据库增加了不必要的空间。甚至使用VARCHAR这种类型也是多余的，因为CHAR(6)就可以很好的完成任务了。</p>
<p>同样的，如果可以的话，我们应该使用MEDIUMINT而不是BIGIN来定义整型字段，应该尽量把字段设置为NOT NULL，这样在将来执行查询的时候，数据库不用去比较NULL值。</p>
<p>对于某些文本字段，例如“省份”或者“性别”，我们可以将它们定义为ENUM类型。因为在MySQL中，ENUM类型被当作数值型数据来处理，而数值型数据被处理起来的速度要比文本类型快得多。这样，我们又可以提高数据库的性能。</p>
<p>51、字符串数据类型：char，varchar，text选择区别。</p>
<p>52、任何对列的操作都将导致表扫描，它包括数据库函数、计算表达式等等，查询时要尽可能将操作移至等号右边。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于]]></title>
        <id>https://cm940324.github.io/post/about/</id>
        <link href="https://cm940324.github.io/post/about/">
        </link>
        <updated>2019-01-25T11:09:48.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://cm940324.github.io/post-images/1618881224746.jpeg" alt="" loading="lazy"><br>
JAVA PROGRAMMER👨‍💻</p>
]]></content>
    </entry>
</feed>