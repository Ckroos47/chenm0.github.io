<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://cm940324.github.io</id>
    <title>Oasis</title>
    <updated>2021-06-17T05:51:10.519Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://cm940324.github.io"/>
    <link rel="self" href="https://cm940324.github.io/atom.xml"/>
    <subtitle>&lt;a href=&quot;https://cm940324.github.io/&quot; target=&quot;_blank&quot;&gt;code blog&lt;/a&gt;</subtitle>
    <logo>https://cm940324.github.io/images/avatar.png</logo>
    <icon>https://cm940324.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Oasis</rights>
    <entry>
        <title type="html"><![CDATA[微服务的数据库设计]]></title>
        <id>https://cm940324.github.io/post/weifuwu-sheji/</id>
        <link href="https://cm940324.github.io/post/weifuwu-sheji/">
        </link>
        <updated>2021-06-17T05:19:26.000Z</updated>
        <content type="html"><![CDATA[<h3 id="单独的数据库">单独的数据库：</h3>
<p>微服务设计的一个关键是数据库设计，基本原则是每个服务都有自己单独的数据库，而且只有微服务本身可以访问这个数据库。它是基于下面三个原因。</p>
<p><strong>优化服务接口</strong>：微服务之间的接口越小越好，最好只有服务调用接口（RPC或消息），没有其他接口。如果微服务不能独享自己的数据库，那么数据库也变成了接口的一部分，这大大拓展了接口范围。</p>
<p><strong>错误诊断</strong>：生产环境中的错误大部分都是和数据库有关的，要么是数据出了问题，要么是数据库的使用方式出了问题。当你不能完全控制数据库的访问时，会有各种各样的错误发生。它可能是别的程序直接连到你的数据库或者是其他部门直接用客户端访问数据库的数据，而这些都是在程序中查不到的，增加了错误排查难度。如果是程序中的问题，只要修改了代码，那么这个错误就不会再有。而上面提到的错误，你永远都没法预测它们什么时候还会再次发生。</p>
<p><strong>性能调优</strong>：性能调优也是一样，你需要对数据库有全权控制才能保证它的性能。如果其他部门一定要访问数据库，而且只是查询的话，那么可以另外创建一份只读数据库，让他们在另一个库中查询，这样才不会影响到你的库。</p>
<p>理想的设计是你的数据库只有你的服务能访问，你也只调用自己数据库中的数据，所有对别的微服务的访问都通过服务调用来实现（请参阅<a href="https://blog.csdn.net/weixin_38748858/article/details/101062272">“微服务之间调用的最佳设计“</a>）。当然，在实际应用中，单纯的服务调用可能不能满足性能或其他要求，不同的微服务都多少需要共享一些数据。</p>
<h3 id="共享数据">共享数据：</h3>
<p>微服务之间的数据共享可以有下四种方式。</p>
<h4 id="静态表">静态表：</h4>
<p>有一些静态的数据库表，例如国家，可能会被很多程序用到，而且程序内部需要对国家这个表做连接（join）生成最终用户展示数据，这样用微服务调用的方式就效率不高，影响性能。一个办法是在每个微服务中配置一个这样的表，它是只读的，这样就可以做数据库连接了。当然你需要保证数据同步。这个方案在多数情况下都是可以接受的，因为以下两点：</p>
<ol>
<li>静态的数据库表结构基本不变：因为一旦表结构变了，你不但要更改所有微服务的数据库表，还要修改所有微服务的程序。</li>
<li>数据库表中的数据变化不频繁：这样数据同步的工作量不大。另外当你同步数据库时总会有延迟，如果数据变化不频繁那么你有很多同步方式可供选择。</li>
</ol>
<h4 id="只读业务数据访问">只读业务数据访问：</h4>
<p>如果你需要读取别的数据库里的动态业务数据， 理想的方式是服务调用。如果你只是调用其他微服务做一些计算，一般情况下性能都是可以接受的。如果你需要做数据的连接，那么你可以用程序代码来做，而不是用SQL语句。如果测试之后性能不能满足要求，那你可以考虑在自己的数据库里建一套只读数据表。数据同步方式大致有两种。如果是事件驱动方式，就用发消息的方式进行同步，如果是RPC方式，就用数据库本身提供的同步方式或者第三方同步软件。<br>
通常情况下，你可能只需要其他数据库的几张表，每张表只需要几个字段。这时，其他数据库是数据的最终来源，控制所有写操作以及相应的业务验证逻辑，我们叫它主表。你的只读库可以叫从表。 当一条数据写入主表后，会发一条广播消息，所有拥有从表的微服务监听消息并更新只读表中的数据。但这时你要特别小心，因为它的危险性要比静态表大得多。第一它的表结构变更会更频繁，而且它的变更完全不受你控制。第二业务数据不像静态表，它是经常更新的，这样对数据同步的要求就比较高。要根据具体的业务需求来决定多大的延迟是可以接受的。<br>
另外它还有两个问题：</p>
<ol>
<li><strong>数据的容量</strong>：数据库中的数据量是影响性能的主要因素。因为这个数据是外来的，不利于掌握它的流量规律，很难进行容量规划，也不能更好地进行性能调优。</li>
<li><strong>接口外泄</strong>: 微服务之间的接口本来只有服务调用接口，这时你可以对内部程序和数据库做任何更改，而不影响其他服务。现在数据库表结构也变成了接口的一部分。接口一旦发布之后，基本是不能更改的，这大大限制了你的灵活性。幸运的是因为另外建了一套表，有了一个缓冲，当主表修改时，从表也许不需要同步更新。</li>
</ol>
<p>除非你能用服务调用（没有本地只读数据库）的方式完成所有功能，不然不管你是用RPC方式还是事件驱动方式进行微服务集成，上面提到的问题都是不可避免的。但是你可以通过合理规划数据库更改，来减少上面问题带来的影响，下面将会详细讲解。</p>
<h4 id="读写业务数据访问">读写业务数据访问：</h4>
<p>这是最复杂的一种情况。一般情况下，你有一个表是主表，而其他表是从表。主表包含主要信息，而且这些主要信息被复制到从表，但微服务会有额外字段需要写入从表。这样本地微服务对从表就既有读也有写的操作。而且主表和从表有一个先后次序的关系。从表的主键来源于主表，因此一定先有主表，再有从表。</p>
<p>假设我们有两个与电影有关的微服务，一个是电影论坛，用户可以发表对电影的评论。另一个是电影商店。“movie”是共享表，左边的一个是电影论坛库，它的“movie”表是主表。右边的是电影商店库，它的“movie”表是从表。它们共享“id”字段（主键）。主表是数据的主要来源，但从表里的“quantity”和“price”字段主表里面没有。主表插入数据后，发消息，从表接到消息，插入一条数据到本地“movie”表。并且从表还会修改表里的“quantity”和“price”字段。在这种情况下，要给每一个字段分配一个唯一源头（微服务），只有源头才有权利主动更改字段，其他微服务只能被动更改（接收源头发出的更改消息之后再改）。在本例子中， “quantity”和“price”字段的源头是右边的表，其他的字段的源头都是左边的表。本例子中“quantity”和“price”只在从表中存在，因此数据写入是单向的，方向是主表到从表。如果主表也需要这些字段，那么它们还要被回写，那数据写入就变成双向的。</p>
<h4 id="直接访问其它数据库">直接访问其它数据库：</h4>
<p>这种方式是要绝对禁止的。生产环境中的许多程序错误和性能问题都是由这种方式产生的。上面的三种方式由于是另外新建了本地只读数据库表，产生了数据库的物理隔离，这样一个数据库的性能问题不会影响到另一个。另外，当主库中的表结构更改时，你可以暂时保持从库中的表不变，这样程序还可以运行。如果直接访问别人的库，主库一修改，别的微服务程序马上就会报错。请参阅ApplicationDatabase。</p>
<h3 id="向后兼容的数据库更新">向后兼容的数据库更新：</h3>
<p>从上面的论述可以看出，数据库表结构的修改是一个影响范围很广的事情。在微服务架构中，共享的表在别的服务中也会有一个只读的拷贝。现在当你要更改表结构时，还需要考虑到对别的微服务的影响。当在单体（Monolithic）架构中，为了保证程序部署能够回滚，数据库的更新是向后兼容的。需要兼容性的另一个原因是支持蓝绿发布（Blue-Green Deployment）。在这种部署方式中，你同时拥有新旧版本的代码，由负载均衡来决定每一个请求指向那个版本。它们可以共享一个数据库（这就要求数据库是向后兼容的），也可以使用不同的数据。数据库的更新简单来讲有以下几种类型：<br>
<strong>增加表或字段</strong>：如果字段可取空值，这个操作是向后兼容的。如果是非空值就要插入一个缺省值。</p>
<p><strong>删除表或字段</strong>：可先暂时保留被删除表或字段，经过几个版本之后再删除。</p>
<p><strong>修改字段名</strong>：新增加一个字段，把数据从旧字段拷贝到新字段，用数据库触发器（或程序）同步旧字段和新字段（供过渡时期使用）。 然后再在几个版本之后把原来的字段删除（请参阅<a href="https://thoughts-on-java.org/update-database-schema-without-downtime/">Update your Database Schema Without Downtime</a>）。</p>
<p><strong>修改表名</strong>：如果数据库支持可更新视图，最简单的办法是先修改表的名字，然后创建一个可更新视图指向原来的表（请参阅<a href="https://martinfowler.com/articles/evodb.html">Evolutionary Database Design</a> ）。如果数据库不支持可更新视图，使用的方法与修改字段名相似，需要创建新的表并做数据同步。</p>
<p><strong>修改字段类型</strong>：与修改字段名几乎相同，只是在拷贝数据时，需要做数据类型转换。</p>
<p>向后兼容的数据库更新的好处是，当程序部署出现问题时，如需进行回滚。只要回滚程序就行了，而不必回滚数据库。回滚时一般只回滚一个版本。凡是需要删除的表或字段在本次部署时都不做修改，等到一个或几个版本之后，确认没有问题了再删除。它的另一个好处就是不会对其他微服务中的共享表产生立刻的直接影响。当本微服务升级后，其他微服务可以评估这些数据库更新带来的影响再决定是否需要做相应的程序或数据库修改。</p>
<h3 id="跨服务事物">跨服务事物：</h3>
<p>微服务的一个难点是如何实现跨服务的事物支持。两阶段提交（Two-Phase Commit）已被证明性能上不能满足需求，现在基本上没有人用。被一致认可的方法叫Saga。它的原理是为事物中的每个操作写一个补偿操作（Compensating Transaction），然后在回滚阶段挨个执行每一个补偿操作。示例如下图，在一个事物中共有3个操作T1，T2，T3。每一个操作要定义一个补偿操作，C1，C2，C3。事物执行时是按照正向顺序先执行T1，当回滚时是按照反向顺序先执行C3。 事物中的每一个操作（正向操作和补偿操作）都被包装成一个命令（Command），Saga执行协调器（Saga Execution Coordinator (SEC)）负责执行所有命令。在执行之前，所有的命令都会按顺序被存入日志中，然后Saga执行协调器从日志中取出命令，依次执行。当某个执行出现错误时，这个错误也被写入日志，并且所有正在执行的命令被停止，开始回滚操作。</p>
<p>Saga放松了对一致性（Consistency）的要求，它能保证的是最终一致性（Eventual Consistency），因此在事物执行过程中数据是不一致的，并且这种不一致会被别的进程看到。在生活中，大多数情况下，我们对一致性的要求并没有那么高，短暂的不一致性是可以接收的。例如银行的转账操作，它们在执行过程中都不是在一个数据库事物里执行的，而是用记账的方式分成两个动作来执行，保证的也是最终一致性。</p>
<p>Saga的原理看起来很简单，但要想正确的实施还是有一定难度的。它的核心问题在于对错误的处理，要把它完全讲明白需要另写一遍文章，我现在只讲一下要点。网络环境是不可靠的，正在执行的命令可能很长时间都没有返回结果，这时，第一，你要设定一个超时。第二，因为你不知道没有返回值的原因是，已经完成了命令但网络出了问题，还是没完成就牺牲了，因此不知道是否要执行补偿操作。这时正确的做法是重试原命令，直到得到完成确认，然后再执行补偿操作。但这对命令有一个要求，那就是这个操作必须是幂等的（Idempotent），也就是说它可以执行多次，但最终结果还是一样的。</p>
<p>另外，有些操作的补偿操作比较容易生成，例如付款操作，你只要把钱款退回就可以了。但有些操作，像发邮件，完成之后就没有办法回到之前的状态了，这时就只能再发一个邮件更正以前的信息。因此补偿操作不一定非要返回到原来的状态，而是抵消掉原来操作产生的效果。</p>
<h3 id="微服务的拆分">微服务的拆分：</h3>
<p>我们原来的程序大多数都是单体程序，但现在要把它拆分成微服务，应该怎样做才能降低对现有应用的影响呢？</p>
<p>假设我们要拆分出来一个微服务叫“client-service”，它需要访问“core client”表。第一步，我们先把程序从原来的代码里拆分出来，变成一个服务. 数据库不动，这个服务仍然指向原来的数据库。其他程序不再直接访问这个服务管理的表，而是通过服务调用或另建共享表来获取数据。</p>
<p>第二步，再把服务的数据库表拆分出来，这时微服务就拥有它自己的数据库了，而不再需要原来的共享数据库了。这时就成了一个真正意义上的的微服务。</p>
<p>上面只讲了拆分一个微服务，如果有多个需要拆分，则需一个一个按照上面讲的方法依次进行。</p>
<p>另外，Martin Fowler在他的文章&quot;Break Monolith into Microservices&quot;里有一个很好的建议。那就是，当你把服务从单体程序里拆分时，不要只想着把代码拆分出来。因为现在的需求可能已经跟原来有所不同，原先的设计可能也不太适用了。而且，技术也已更新，代码也要作相应的改造。更好的办法是重写原来的功能（而不是重写原来的代码），把重点放在拆分业务功能上，而不是拆分代码上，用新的设计和技术来实现这个业务功能。</p>
<h3 id="结论">结论：</h3>
<p>数据库设计是微服务设计的一个关键点，基本原则是每个微服务都有自己单独的数据库，而且只有微服务本身可以访问这个数据库。微服务之间的数据共享可以通过服务调用，或者主、从表的方式实现。在共享数据时，要找到合适的同步方式。在微服务架构中，数据库的修改影响广泛，需要保证这种修改是向后兼容的。实现跨服务事物的标准方法是Saga。当把单体程序拆分成微服务时，可以分步进行，以减少对现有程序的影响。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[两数之和]]></title>
        <id>https://cm940324.github.io/post/twonum/</id>
        <link href="https://cm940324.github.io/post/twonum/">
        </link>
        <updated>2021-06-11T01:50:16.000Z</updated>
        <content type="html"><![CDATA[<p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。<br>
示例 1：<br>
//输入：nums = [2,7,11,15], target = 9<br>
//输出：[0,1]<br>
//解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</p>
<p>// 示例 2：<br>
//输入：nums = [3,2,4], target = 6<br>
//输出：[1,2]</p>
<p>// 示例 3：</p>
<p>//输入：nums = [3,3], target = 6<br>
//输出：[0,1]<br>
// 提示：</p>
<p>// 2 &lt;= nums.length &lt;= 104<br>
// -109 &lt;= nums[i] &lt;= 109<br>
// -109 &lt;= target &lt;= 109<br>
// 只会存在一个有效答案</p>
<p>// 进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？<br>
// Related Topics 数组 哈希表</p>
<pre><code>class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();
        for (int i = 1; i &lt;= nums.length; i++) {
            if (map.contains(target - nums[i])){
                return new int[]{map.get(target - nums[i]),i};
            }
            map.put(map.contains(target - nums[i]), i);
        }
        return new int[0];
    }
    
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring Data Rest---Paging and Sorting ]]></title>
        <id>https://cm940324.github.io/post/spring-data-rest-learn/</id>
        <link href="https://cm940324.github.io/post/spring-data-rest-learn/">
        </link>
        <updated>2021-06-10T07:11:22.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-paging">1. Paging</h3>
<p>Spring Data REST能识别含有分页和排序请求的URL，从而返回用户想要的数据，而不是直接返回一大堆数据集合。如果你继承PagingAndSortingRepository&lt;T, ID&gt;并获取实体类的列表集合，例如：</p>
<pre><code>interface PersonRepository extends PagingAndSortingRepository&lt;Person, Long&gt; {}
</code></pre>
<p>那么请求数据分页默认数为20个，也就是说第一次请求为20个数据，并带有分页的参数，如果想要自定义分页的参数，可以采用更改请求的URL参数的办法进行更改：</p>
<p><mark>http://localhost:8080/persons/?size=5</mark></p>
<p>如果要在你自己的查询方法中使用分页，需要在方法的参数中添加一个Pageable参数，这样获得的数据是一页数据(Page)而不是一个列表(List):</p>
<pre><code>@RestResource(path = &quot;nameStartsWith&quot;, rel = &quot;nameStartsWith&quot;)

public PagefindByNameStartsWith(@Param(&quot;name&quot;) String name, Pageable p);
</code></pre>
<p>这样的一个查询方法，会输出到链接：/people/search/nameStartsWith 并且会支持分页，这个原理和Spring Data Jpa的类似。</p>
<h3 id="2-previous-and-next-links">2. Previous and Next Links</h3>
<p>每个分页的response数据返回到前端页面，都有一个prev和next链接，比如在浏览器中请求 localhost:8080/people?size=5 后得到的数据如下：</p>
<pre><code>{
&quot;_links&quot; : {
	&quot;self&quot; : {
		&quot;href&quot; : &quot;http://localhost:8080/persons{&amp;sort,page,size}&quot;, 
	&quot;templated&quot; : true
	},
	&quot;next&quot; : {
		&quot;href&quot; : &quot;http://localhost:8080/persons?page=1&amp;size=5{&amp;sort}&quot;, 
		&quot;templated&quot; : true
	}
},
	&quot;_embedded&quot; : {
		... data ...
	},
	&quot;page&quot; : { ③
	&quot;size&quot; : 5,
	&lt;!-- &quot;totalElements&quot; : 50 --&gt;
	&quot;totalPages&quot; : 10,
	&quot;number&quot; : 0
}
</code></pre>
<p>这两个链接是指向下一级链接(next)和上一级(prev)的链接的地址</p>
<h3 id="3sorting">3.Sorting</h3>
<p>和Paging一样，Spring Data Rest识别含有排序的URL请求参数，实体类对应的同样有一个实体仓库。为了让数据按照自己想要的参数进行排序，可以在URL请求中添加一个name属性，并指定属性的排序方式，指定排序的方向(正向asc,逆向desc),比如：</p>
<pre><code class="language-html">http://localhost:8080/people/search/nameStartsWith?name=K&amp;sort=name,desc
</code></pre>
<p>这样一个语句是使用了定义在PersonRepository中的findByNameStartsWith查询方法进行查询所有Person的姓名中以字母K开头的并以name进行逆向排序的用户。通常为使用多个属性进行排序，往往可以添加sort=PROPERTY自己想要排序的参数进行排序。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[微服务：服务注册发现+ API 网关+配置中心+配置中心+服务跟踪]]></title>
        <id>https://cm940324.github.io/post/weifuwu-ques/</id>
        <link href="https://cm940324.github.io/post/weifuwu-ques/">
        </link>
        <updated>2021-06-07T07:00:17.000Z</updated>
        <content type="html"><![CDATA[<p><strong>服务注册发现</strong></p>
<p>服务注册就是维护一个登记簿，它管理系统内所有的服务地址。当新的服务启动后，它会向登记簿交待自己的地址信息。服务的依赖方直接向登记簿要 Service Provider 地址就行了。当下用于服务注册的工具非常多 ZooKeeper，Consul，Etcd, 还有 Netflix 家的 eureka 等。服务注册有两种:</p>
<p><strong>形式：客户端注册和第三方注册。</strong></p>
<p><strong>客户端注册（zookeeper</strong>）<br>
客户端注册是服务自身要负责注册与注销的工作。当服务启动后向注册中心注册自身，当服务下线时注销自己。期间还需要和注册中心保持心跳。心跳不一定要客户端来做，也可以由注册中心负责（这个过程叫探活）。这种方式的缺点是注册工作与服务耦合在一起，不同语言都要实现一套注册逻辑。</p>
<p><strong>第三方注册（独立的服务 Registrar）</strong></p>
<p>第三方注册由一个独立的服务Registrar负责注册与注销。当服务启动后以某种方式通知Registrar，然后 Registrar 负责向注册中心发起注册工作。同时注册中心要维护与服务之间的心跳，当服务不可用时，向注册中心注销服务。这种方式的缺点是 Registrar 必须是一个高可用的系统则注册工作没法进展。</p>
<p><strong>客户端发现</strong></p>
<p>客户端发现是指客户端负责查询可用服务地址，以及负载均衡的工作。这种方式最方便直接，而且也方便做负载均衡。再者一旦发现某个服务不可用立即换另外一个，非常直接。缺点也在于多语言时的重复工作，每个语言实现相同的逻辑。</p>
<p><strong>服务端发现</strong></p>
<p>服务端发现需要额外的 Router 服务，请求先打到 Router，然后 Router 负责查询服务与负载均衡。这种方式虽然没有客户端发现的缺点，但是它的缺点是保证 Router 的高可用。</p>
<p><strong>API 网关</strong><br>
API Gateway 是一个服务器，也可以说是进入系统的唯一节点。这跟面向对象设计模式中的<br>
Facade 模式很像。API Gateway 封装内部系统的架构，并且提供 API 给各个客户端。它还可能有其他功能，如授权、监控、负载均衡、缓存、请求分片和管理、静态响应处理等。下图展示了一个适应当前架构的 API Gateway。<br>
API Gateway 负责请求转发、合成和协议转换。所有来自客户端的请求都要先经过 API Gateway，然后路由这些请求到对应的微服务。API Gateway 将经常通过调用多个微服务来处理一个请求以及聚合多个服务的结果。它可以在 web 协议与内部使用的非 Web 友好型协议间进行转换，如HTTP 协议、WebSocket 协议。</p>
<p><strong>请求转发</strong></p>
<p>服务转发主要是对客户端的请求安装微服务的负载转发到不同的服务上</p>
<p><strong>响应合并</strong></p>
<p>把业务上需要调用多个服务接口才能完成的工作合并成一次调用对外统一提供服务。</p>
<p><strong>协议转换</strong></p>
<p>重点是支持 SOAP，JMS，Rest 间的协议转换。</p>
<p><strong>数据转换</strong></p>
<p>重点是支持 XML 和 Json 之间的报文格式转换能力（可选）</p>
<p><strong>安全认证</strong></p>
<ol>
<li>
<p>基于 Token 的客户端访问控制和安全策略</p>
</li>
<li>
<p>传输数据和报文加密，到服务端解密，需要在客户端有独立的 SDK 代理包</p>
</li>
<li>
<p>基于 Https 的传输加密，客户端和服务端数字证书支持</p>
</li>
<li>
<p>基于 OAuth2.0 的服务安全认证(授权码，客户端，密码模式等）</p>
</li>
</ol>
<p><strong>配置中心</strong><br>
配置中心一般用作系统的参数配置，它需要满足如下几个要求：高效获取、实时感知、分布式访问。</p>
<p><strong>zookeeper 配置中心</strong></p>
<p>采取数据加载到内存方式解决高效获取的问题，借助 zookeeper 的节点监听机制来实现实时感知。</p>
<p><strong>事件调度（kafka）</strong><br>
消息服务和事件的统一调度，常用用 kafka ，activemq 等。</p>
<p><strong>服务跟踪（starter-sleuth）</strong></p>
<p>随着微服务数量不断增长，需要跟踪一个请求从一个微服务到下一个微服务的传播过程， SpringCloud Sleuth 正是解决这个问题，它在日志中引入唯一 ID，以保证微服务调用之间的一致性，这样你就能跟踪某个请求是如何从一个微服务传递到下一个。</p>
<ol>
<li>
<p>为了实现请求跟踪，当请求发送到分布式系统的入口端点时，只需要服务跟踪框架为该请求创建一个唯一的跟踪标识，同时在分布式系统内部流转的时候，框架始终保持传递该唯一标识，直到返回给请求方为止，这个唯一标识就是前文中提到的 Trace ID。通过 Trace ID 的记录，我们就能将所有请求过程日志关联起来。</p>
</li>
<li>
<p>为了统计各处理单元的时间延迟，当请求达到各个服务组件时，或是处理逻辑到达某个状态时，也通过一个唯一标识来标记它的开始、具体过程以及结束，该标识就是我们前文中提到的 Span ID，对于每个 Span 来说，它必须有开始和结束两个节点，通过记录开始 Span 和结束 Span 的时间戳，就能统计出该 Span 的时间延迟，除了时间戳记录之外，它还可以包含一些其他元数据，比如：事件名称、请求信息等。</p>
</li>
<li>
<p>在快速入门示例中，我们轻松实现了日志级别的跟踪信息接入，这完全归功于spring-cloudstarter-sleuth 组件的实现。在 Spring Boot 应用中，通过在工程中引入 spring-cloud<br>
starter-sleuth 依赖之后， 它会自动的为当前应用构建起各通信通道的跟踪机制，比如：</p>
</li>
</ol>
<ul>
<li>通过诸如 RabbitMQ、Kafka（或者其他任何 Spring Cloud Stream 绑定器实现的消息<br>
中间件）传递的请求。</li>
<li>通过 Zuul 代理传递的请求。</li>
<li>通过 RestTemplate 发起的请求。</li>
</ul>
<p><strong>服务熔断（Hystrix）</strong><br>
在微服务架构中通常会有多个服务层调用，基础服务的故障可能会导致级联故障，进而造成整个系统不可用的情况，这种现象被称为服务雪崩效应。服务雪崩效应是一种因“服务提供者”的不可用导致“服务消费者”的不可用,并将不可用逐渐放大的过程。</p>
<p>熔断器的原理很简单，如同电力过载保护器。它可以实现快速失败，如果它在一段时间内侦测到许多类似的错误，会强迫其以后的多个调用快速失败，不再访问远程服务器，从而防止应用程序</p>
<p>不断地尝试执行可能会失败的操作，使得应用程序继续执行而不用等待修正错误，或者浪费 CPU时间去等到长时间的超时产生。熔断器也可以使应用程序能够诊断错误是否已经修正，如果已经修正，应用程序会再次尝试调用操作。</p>
<p><strong>Hystrix 断路器机制</strong></p>
<p>断路器很好理解, 当 Hystrix Command 请求后端服务失败数量超过一定比例(默认 50%), 断路器会切换到开路状态(Open). 这时所有请求会直接失败而不会发送到后端服务. 断路器保持在开路状态一段时间后(默认 5 秒), 自动切换到半开路状态(HALF-OPEN). 这时会判断下一次请求的返回情况,</p>
<p>如果请求成功, 断路器切回闭路状态(CLOSED), 否则重新切换到开路状态(OPEN). Hystrix 的断路器就像我们家庭电路中的保险丝, 一旦后端服务不可用, 断路器会直接切断请求链, 避免发送大量无效请求影响系统吞吐量, 并且断路器有自我检测并恢复的能力。</p>
<p><strong>API 管理</strong></p>
<p>SwaggerAPI 管理工具。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[hibernate CascadeType属性说明]]></title>
        <id>https://cm940324.github.io/post/hibernate-cascadetype/</id>
        <link href="https://cm940324.github.io/post/hibernate-cascadetype/">
        </link>
        <updated>2021-06-07T06:31:17.000Z</updated>
        <content type="html"><![CDATA[<h3 id="cascade属性-指定级联操作的行为可多选">cascade属性： 指定级联操作的行为(可多选)</h3>
<ul>
<li><strong>CascadeType.PERSIST 级联新增（又称级联保存）：</strong><br>
获取A对象里也同时也重新获取最新的B时的对象。即会重新查询数据库里的最新数据，并且，只有A类新增时，会级联B对象新增。若B对象在数据库存（跟新）在则抛异常（让B变为持久态），对应EntityManager的presist方法,调用JPA规范中的persist()，不适用于Hibernate的save()方法</li>
<li><strong>CascadeType.MERGE 级联合并（又称级联更新）</strong><br>
指A类新增或者变化，会级联B对象（新增或者变化） ，对应EntityManager的merge方法，调用JPA规范中merge()时，不适用于Hibernate的update()方法</li>
<li><strong>CascadeType.REMOVE 级联删除</strong><br>
只有A类删除时，会级联删除B类,即在设置的那一端进行删除时，另一端才会级联删除，对应EntityManager的remove方法，调用JPA规范中的remove()时，适用于Hibernate的delete()方法</li>
<li><strong>CascadeType.REFRESH 级联刷新</strong><br>
获取order（一或多）对象里也同时也重新获取最新的items（多）的对象，对应EntityManager的refresh(object)，调用JPA规范中的refresh()时，适用于Hibernate的flush()方法</li>
<li><strong>CascadeType.ALL</strong><br>
包含所有持久化方法</li>
</ul>
<p><strong>综上：大多数情况用CascadeType.MERGE就能达到级联跟新又不报错，用CascadeType.ALL时要斟酌下CascadeType.REMOVE</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PostgreSQL踩坑记录]]></title>
        <id>https://cm940324.github.io/post/postgresql-ques/</id>
        <link href="https://cm940324.github.io/post/postgresql-ques/">
        </link>
        <updated>2021-06-03T06:26:03.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>在进行数据库记录的迁移和复制数据后容易出现错误</li>
</ol>
<pre><code>DETAIL:  Key (id)=(1) already exists
</code></pre>
<p>解决方案：</p>
<pre><code>select setval('tablename_id_seq', max(id)) from tablename;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式的通俗理解]]></title>
        <id>https://cm940324.github.io/post/shejimoshi-tongsu/</id>
        <link href="https://cm940324.github.io/post/shejimoshi-tongsu/">
        </link>
        <updated>2021-05-27T00:56:09.000Z</updated>
        <content type="html"><![CDATA[<h3 id="工厂方法">工厂方法</h3>
<p>追 MM 少不了请吃饭了，麦当劳的鸡翅和肯德基的鸡翅都是 MM 爱吃的东西，虽然口味有所不同，但不管你带 MM 去麦当劳或肯德基，只管向服务员说「来四个鸡翅」就行了。麦当劳和肯德基就是生产鸡翅的 Factory 工厂模式：客户类和工厂类分开。</p>
<p>消费者任何时候需要某种产品，只需向工厂请求即可。消费者无须修改就可以接纳新产品。缺点是当产品修改时，工厂类也要做相应的修改。如：如何创建及如何向客户端提供。</p>
<h3 id="建造者模式">建造者模式</h3>
<p>MM 最爱听的就是「我爱你」这句话了，见到不同地方的 MM，要能够用她们的方言跟她说这句话哦，我有一个多种语言翻译机，上面每种语言都有一个按键，见到 MM 我只要按对应的键，它就能够用相应的语言说出「我爱你」这句话了，国外的 MM 也可以轻松搞掂，这就是我的「我爱你」builder。</p>
<p>建造模式：将产品的内部表象和产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象。建造模式使得产品内部表象可以独立的变化，客户不必知道产品内部组成的细节。建造模式可以强制实行一种分步骤进行的建造过程。</p>
<h3 id="抽象工厂">抽象工厂</h3>
<p>请 MM 去麦当劳吃汉堡，不同的 MM 有不同的口味，要每个都记住是一件烦人的事情，我一般采用 Factory Method 模式，带着 MM 到服务员那儿，说「要一个汉堡」，具体要什么样的汉堡呢，让 MM 直接跟服务员说就行了。</p>
<p>工厂方法模式：核心工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类去做，成为一个抽象工厂角色，仅负责给出具体工厂类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。</p>
<h3 id="原型模式">原型模式</h3>
<p>跟 MM 用 QQ 聊天，一定要说些深情的话语了，我搜集了好多肉麻的情话，需要时只要 copy 出来放到 QQ 里面就行了，这就是我的情话 prototype 了。（100 块钱一份，你要不要）</p>
<p>原始模型模式：通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的方法创建出更多同类型的对象。原始模型模式允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。缺点是每一个类都必须配备一个克隆方法。</p>
<h3 id="单态模式">单态模式</h3>
<p>俺有 6 个漂亮的老婆，她们的老公都是我，我就是我们家里的老公 Sigleton，她们只要说道「老公」，都是指的同一个人，那就是我 (刚才做了个梦啦，哪有这么好的事)</p>
<p>单例模式：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式。单例模式只应在有真正的 “单一实例” 的需求时才可使用</p>
<h3 id="适配器模式">适配器模式</h3>
<p>在朋友聚会上碰到了一个美女 Sarah，从香港来的，可我不会说粤语，她不会说普通话，只好求助于我的朋友 kent 了，他作为我和 Sarah 之间的 Adapter，让我和 Sarah 可以相互交谈了 (也不知道他会不会耍我)</p>
<p>适配器（变压器）模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。适配类可以根据参数返还一个合适的实例给客户端。</p>
<h3 id="桥梁模式">桥梁模式</h3>
<p>早上碰到 MM，要说早上好，晚上碰到 MM，要说晚上好；碰到 MM 穿了件新衣服，要说你的衣服好漂亮哦，碰到 MM 新做的发型，要说你的头发好漂亮哦。不要问我 “早上碰到 MM 新做了个发型怎么说” 这种问题，自己用 BRIDGE 组合一下不就行了</p>
<p>桥梁模式：将抽象化与实现化脱耦，使得二者可以独立的变化，也就是说将他们之间的强关联变成弱关联，也就是指在一个软件系统的抽象化和实现化之间使用组合 / 聚合关系而不是继承关系，从而使两者可以独立的变化。</p>
<h3 id="合成模式">合成模式</h3>
<p>Mary 今天过生日。“我过生日，你要送我一件礼物。”“嗯，好吧，去商店，你自己挑。”“这件 T 恤挺漂亮，买，这条裙子好看，买，这个包也不错，买。”“喂，买了三件了呀，我只答应送一件礼物的哦。”“什么呀，T 恤加裙子加包包，正好配成一套呀，小姐，麻烦你包起来。”“……”，MM 都会用 Composite 模式了，你会了没有？</p>
<p>合成模式：合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。合成模式使得客户端把一个个单独的成分对象和由他们复合而成的合成对象同等看待。</p>
<h3 id="装饰模式">装饰模式</h3>
<p>Mary 过完轮到 Sarly 过生日，还是不要叫她自己挑了，不然这个月伙食费肯定玩完，拿出我去年在华山顶上照的照片，在背面写上 “最好的的礼物，就是爱你的 Fita”，再到街上礼品店买了个像框（卖礼品的 MM 也很漂亮哦），再找隔壁搞美术设计的 Mike 设计了一个漂亮的盒子装起来……，我们都是 Decorator，最终都在修饰我这个人呀，怎么样，看懂了吗？</p>
<p>装饰模式：装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案，提供比继承更多的灵活性。动态给一个对象增加功能，这些功能可以再动态的撤消。增加由一些基本功能的排列组合而产生的非常大量的功能。</p>
<h3 id="门面模式">门面模式</h3>
<p>我有一个专业的 Nikon 相机，我就喜欢自己手动调光圈、快门，这样照出来的照片才专业，但 MM 可不懂这些，教了半天也不会。幸好相机有 Facade 设计模式，把相机调整到自动档，只要对准目标按快门就行了，一切由相机自动调整，这样 MM 也可以用这个相机给我拍张照片了。门面模式：外部与一个子系统的通信必须通过一个统一的门面对象进行。</p>
<p>门面模式提供一个高层次的接口，使得子系统更易于使用。每一个子系统只有一个门面类，而且此门面类只有一个实例，也就是说它是一个单例模式。但整个系统可以有多个门面类。</p>
<h3 id="享元模式">享元模式</h3>
<p>每天跟 MM 发短信，手指都累死了，最近买了个新手机，可以把一些常用的句子存在手机里，要用的时候，直接拿出来，在前面加上 MM 的名字就可以发送了，再不用一个字一个字敲了。共享的句子就是 Flyweight，MM 的名字就是提取出来的外部特征，根据上下文情况使用。享元模式：FLYWEIGHT 在拳击比赛中指最轻量级。</p>
<p>享元模式以共享的方式高效的支持大量的细粒度对象。享元模式能做到共享的关键是区分内蕴状态和外蕴状态。内蕴状态存储在享元内部，不会随环境的改变而有所不同。外蕴状态是随环境的改变而改变的。外蕴状态不能影响内蕴状态，它们是相互独立的。</p>
<p>将可以共享的状态和不可以共享的状态从常规类中区分开来，将不可以共享的状态从类里剔除出去。客户端不可以直接创建被共享的对象，而应当使用一个工厂对象负责创建被共享的对象。享元模式大幅度的降低内存中对象的数量。</p>
<h3 id="代理模式">代理模式</h3>
<p>跟 MM 在网上聊天，一开头总是 “hi, 你好”,“你从哪儿来呀？”“你多大了？”“身高多少呀？” 这些话，真烦人，写个程序做为我的 Proxy 吧，凡是接收到这些话都设置好了自己的回答，接收到其他的话时再通知我回答，怎么样，酷吧。</p>
<p>代理模式：代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用。代理就是一个人或一个机构代表另一个人或者一个机构采取行动。某些情况下，客户不想或者不能够直接引用一个对象，代理对象可以在客户和目标对象直接起到中介的作用。</p>
<p>客户端分辨不出代理主题对象与真实主题对象。代理模式可以并不知道真正的被代理对象，而仅仅持有一个被代理对象的接口，这时候代理对象不能够创建被代理对象，被代理对象必须有系统的其他角色代为创建并传入。</p>
<h3 id="责任链模式">责任链模式</h3>
<p>晚上去上英语课，为了好开溜坐到了最后一排，哇，前面坐了好几个漂亮的 MM 哎，找张纸条，写上 “Hi, 可以做我的女朋友吗？如果不愿意请向前传”，纸条就一个接一个的传上去了，糟糕，传到第一排的 MM 把纸条传给老师了，听说是个老处女呀，快跑！</p>
<p>责任链模式：在责任链模式中，很多对象由每一个对象对其下家的引用而接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。客户并不知道链上的哪一个对象最终处理这个请求，系统可以在不影响客户端的情况下动态的重新组织链和分配责任。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象所接受。</p>
<h3 id="命令模式">命令模式</h3>
<p>俺有一个 MM 家里管得特别严，没法见面，只好借助于她弟弟在我们俩之间传送信息，她对我有什么指示，就写一张纸条让她弟弟带给我。这不，她弟弟又传送过来一个 COMMAND，为了感谢他，我请他吃了碗杂酱面，哪知道他说：“我同时给我姐姐三个男朋友送 COMMAND，就数你最小气，才请我吃面。”</p>
<p>命令模式：命令模式把一个请求或者操作封装到一个对象中。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。命令模式允许请求的一方和发送的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否执行，何时被执行以及是怎么被执行的。系统支持命令的撤消。</p>
<h3 id="解释器模式">解释器模式</h3>
<p>俺有一个《泡 MM 真经》，上面有各种泡 MM 的攻略，比如说去吃西餐的步骤、去看电影的方法等等，跟 MM 约会时，只要做一个 Interpreter，照着上面的脚本执行就可以了。</p>
<p>解释器模式：给定一个语言后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。解释器模式将描述怎样在有了一个简单的文法后，使用模式设计解释这些语句。</p>
<p>在解释器模式里面提到的语言是指任何解释器对象能够解释的任何组合。在解释器模式中需要定义一个代表文法的命令类的等级结构，也就是一系列的组合规则。每一个命令对象都有一个解释方法，代表对命令对象的解释。命令对象的等级结构中的对象的任何排列组合都是一个语言。</p>
<h3 id="迭代模式">迭代模式</h3>
<p>我爱上了 Mary，不顾一切的向她求婚。Mary：“想要我跟你结婚，得答应我的条件” 我：“什么条件我都答应，你说吧” Mary：“我看上了那个一克拉的钻石” 我：“我买，我买，还有吗？” Mary：“我看上了湖边的那栋别墅” 我：“我买，我买，还有吗？” Mary：“我看上那辆法拉利跑车” 我脑袋嗡的一声，坐在椅子上，一咬牙：“我买，我买，还有吗？”</p>
<p>迭代模式：迭代模式可以顺序访问一个聚集中的元素而不必暴露聚集的内部表象。多个对象聚在一起形成的总体称之为聚集，聚集对象是能够包容一组对象的容器对象。迭代子模式将迭代逻辑封装到一个独立的子对象中，从而与聚集本身隔开。</p>
<p>迭代模式简化了聚集的界面。每一个聚集对象都可以有一个或一个以上的迭代子对象，每一个迭代子的迭代状态可以是彼此独立的。迭代算法可以独立于聚集角色变化。</p>
<h3 id="调停者模式">调停者模式</h3>
<p>四个 MM 打麻将，相互之间谁应该给谁多少钱算不清楚了，幸亏当时我在旁边，按照各自的筹码数算钱，赚了钱的从我这里拿，赔了钱的也付给我，一切就 OK 啦，俺得到了四个 MM 的电话。调停者模式：调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使他们可以松散偶合。</p>
<p>当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。保证这些作用可以彼此独立的变化。调停者模式将多对多的相互作用转化为一对多的相互作用。调停者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。</p>
<h3 id="备忘录模式">备忘录模式</h3>
<p>同时跟几个 MM 聊天时，一定要记清楚刚才跟 MM 说了些什么话，不然 MM 发现了会不高兴的哦，幸亏我有个备忘录，刚才与哪个 MM 说了什么话我都拷贝一份放到备忘录里面保存，这样可以随时察看以前的记录啦。</p>
<p>备忘录模式：备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。</p>
<h3 id="观察者模式">观察者模式</h3>
<p>想知道咱们公司最新 MM 情报吗？加入公司的 MM 情报邮件组就行了，tom 负责搜集情报，他发现的新情报不用一个一个通知我们，直接发布给邮件组，我们作为订阅者（观察者）就可以及时收到情报啦。</p>
<p>观察者模式：观察者模式定义了一种一队多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。</p>
<h3 id="状态模式">状态模式</h3>
<p>跟 MM 交往时，一定要注意她的状态哦，在不同的状态时她的行为会有不同，比如你约她今天晚上去看电影，对你没兴趣的 MM 就会说 “有事情啦”，对你不讨厌但还没喜欢上的 MM 就会说 “好啊，不过可以带上我同事么？”，已经喜欢上你的 MM 就会说 “几点钟？看完电影再去泡吧怎么样？”，当然你看电影过程中表现良好的话，也可以把 MM 的状态从不讨厌不喜欢变成喜欢哦。</p>
<p>状态模式：状态模式允许一个对象在其内部状态改变的时候改变行为。这个对象看上去象是改变了它的类一样。状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。</p>
<p>状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。</p>
<h3 id="策略模式">策略模式</h3>
<p>跟不同类型的 MM 约会，要用不同的策略，有的请电影比较好，有的则去吃小吃效果不错，有的去海边浪漫最合适，单目的都是为了得到 MM 的芳心，我的追 MM 锦囊中有好多 Strategy 哦。策略模式：策略模式针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。</p>
<p>策略模式使得算法可以在不影响到客户端的情况下发生变化。策略模把行为和环境分开。环境类负责维持和查询行为类，各种算法在具体的策略类中提供。由于算法和环境独立开来，算法的增减，修改都不会影响到环境和客户端</p>
<h3 id="模版方法模式">模版方法模式</h3>
<p>看过《如何说服女生上床》这部经典文章吗？女生从认识到上床的不变的步骤分为巧遇、打破僵局、展开追求、接吻、前戏、动手、爱抚、进去八大步骤 (Template method)，但每个步骤针对不同的情况，都有不一样的做法，这就要看你随机应变啦 (具体实现)；</p>
<p>模板方法模式：模板方法模式准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。</p>
<h3 id="访问者模式">访问者模式</h3>
<p>情人节到了，要给每个 MM 送一束鲜花和一张卡片，可是每个 MM 送的花都要针对她个人的特点，每张卡片也要根据个人的特点来挑，我一个人哪搞得清楚，还是找花店老板和礼品店老板做一下 Visitor，让花店老板根据 MM 的特点选一束花，让礼品店老板也根据每个人特点选一张卡，这样就轻松多了；</p>
<p>访问者模式：访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。访问者模式使得增加新的操作变的很容易，就是增加一个新的访问者类。</p>
<p>访问者模式将有关的行为集中到一个访问者对象中，而不是分散到一个个的节点类中。当使用访问者模式时，要将尽可能多的对象浏览逻辑放在访问者类中，而不是放到它的子类中。访问者模式可以跨过几个类的等级结构访问属于不同的等级结构的成员类。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Thymeleaf常用属性]]></title>
        <id>https://cm940324.github.io/post/thymeleaf/</id>
        <link href="https://cm940324.github.io/post/thymeleaf/">
        </link>
        <updated>2021-05-21T09:12:09.000Z</updated>
        <content type="html"><![CDATA[<p>如需了解Thymeleaf 基本表达式，请参考《<a href="http://www.cnblogs.com/hjwublog/p/5051632.html">Thymeleaf </a><a href="http://www.cnblogs.com/hjwublog/p/5051632.html">基本表达式</a>》一文</p>
<h1 id="thaction"><strong>th:action</strong></h1>
<p>定义后台控制器路径，类似<form>标签的action属性。</p>
<p>例如：</p>
<pre><code>&lt;form id=&quot;login-form&quot; th:action=&quot;@{/login}&quot;&gt;...&lt;/form&gt;
</code></pre>
<h1 id="theach"><strong>th:each</strong></h1>
<p>对象遍历，功能类似jstl中的&lt;c:forEach&gt;标签。</p>
<p>例如：</p>
<pre><code>public class StudentRequestBean {

private List&lt;Student&gt; students;

...

}

public class Student implements Serializable{

private String firstName;

private String school;

...}

@RequestMapping(value = &quot;/addStudent&quot;, method = RequestMethod.POST)

public String addStudent(@ModelAttribute(value = &quot;stuReqBean&quot;) 

StudentRequestBean stuReqBean，ModelMap model) {...}
</code></pre>
<form id="login-form" th:action="@{/addStudent}" 
```
th:object="${stuReqBean}" method="POST">
<div class="student" th:each="stuIter,rowStat:${stuReqBean.students}">
<p>&lt;input type=&quot;text&quot; class=&quot;firstName&quot; value=&quot;&quot;</p>
<p>th:field=&quot;*{students[<strong>${rowStat.index}</strong>].firstName}&quot;&gt;</input></p>
<p>&lt;input type=&quot;text&quot; class=&quot;school&quot; value=&quot;&quot;</p>
<p>th:field=&quot;*{students[<strong>${rowStat.index}</strong>].school}&quot;&gt;</input></p>
<p>...</p>
</div>
</form>
```
<p>上面的例子中通过选择表达式*{}既能将表单绑定到后台的StudentRequestBean中的集合属性students，也能将Servlet上下文中的StudentRequestBean中的List类型的students变量回显，回显时通过th:each进行遍历。</p>
<p>注意1：绑定集合属性元素下标的用法*{students[<strong>${rowStat.index}</strong>].firstName}</p>
<p>注意2：如果List<Student> students为null，页面将无法显示表单，后台必须给students初始化一个值，即:</p>
<pre><code>List&lt;Student &gt; stus = new ArrayList&lt;Student &gt;();

stus .add(new Student ());

StudentRequestBean.setStudents(stus );
</code></pre>
<p>注意3：stuIter代表students的迭代器</p>
<h1 id="thfield"><strong>th:field</strong></h1>
<p>常用于表单字段绑定。通常与th:object一起使用。 属性绑定、集合绑定。</p>
<p>如：</p>
<pre><code>public class LoginBean implements Serializable{...

private String username;

private List&lt;User&gt; user;

...}


public class User implements Serializable{...

private String username;;

...}


@RequestMapping(value = &quot;/login&quot;, method = RequestMethod.POST)

public String login(@ModelAttribute(value = &quot;loginBean&quot;) LoginBean loginBean，ModelMap model) {..}
</code></pre>
<pre><code>&lt;form id=&quot;login-form&quot; th:action=&quot;@{/login}&quot; th:object=&quot;${loginBean}&quot;&gt;...

&lt;input type=&quot;text&quot; value=&quot;&quot; th:field=&quot;*{username}&quot;&gt;&lt;/input&gt;

&lt;input type=&quot;text&quot; value=&quot;&quot; th:field=&quot;*{user[0].username}&quot;&gt;&lt;/input&gt;

&lt;/form&gt;
</code></pre>
<h1 id="thhref"><strong>th:href</strong></h1>
<p>定义超链接，类似<a>标签的href 属性。value形式为@{/logout}</p>
<p>例如：</p>
<pre><code>&lt;a th:href=&quot;@{/logout}&quot; class=&quot;signOut&quot;&gt;&lt;/a&gt;
</code></pre>
<h1 id="thid"><strong>th:id</strong></h1>
<p>div id声明，类似html标签中的id属性。</p>
<p>例如：</p>
<pre><code>&lt;div class=&quot;student&quot; th:id = &quot;stu+(${rowStat.index}+1)&quot;&gt;&lt;/div&gt;
</code></pre>
<h1 id="thif"><strong>th:if</strong></h1>
<p>条件判断。</p>
<p>例如：</p>
<pre><code>&lt;div th:if=&quot;${rowStat.index} == 0&quot;&gt;... do something ...&lt;/div&gt;
</code></pre>
<h1 id="thinclude"><strong>th:include</strong></h1>
<p>见th:fragment</p>
<h1 id="thfragment"><strong>th:fragment</strong></h1>
<p>声明定义该属性的div为模板片段，常用与头文件、页尾文件的引入。常与th:include，th:replace一起使用。</p>
<p>例如：</p>
<p>声明模板片段/WEBINF/templates/footer. html</p>
<pre><code>&lt;div th: fragment=&quot; copy&quot; &gt;

© 2011 The Good Thymes Virtual Grocery

&lt;/div&gt;
</code></pre>
<p>引入模板片段</p>
<pre><code>&lt;div th: include=&quot; /templates/footer : : copy&quot; &gt;&lt;/div&gt;

&lt;div th: replace=&quot; /templates/footer : : copy&quot; &gt;&lt;/div&gt;
</code></pre>
<h1 id="thobject"><strong>th:object</strong></h1>
<p>用于表单数据对象绑定，将表单绑定到后台controller的一个JavaBean参数。常与th:field一起使用进行表单数据绑定。</p>
<p>例如：</p>
<pre><code>public class LoginBean implements Serializable{...}


@RequestMapping(value = &quot;/login&quot;, method = RequestMethod.POST)

public String login(@ModelAttribute(value = &quot;loginBean&quot;) LoginBean loginBean，ModelMap model) {...}
</code></pre>
<pre><code>&lt;form id=&quot;login-form&quot; th:action=&quot;@{/login}&quot; th:object=&quot;${loginBean}&quot;&gt;...&lt;/form&gt;
</code></pre>
<h1 id="thsrc"><strong>th:src</strong></h1>
<p>用于外部资源引入，类似于<script>标签的src属性，常与@{}一起使用。</p>
<p>例如：</p>
<pre><code>&lt;script th:src=&quot;@{/resources/js/jquery/jquery.json-2.4.min.js}&quot;
</code></pre>
<h1 id="threplace"><strong>th:replace</strong></h1>
<p>见th:fragment</p>
<h1 id="thtext"><strong>th:text</strong></h1>
<p>文本显示。</p>
<p>例如：</p>
<pre><code>&lt;td class=&quot;text&quot; th:text=&quot;${username}&quot; &gt;&lt;/td&gt;
</code></pre>
<h1 id="thvalue"><strong>th:value</strong></h1>
<p>用于标签复制，类似<option>标签的value属性。</p>
<p>例如:</p>
<pre><code>&lt;option th:value=&quot;Adult&quot;&gt;Adult&lt;/option&gt;

&lt;input  id=&quot;msg&quot; type=&quot;hidden&quot; th:value=&quot;${msg}&quot; /&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[搭建内容管理系统CMS（1）：如何支持内容生产？]]></title>
        <id>https://cm940324.github.io/post/cms1/</id>
        <link href="https://cm940324.github.io/post/cms1/">
        </link>
        <updated>2021-05-21T06:52:55.000Z</updated>
        <content type="html"><![CDATA[<pre><code>内容管理系统是一种位于WEB 前端（Web 服务器）和后端办公系统或流程（内容创作、编辑）之间的软件系统，本文是对于内容管理系统CMS在内容生产环节的总结与分享。
</code></pre>
<p><em><strong>*关于CMS内容管理系统：*</strong></em></p>
<p>内容管理系统（content management system，CMS）是一种位于WEB 前端（Web 服务器）和后端办公系统或流程（内容创作、编辑）之间的软件系统。</p>
<p>“内容”是任何类型的数字信息，可以是文本、图形图像、Web页面、业务文档、数据库表单、视频、声音、XML文件等。</p>
<h3 id="1-关于cms搭建的思考">1. 关于CMS搭建的思考</h3>
<p>通常，设计一个产品之前，我们需要思考以下几个基本的问题：</p>
<p>**产品目标：**我们希望通过这个产品得到什么？</p>
<p>——这决定我们要做成一个什么类型的产品</p>
<p>**目标用户：**产品面向的目标用户具有什么特征？</p>
<p>——这决定我们去哪找什么样的用户</p>
<p>**用户需求：**我们的用户希望通过这个产品得到什么？</p>
<p>——这决定我们要设计哪些功能模块</p>
<p>**场景动机：**我们的用户在什么样的场景下会有使用产品的动机？</p>
<p>——这决定我们要怎么设计产品</p>
<p>**标准指标：**想法正确、方案合理、市场匹配的标准/指标是什么？</p>
<p>——这决定我们的目标是否达成</p>
<p>我们需要思考和梳理的内容，可概括为3点：对象、痛点、解决方案。</p>
<p><strong>对象：</strong></p>
<ul>
<li>
<p>内容的生产人员，例：运营、用户（由用户端满足需求）</p>
</li>
<li>
<p>内容的审核人员，例：运营、客服</p>
</li>
<li>
<p>内容的推广人员，例：运营、用户（由用户端满足需求）</p>
</li>
<li>
<p>相互作用的系统，例：过滤系统、推荐系统</p>
</li>
</ul>
<p><strong>痛点：</strong></p>
<ul>
<li>
<p>运营：高效地完成内容生产、便捷地审核用户推荐、特定需求的人工推荐、推荐系统的精准度优化、及时直观地获取到内容运营的数据情况；</p>
</li>
<li>
<p>客服：便捷地审核用户举报、问题用户的管理、推荐系统的精准度优化；</p>
</li>
<li>
<p>过滤系统：对内容完成智能过滤；</p>
</li>
<li>
<p>推荐系统：对内容完成智能推荐。</p>
</li>
</ul>
<p><strong>解决方案：</strong></p>
<ul>
<li>运营：好用的内容编辑、修改和发布工具；待审核的处理工作台；人工推荐配置支持、推荐系统的运作情况；内容运营数据的可视化呈现；</li>
<li>客服：待审核的处理工作台；用户标记管理、过滤系统的运作情况；</li>
<li>过滤系统：系统的搭建和持续优化方案；</li>
<li>推荐系统：系统的搭建和持续优化方案。</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://cm940324.github.io/post-images/1621580833843.png" alt="" loading="lazy"></figure>
<h3 id="2-内容的生产来源">2. 内容的生产(来源)</h3>
<p>CMS内容管理系统，从字面意思就能知道，管理的对象是“内容”，而“内容”的具体类型是什么、“管理”的具体范畴是什么，这些都是要依据具体的业务而定。</p>
<p>得有内容才有管理，没内容谈何管理呢？那问题来了，内容从哪里来呢？来源都有哪些？</p>
<h4 id="21-常见的内容生产模式">2.1 常见的内容生产模式</h4>
<p>介绍一下常见的内容生产模式，有以下三种：</p>
<p><strong>UGC模式：</strong></p>
<ul>
<li>全称：user generated content。即：用户输出内容。</li>
<li>产品代表：小红书。主要通过激励用户生产内容，形成社区氛围。</li>
</ul>
<p><strong>PGC模式：</strong></p>
<ul>
<li>全称：professionally generated content。即：专业输出内容。</li>
<li>产品代表：知乎。主要通过专业人员生产内容，提供给用户消费。</li>
</ul>
<p><strong>OGC模式：</strong></p>
<ul>
<li>
<p>全称：occupationally generated content。即：职业输出内容。</p>
</li>
<li>
<p>产品代表：新闻资讯类。主要通过具有一定知识和专业背景的行业人士生产内容，并领取相应报酬。</p>
</li>
</ul>
<p><strong>三者之间的区别：</strong></p>
<ul>
<li>
<p>UGC与PGC的区别：生产内容的人有无专业知识、资质；</p>
</li>
<li>
<p>PGC与OGC的区别：生产内容的人是否以此为职业，获得对应的报酬。</p>
</li>
</ul>
<p>往往PGC模式的内容生产者，也是产品的用户，还可能是种子用户、忠诚用户、意见领袖。</p>
<p>综上，我们可以将内容的来源分成4种：</p>
<ul>
<li>用户生产（UGC&amp;PGC）</li>
<li>运营生产（OGC）</li>
<li>技术爬取（通过技术手段去爬取内容）</li>
<li>授权使用（以付费的形式购买内容版权）</li>
</ul>
<p>其中：用户生产内容的产品支持，可由用户端的产品设计来满足。</p>
<p>技术爬取和授权使用，在需求明确的前提下，主要是由技术人员来实现和对接。</p>
<p>如果存在与多家平台有版权内容的授权对接工作，那建议可开发统一的内容接入接口。不同的版权内容平台，可能对接的方式有着大大小小的差异，这里可能涉及到一定的开发工作量。作为一名尽职的B端产品经理，本着为公司降本（降低开发成本）提效（提高版本效率）的一贯原则，最理想的状态是把统一的接口文档一发，就能把部分的开发工作量给转移了出去。但现实往往都是很骨感的，如果对方是“爸爸”，愿意把内容的版权给你就已经很难得了，那还是得乖乖自个儿开发接入。</p>
<p>以过来人的经验（踩过坑的那种），这部分的工作不要过分依赖开发，由其独自对接完成，需要加入必要的管理和规划，以免重复低效的工作占用太多的开发资源，或是人员离职变动带来的麻烦。至于价值、重要程度和优先级，需依据自己的项目、产品和团队情况，具体评估。</p>
<p>而内容管理系统（CMS）在生产环节主要服务的对象是负责内容生产的运营小伙伴。</p>
<p>一般情况下，内容运营除了管理官方账号外，可能同时还在运营着多个个人账号，如果运营同事也是依靠用户端来完成内容发布的工作，那就会存在频繁切换登录不同账号的麻烦。而切换登录这个需求对于普通用户可能根本就不存在。</p>
<p>除此之外，内容运营还存在用户需求之上的发布需求，比如可以预设定时发布等等。</p>
<h4 id="22-cms在生产环节的需求点">2.2 CMS在生产环节的需求点</h4>
<p>总结一下，内容管理系统（CMS）在生产环节的需求概要有：</p>
<p><strong>账号关联：</strong></p>
<ul>
<li>
<p>和CMS系统账号关联，支持系统账号和运营账号一对多的关系；</p>
</li>
<li>
<p>使用CMS系统发布内容时候，可选择对应的运营账号；</p>
</li>
<li>
<p>支持运营账号解除绑定或转移，以便应对人员调整或离职的变动。</p>
</li>
</ul>
<p><strong>生产工具：</strong></p>
<ul>
<li>提供便捷、好用的编辑功能；</li>
<li>支持效果预览；</li>
<li>可保存草稿。</li>
</ul>
<p>**素材管理：**如果对素材的复用度较高，可考虑增加素材管理，同时也方便随时随地有台电脑登录系统就能开展工作，避免素材要用起来才发现保存在某台电脑本地的尴尬。</p>
<p>**模板管理：**如果对特定内容的排版呈现有统一的要求，例如“每日推荐”等，只需要替换具体内容和素材即可，则可以增加模板管理，为运营减免重复不必要的排版布局工作。</p>
<p><strong>预设时间发布：</strong></p>
<ul>
<li>内容通常都是提前就会准备好的，尤其是针对一些节日主题或活动营销的内容，会提前思考、撰写，并对更新的节奏做好规划排期（就像产品经理做版本规划一样）。</li>
<li>如果有提供定时发布功能，那负责内容运营的同事就可以集中时间一次性地把准备好的内容提前设置好发布时间，使其更合理的安排工作时间和实施内容计划，提高工作效率。</li>
</ul>
<p>早期的版本，可仅提供基本的、必要的管理、编辑和发布功能，保证内容运营的顺利生产。而更能提高效率的工具和功能，则可与运营部门确认整体的内容工作规划，在不同的时期配合新增上线。</p>
<p>具体的功能设计可参考：微信公众平台、秀米编辑器、365编辑器。</p>
<p>以上，就是对于内容管理系统CMS在内容生产环节的总结与分享。后面，还会有CMS在内容过滤、内容呈现和内容举报环节的文章更新。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[AmazonS3工具类]]></title>
        <id>https://cm940324.github.io/post/amazons3-util/</id>
        <link href="https://cm940324.github.io/post/amazons3-util/">
        </link>
        <updated>2021-05-13T07:00:29.000Z</updated>
        <content type="html"><![CDATA[<pre><code>/**
 * @author chenmo
 * @Date: Created in 2021/5/12 5:05 下午
 * @Utils: Intellij Idea
 * @Description: TODO
 */
@Component
@RequiredArgsConstructor
public class AmazonS3Operator {

    private static final Logger LOGGER = LoggerFactory.getLogger(AmazonS3Operator.class);

    final AmazonS3Configuration amazonS3Configuration;

    //创建链接
    public AmazonS3 createConnection(){
        var credentials = new BasicAWSCredentials(amazonS3Configuration.getAccessKey(), amazonS3Configuration.getSecretKey());
        var conn = new AmazonS3Client(credentials);
        conn.setEndpoint(amazonS3Configuration.getEndPoint());
        var buckets = conn.listBuckets();
        LOGGER.info(&quot;amazonS3 bucket list ==========================================&quot;);
        for (Bucket bucket : buckets) {
            LOGGER.info(&quot;amazonS3 bucket =========&gt;&quot;+bucket.getName() + &quot;\t&quot; +
                    StringUtils.fromDate(bucket.getCreationDate()));
        }
        LOGGER.info(&quot;================================================================&quot;);
        return conn;
    }

    //创建Bucket
    public Bucket createBucket(String name){
        return createConnection().createBucket(name);
    }

    //上传一个文件
    public String uploadFileToBucket(MultipartFile multipartFile){
        var snowflake = new Snowflake(1,1);
        var key = snowflake.nextIdStr();
        FileInputStream fileInputStream = null;
        try {
            fileInputStream = (FileInputStream) multipartFile.getInputStream();
            createConnection().putObject(amazonS3Configuration.getBucket(),key,fileInputStream,new ObjectMetadata());
            LOGGER.info(&quot;上传文件&quot;+key+&quot;：&quot;+multipartFile.getName()+ &quot;到&quot;+amazonS3Configuration.getBucket()+&quot;成功！！！！&quot;);
            return key;
        }catch (FileNotFoundException e){
            LOGGER.info(&quot;上传文件&quot;+key+&quot;：&quot;+multipartFile.getName()+  &quot;到&quot;+amazonS3Configuration.getBucket()+&quot;失败，文件未找到&quot;);
            return null;
        }catch (IOException e){
            e.printStackTrace();
            return null;
        }finally {
            try {
                if(fileInputStream != null){
                    fileInputStream.close();
                }
            }catch (IOException e){
                LOGGER.debug(&quot;inputStream close IOException:&quot; + e.getMessage());
                e.printStackTrace();
            }
        }
    }

    //预览一个文件
    public String reviewFileFromBucket(String key){
        try {
            if(StringUtils.isNullOrEmpty(key)){
                return null;
            }
            var httpRequest = new GeneratePresignedUrlRequest(amazonS3Configuration.getBucket(), key);
            return createConnection().generatePresignedUrl(httpRequest).toString();
        }catch (Exception e){
            e.printStackTrace();
        }
        return null;
    }

}
</code></pre>
]]></content>
    </entry>
</feed>