<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://cm940324.github.io</id>
    <title>Oasis</title>
    <updated>2021-06-03T06:40:56.593Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://cm940324.github.io"/>
    <link rel="self" href="https://cm940324.github.io/atom.xml"/>
    <subtitle>&lt;a href=&quot;https://cm940324.github.io/&quot; target=&quot;_blank&quot;&gt;code blog&lt;/a&gt;</subtitle>
    <logo>https://cm940324.github.io/images/avatar.png</logo>
    <icon>https://cm940324.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Oasis</rights>
    <entry>
        <title type="html"><![CDATA[PostgreSQL踩坑记录]]></title>
        <id>https://cm940324.github.io/post/postgresql-ques/</id>
        <link href="https://cm940324.github.io/post/postgresql-ques/">
        </link>
        <updated>2021-06-03T06:26:03.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>在进行数据库记录的迁移和复制数据后容易出现错误</li>
</ol>
<pre><code>DETAIL:  Key (id)=(1) already exists
</code></pre>
<p>解决方案：</p>
<pre><code>select setval('tablename_id_seq', max(id)) from tablename;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式的通俗理解]]></title>
        <id>https://cm940324.github.io/post/shejimoshi-tongsu/</id>
        <link href="https://cm940324.github.io/post/shejimoshi-tongsu/">
        </link>
        <updated>2021-05-27T00:56:09.000Z</updated>
        <content type="html"><![CDATA[<h3 id="工厂方法">工厂方法</h3>
<p>追 MM 少不了请吃饭了，麦当劳的鸡翅和肯德基的鸡翅都是 MM 爱吃的东西，虽然口味有所不同，但不管你带 MM 去麦当劳或肯德基，只管向服务员说「来四个鸡翅」就行了。麦当劳和肯德基就是生产鸡翅的 Factory 工厂模式：客户类和工厂类分开。</p>
<p>消费者任何时候需要某种产品，只需向工厂请求即可。消费者无须修改就可以接纳新产品。缺点是当产品修改时，工厂类也要做相应的修改。如：如何创建及如何向客户端提供。</p>
<h3 id="建造者模式">建造者模式</h3>
<p>MM 最爱听的就是「我爱你」这句话了，见到不同地方的 MM，要能够用她们的方言跟她说这句话哦，我有一个多种语言翻译机，上面每种语言都有一个按键，见到 MM 我只要按对应的键，它就能够用相应的语言说出「我爱你」这句话了，国外的 MM 也可以轻松搞掂，这就是我的「我爱你」builder。</p>
<p>建造模式：将产品的内部表象和产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象。建造模式使得产品内部表象可以独立的变化，客户不必知道产品内部组成的细节。建造模式可以强制实行一种分步骤进行的建造过程。</p>
<h3 id="抽象工厂">抽象工厂</h3>
<p>请 MM 去麦当劳吃汉堡，不同的 MM 有不同的口味，要每个都记住是一件烦人的事情，我一般采用 Factory Method 模式，带着 MM 到服务员那儿，说「要一个汉堡」，具体要什么样的汉堡呢，让 MM 直接跟服务员说就行了。</p>
<p>工厂方法模式：核心工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类去做，成为一个抽象工厂角色，仅负责给出具体工厂类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。</p>
<h3 id="原型模式">原型模式</h3>
<p>跟 MM 用 QQ 聊天，一定要说些深情的话语了，我搜集了好多肉麻的情话，需要时只要 copy 出来放到 QQ 里面就行了，这就是我的情话 prototype 了。（100 块钱一份，你要不要）</p>
<p>原始模型模式：通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的方法创建出更多同类型的对象。原始模型模式允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。缺点是每一个类都必须配备一个克隆方法。</p>
<h3 id="单态模式">单态模式</h3>
<p>俺有 6 个漂亮的老婆，她们的老公都是我，我就是我们家里的老公 Sigleton，她们只要说道「老公」，都是指的同一个人，那就是我 (刚才做了个梦啦，哪有这么好的事)</p>
<p>单例模式：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式。单例模式只应在有真正的 “单一实例” 的需求时才可使用</p>
<h3 id="适配器模式">适配器模式</h3>
<p>在朋友聚会上碰到了一个美女 Sarah，从香港来的，可我不会说粤语，她不会说普通话，只好求助于我的朋友 kent 了，他作为我和 Sarah 之间的 Adapter，让我和 Sarah 可以相互交谈了 (也不知道他会不会耍我)</p>
<p>适配器（变压器）模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。适配类可以根据参数返还一个合适的实例给客户端。</p>
<h3 id="桥梁模式">桥梁模式</h3>
<p>早上碰到 MM，要说早上好，晚上碰到 MM，要说晚上好；碰到 MM 穿了件新衣服，要说你的衣服好漂亮哦，碰到 MM 新做的发型，要说你的头发好漂亮哦。不要问我 “早上碰到 MM 新做了个发型怎么说” 这种问题，自己用 BRIDGE 组合一下不就行了</p>
<p>桥梁模式：将抽象化与实现化脱耦，使得二者可以独立的变化，也就是说将他们之间的强关联变成弱关联，也就是指在一个软件系统的抽象化和实现化之间使用组合 / 聚合关系而不是继承关系，从而使两者可以独立的变化。</p>
<h3 id="合成模式">合成模式</h3>
<p>Mary 今天过生日。“我过生日，你要送我一件礼物。”“嗯，好吧，去商店，你自己挑。”“这件 T 恤挺漂亮，买，这条裙子好看，买，这个包也不错，买。”“喂，买了三件了呀，我只答应送一件礼物的哦。”“什么呀，T 恤加裙子加包包，正好配成一套呀，小姐，麻烦你包起来。”“……”，MM 都会用 Composite 模式了，你会了没有？</p>
<p>合成模式：合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。合成模式使得客户端把一个个单独的成分对象和由他们复合而成的合成对象同等看待。</p>
<h3 id="装饰模式">装饰模式</h3>
<p>Mary 过完轮到 Sarly 过生日，还是不要叫她自己挑了，不然这个月伙食费肯定玩完，拿出我去年在华山顶上照的照片，在背面写上 “最好的的礼物，就是爱你的 Fita”，再到街上礼品店买了个像框（卖礼品的 MM 也很漂亮哦），再找隔壁搞美术设计的 Mike 设计了一个漂亮的盒子装起来……，我们都是 Decorator，最终都在修饰我这个人呀，怎么样，看懂了吗？</p>
<p>装饰模式：装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案，提供比继承更多的灵活性。动态给一个对象增加功能，这些功能可以再动态的撤消。增加由一些基本功能的排列组合而产生的非常大量的功能。</p>
<h3 id="门面模式">门面模式</h3>
<p>我有一个专业的 Nikon 相机，我就喜欢自己手动调光圈、快门，这样照出来的照片才专业，但 MM 可不懂这些，教了半天也不会。幸好相机有 Facade 设计模式，把相机调整到自动档，只要对准目标按快门就行了，一切由相机自动调整，这样 MM 也可以用这个相机给我拍张照片了。门面模式：外部与一个子系统的通信必须通过一个统一的门面对象进行。</p>
<p>门面模式提供一个高层次的接口，使得子系统更易于使用。每一个子系统只有一个门面类，而且此门面类只有一个实例，也就是说它是一个单例模式。但整个系统可以有多个门面类。</p>
<h3 id="享元模式">享元模式</h3>
<p>每天跟 MM 发短信，手指都累死了，最近买了个新手机，可以把一些常用的句子存在手机里，要用的时候，直接拿出来，在前面加上 MM 的名字就可以发送了，再不用一个字一个字敲了。共享的句子就是 Flyweight，MM 的名字就是提取出来的外部特征，根据上下文情况使用。享元模式：FLYWEIGHT 在拳击比赛中指最轻量级。</p>
<p>享元模式以共享的方式高效的支持大量的细粒度对象。享元模式能做到共享的关键是区分内蕴状态和外蕴状态。内蕴状态存储在享元内部，不会随环境的改变而有所不同。外蕴状态是随环境的改变而改变的。外蕴状态不能影响内蕴状态，它们是相互独立的。</p>
<p>将可以共享的状态和不可以共享的状态从常规类中区分开来，将不可以共享的状态从类里剔除出去。客户端不可以直接创建被共享的对象，而应当使用一个工厂对象负责创建被共享的对象。享元模式大幅度的降低内存中对象的数量。</p>
<h3 id="代理模式">代理模式</h3>
<p>跟 MM 在网上聊天，一开头总是 “hi, 你好”,“你从哪儿来呀？”“你多大了？”“身高多少呀？” 这些话，真烦人，写个程序做为我的 Proxy 吧，凡是接收到这些话都设置好了自己的回答，接收到其他的话时再通知我回答，怎么样，酷吧。</p>
<p>代理模式：代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用。代理就是一个人或一个机构代表另一个人或者一个机构采取行动。某些情况下，客户不想或者不能够直接引用一个对象，代理对象可以在客户和目标对象直接起到中介的作用。</p>
<p>客户端分辨不出代理主题对象与真实主题对象。代理模式可以并不知道真正的被代理对象，而仅仅持有一个被代理对象的接口，这时候代理对象不能够创建被代理对象，被代理对象必须有系统的其他角色代为创建并传入。</p>
<h3 id="责任链模式">责任链模式</h3>
<p>晚上去上英语课，为了好开溜坐到了最后一排，哇，前面坐了好几个漂亮的 MM 哎，找张纸条，写上 “Hi, 可以做我的女朋友吗？如果不愿意请向前传”，纸条就一个接一个的传上去了，糟糕，传到第一排的 MM 把纸条传给老师了，听说是个老处女呀，快跑！</p>
<p>责任链模式：在责任链模式中，很多对象由每一个对象对其下家的引用而接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。客户并不知道链上的哪一个对象最终处理这个请求，系统可以在不影响客户端的情况下动态的重新组织链和分配责任。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象所接受。</p>
<h3 id="命令模式">命令模式</h3>
<p>俺有一个 MM 家里管得特别严，没法见面，只好借助于她弟弟在我们俩之间传送信息，她对我有什么指示，就写一张纸条让她弟弟带给我。这不，她弟弟又传送过来一个 COMMAND，为了感谢他，我请他吃了碗杂酱面，哪知道他说：“我同时给我姐姐三个男朋友送 COMMAND，就数你最小气，才请我吃面。”</p>
<p>命令模式：命令模式把一个请求或者操作封装到一个对象中。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。命令模式允许请求的一方和发送的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否执行，何时被执行以及是怎么被执行的。系统支持命令的撤消。</p>
<h3 id="解释器模式">解释器模式</h3>
<p>俺有一个《泡 MM 真经》，上面有各种泡 MM 的攻略，比如说去吃西餐的步骤、去看电影的方法等等，跟 MM 约会时，只要做一个 Interpreter，照着上面的脚本执行就可以了。</p>
<p>解释器模式：给定一个语言后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。解释器模式将描述怎样在有了一个简单的文法后，使用模式设计解释这些语句。</p>
<p>在解释器模式里面提到的语言是指任何解释器对象能够解释的任何组合。在解释器模式中需要定义一个代表文法的命令类的等级结构，也就是一系列的组合规则。每一个命令对象都有一个解释方法，代表对命令对象的解释。命令对象的等级结构中的对象的任何排列组合都是一个语言。</p>
<h3 id="迭代模式">迭代模式</h3>
<p>我爱上了 Mary，不顾一切的向她求婚。Mary：“想要我跟你结婚，得答应我的条件” 我：“什么条件我都答应，你说吧” Mary：“我看上了那个一克拉的钻石” 我：“我买，我买，还有吗？” Mary：“我看上了湖边的那栋别墅” 我：“我买，我买，还有吗？” Mary：“我看上那辆法拉利跑车” 我脑袋嗡的一声，坐在椅子上，一咬牙：“我买，我买，还有吗？”</p>
<p>迭代模式：迭代模式可以顺序访问一个聚集中的元素而不必暴露聚集的内部表象。多个对象聚在一起形成的总体称之为聚集，聚集对象是能够包容一组对象的容器对象。迭代子模式将迭代逻辑封装到一个独立的子对象中，从而与聚集本身隔开。</p>
<p>迭代模式简化了聚集的界面。每一个聚集对象都可以有一个或一个以上的迭代子对象，每一个迭代子的迭代状态可以是彼此独立的。迭代算法可以独立于聚集角色变化。</p>
<h3 id="调停者模式">调停者模式</h3>
<p>四个 MM 打麻将，相互之间谁应该给谁多少钱算不清楚了，幸亏当时我在旁边，按照各自的筹码数算钱，赚了钱的从我这里拿，赔了钱的也付给我，一切就 OK 啦，俺得到了四个 MM 的电话。调停者模式：调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使他们可以松散偶合。</p>
<p>当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。保证这些作用可以彼此独立的变化。调停者模式将多对多的相互作用转化为一对多的相互作用。调停者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。</p>
<h3 id="备忘录模式">备忘录模式</h3>
<p>同时跟几个 MM 聊天时，一定要记清楚刚才跟 MM 说了些什么话，不然 MM 发现了会不高兴的哦，幸亏我有个备忘录，刚才与哪个 MM 说了什么话我都拷贝一份放到备忘录里面保存，这样可以随时察看以前的记录啦。</p>
<p>备忘录模式：备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。</p>
<h3 id="观察者模式">观察者模式</h3>
<p>想知道咱们公司最新 MM 情报吗？加入公司的 MM 情报邮件组就行了，tom 负责搜集情报，他发现的新情报不用一个一个通知我们，直接发布给邮件组，我们作为订阅者（观察者）就可以及时收到情报啦。</p>
<p>观察者模式：观察者模式定义了一种一队多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。</p>
<h3 id="状态模式">状态模式</h3>
<p>跟 MM 交往时，一定要注意她的状态哦，在不同的状态时她的行为会有不同，比如你约她今天晚上去看电影，对你没兴趣的 MM 就会说 “有事情啦”，对你不讨厌但还没喜欢上的 MM 就会说 “好啊，不过可以带上我同事么？”，已经喜欢上你的 MM 就会说 “几点钟？看完电影再去泡吧怎么样？”，当然你看电影过程中表现良好的话，也可以把 MM 的状态从不讨厌不喜欢变成喜欢哦。</p>
<p>状态模式：状态模式允许一个对象在其内部状态改变的时候改变行为。这个对象看上去象是改变了它的类一样。状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。</p>
<p>状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。</p>
<h3 id="策略模式">策略模式</h3>
<p>跟不同类型的 MM 约会，要用不同的策略，有的请电影比较好，有的则去吃小吃效果不错，有的去海边浪漫最合适，单目的都是为了得到 MM 的芳心，我的追 MM 锦囊中有好多 Strategy 哦。策略模式：策略模式针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。</p>
<p>策略模式使得算法可以在不影响到客户端的情况下发生变化。策略模把行为和环境分开。环境类负责维持和查询行为类，各种算法在具体的策略类中提供。由于算法和环境独立开来，算法的增减，修改都不会影响到环境和客户端</p>
<h3 id="模版方法模式">模版方法模式</h3>
<p>看过《如何说服女生上床》这部经典文章吗？女生从认识到上床的不变的步骤分为巧遇、打破僵局、展开追求、接吻、前戏、动手、爱抚、进去八大步骤 (Template method)，但每个步骤针对不同的情况，都有不一样的做法，这就要看你随机应变啦 (具体实现)；</p>
<p>模板方法模式：模板方法模式准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。</p>
<h3 id="访问者模式">访问者模式</h3>
<p>情人节到了，要给每个 MM 送一束鲜花和一张卡片，可是每个 MM 送的花都要针对她个人的特点，每张卡片也要根据个人的特点来挑，我一个人哪搞得清楚，还是找花店老板和礼品店老板做一下 Visitor，让花店老板根据 MM 的特点选一束花，让礼品店老板也根据每个人特点选一张卡，这样就轻松多了；</p>
<p>访问者模式：访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。访问者模式使得增加新的操作变的很容易，就是增加一个新的访问者类。</p>
<p>访问者模式将有关的行为集中到一个访问者对象中，而不是分散到一个个的节点类中。当使用访问者模式时，要将尽可能多的对象浏览逻辑放在访问者类中，而不是放到它的子类中。访问者模式可以跨过几个类的等级结构访问属于不同的等级结构的成员类。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Thymeleaf常用属性]]></title>
        <id>https://cm940324.github.io/post/thymeleaf/</id>
        <link href="https://cm940324.github.io/post/thymeleaf/">
        </link>
        <updated>2021-05-21T09:12:09.000Z</updated>
        <content type="html"><![CDATA[<p>如需了解Thymeleaf 基本表达式，请参考《<a href="http://www.cnblogs.com/hjwublog/p/5051632.html">Thymeleaf </a><a href="http://www.cnblogs.com/hjwublog/p/5051632.html">基本表达式</a>》一文</p>
<h1 id="thaction"><strong>th:action</strong></h1>
<p>定义后台控制器路径，类似<form>标签的action属性。</p>
<p>例如：</p>
<pre><code>&lt;form id=&quot;login-form&quot; th:action=&quot;@{/login}&quot;&gt;...&lt;/form&gt;
</code></pre>
<h1 id="theach"><strong>th:each</strong></h1>
<p>对象遍历，功能类似jstl中的&lt;c:forEach&gt;标签。</p>
<p>例如：</p>
<pre><code>public class StudentRequestBean {

private List&lt;Student&gt; students;

...

}

public class Student implements Serializable{

private String firstName;

private String school;

...}

@RequestMapping(value = &quot;/addStudent&quot;, method = RequestMethod.POST)

public String addStudent(@ModelAttribute(value = &quot;stuReqBean&quot;) 

StudentRequestBean stuReqBean，ModelMap model) {...}
</code></pre>
<form id="login-form" th:action="@{/addStudent}" 
```
th:object="${stuReqBean}" method="POST">
<div class="student" th:each="stuIter,rowStat:${stuReqBean.students}">
<p>&lt;input type=&quot;text&quot; class=&quot;firstName&quot; value=&quot;&quot;</p>
<p>th:field=&quot;*{students[<strong>${rowStat.index}</strong>].firstName}&quot;&gt;</input></p>
<p>&lt;input type=&quot;text&quot; class=&quot;school&quot; value=&quot;&quot;</p>
<p>th:field=&quot;*{students[<strong>${rowStat.index}</strong>].school}&quot;&gt;</input></p>
<p>...</p>
</div>
</form>
```
<p>上面的例子中通过选择表达式*{}既能将表单绑定到后台的StudentRequestBean中的集合属性students，也能将Servlet上下文中的StudentRequestBean中的List类型的students变量回显，回显时通过th:each进行遍历。</p>
<p>注意1：绑定集合属性元素下标的用法*{students[<strong>${rowStat.index}</strong>].firstName}</p>
<p>注意2：如果List<Student> students为null，页面将无法显示表单，后台必须给students初始化一个值，即:</p>
<pre><code>List&lt;Student &gt; stus = new ArrayList&lt;Student &gt;();

stus .add(new Student ());

StudentRequestBean.setStudents(stus );
</code></pre>
<p>注意3：stuIter代表students的迭代器</p>
<h1 id="thfield"><strong>th:field</strong></h1>
<p>常用于表单字段绑定。通常与th:object一起使用。 属性绑定、集合绑定。</p>
<p>如：</p>
<pre><code>public class LoginBean implements Serializable{...

private String username;

private List&lt;User&gt; user;

...}


public class User implements Serializable{...

private String username;;

...}


@RequestMapping(value = &quot;/login&quot;, method = RequestMethod.POST)

public String login(@ModelAttribute(value = &quot;loginBean&quot;) LoginBean loginBean，ModelMap model) {..}
</code></pre>
<pre><code>&lt;form id=&quot;login-form&quot; th:action=&quot;@{/login}&quot; th:object=&quot;${loginBean}&quot;&gt;...

&lt;input type=&quot;text&quot; value=&quot;&quot; th:field=&quot;*{username}&quot;&gt;&lt;/input&gt;

&lt;input type=&quot;text&quot; value=&quot;&quot; th:field=&quot;*{user[0].username}&quot;&gt;&lt;/input&gt;

&lt;/form&gt;
</code></pre>
<h1 id="thhref"><strong>th:href</strong></h1>
<p>定义超链接，类似<a>标签的href 属性。value形式为@{/logout}</p>
<p>例如：</p>
<pre><code>&lt;a th:href=&quot;@{/logout}&quot; class=&quot;signOut&quot;&gt;&lt;/a&gt;
</code></pre>
<h1 id="thid"><strong>th:id</strong></h1>
<p>div id声明，类似html标签中的id属性。</p>
<p>例如：</p>
<pre><code>&lt;div class=&quot;student&quot; th:id = &quot;stu+(${rowStat.index}+1)&quot;&gt;&lt;/div&gt;
</code></pre>
<h1 id="thif"><strong>th:if</strong></h1>
<p>条件判断。</p>
<p>例如：</p>
<pre><code>&lt;div th:if=&quot;${rowStat.index} == 0&quot;&gt;... do something ...&lt;/div&gt;
</code></pre>
<h1 id="thinclude"><strong>th:include</strong></h1>
<p>见th:fragment</p>
<h1 id="thfragment"><strong>th:fragment</strong></h1>
<p>声明定义该属性的div为模板片段，常用与头文件、页尾文件的引入。常与th:include，th:replace一起使用。</p>
<p>例如：</p>
<p>声明模板片段/WEBINF/templates/footer. html</p>
<pre><code>&lt;div th: fragment=&quot; copy&quot; &gt;

© 2011 The Good Thymes Virtual Grocery

&lt;/div&gt;
</code></pre>
<p>引入模板片段</p>
<pre><code>&lt;div th: include=&quot; /templates/footer : : copy&quot; &gt;&lt;/div&gt;

&lt;div th: replace=&quot; /templates/footer : : copy&quot; &gt;&lt;/div&gt;
</code></pre>
<h1 id="thobject"><strong>th:object</strong></h1>
<p>用于表单数据对象绑定，将表单绑定到后台controller的一个JavaBean参数。常与th:field一起使用进行表单数据绑定。</p>
<p>例如：</p>
<pre><code>public class LoginBean implements Serializable{...}


@RequestMapping(value = &quot;/login&quot;, method = RequestMethod.POST)

public String login(@ModelAttribute(value = &quot;loginBean&quot;) LoginBean loginBean，ModelMap model) {...}
</code></pre>
<pre><code>&lt;form id=&quot;login-form&quot; th:action=&quot;@{/login}&quot; th:object=&quot;${loginBean}&quot;&gt;...&lt;/form&gt;
</code></pre>
<h1 id="thsrc"><strong>th:src</strong></h1>
<p>用于外部资源引入，类似于<script>标签的src属性，常与@{}一起使用。</p>
<p>例如：</p>
<pre><code>&lt;script th:src=&quot;@{/resources/js/jquery/jquery.json-2.4.min.js}&quot;
</code></pre>
<h1 id="threplace"><strong>th:replace</strong></h1>
<p>见th:fragment</p>
<h1 id="thtext"><strong>th:text</strong></h1>
<p>文本显示。</p>
<p>例如：</p>
<pre><code>&lt;td class=&quot;text&quot; th:text=&quot;${username}&quot; &gt;&lt;/td&gt;
</code></pre>
<h1 id="thvalue"><strong>th:value</strong></h1>
<p>用于标签复制，类似<option>标签的value属性。</p>
<p>例如:</p>
<pre><code>&lt;option th:value=&quot;Adult&quot;&gt;Adult&lt;/option&gt;

&lt;input  id=&quot;msg&quot; type=&quot;hidden&quot; th:value=&quot;${msg}&quot; /&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[搭建内容管理系统CMS（1）：如何支持内容生产？]]></title>
        <id>https://cm940324.github.io/post/cms1/</id>
        <link href="https://cm940324.github.io/post/cms1/">
        </link>
        <updated>2021-05-21T06:52:55.000Z</updated>
        <content type="html"><![CDATA[<pre><code>内容管理系统是一种位于WEB 前端（Web 服务器）和后端办公系统或流程（内容创作、编辑）之间的软件系统，本文是对于内容管理系统CMS在内容生产环节的总结与分享。
</code></pre>
<p><em><strong>*关于CMS内容管理系统：*</strong></em></p>
<p>内容管理系统（content management system，CMS）是一种位于WEB 前端（Web 服务器）和后端办公系统或流程（内容创作、编辑）之间的软件系统。</p>
<p>“内容”是任何类型的数字信息，可以是文本、图形图像、Web页面、业务文档、数据库表单、视频、声音、XML文件等。</p>
<h3 id="1-关于cms搭建的思考">1. 关于CMS搭建的思考</h3>
<p>通常，设计一个产品之前，我们需要思考以下几个基本的问题：</p>
<p>**产品目标：**我们希望通过这个产品得到什么？</p>
<p>——这决定我们要做成一个什么类型的产品</p>
<p>**目标用户：**产品面向的目标用户具有什么特征？</p>
<p>——这决定我们去哪找什么样的用户</p>
<p>**用户需求：**我们的用户希望通过这个产品得到什么？</p>
<p>——这决定我们要设计哪些功能模块</p>
<p>**场景动机：**我们的用户在什么样的场景下会有使用产品的动机？</p>
<p>——这决定我们要怎么设计产品</p>
<p>**标准指标：**想法正确、方案合理、市场匹配的标准/指标是什么？</p>
<p>——这决定我们的目标是否达成</p>
<p>我们需要思考和梳理的内容，可概括为3点：对象、痛点、解决方案。</p>
<p><strong>对象：</strong></p>
<ul>
<li>
<p>内容的生产人员，例：运营、用户（由用户端满足需求）</p>
</li>
<li>
<p>内容的审核人员，例：运营、客服</p>
</li>
<li>
<p>内容的推广人员，例：运营、用户（由用户端满足需求）</p>
</li>
<li>
<p>相互作用的系统，例：过滤系统、推荐系统</p>
</li>
</ul>
<p><strong>痛点：</strong></p>
<ul>
<li>
<p>运营：高效地完成内容生产、便捷地审核用户推荐、特定需求的人工推荐、推荐系统的精准度优化、及时直观地获取到内容运营的数据情况；</p>
</li>
<li>
<p>客服：便捷地审核用户举报、问题用户的管理、推荐系统的精准度优化；</p>
</li>
<li>
<p>过滤系统：对内容完成智能过滤；</p>
</li>
<li>
<p>推荐系统：对内容完成智能推荐。</p>
</li>
</ul>
<p><strong>解决方案：</strong></p>
<ul>
<li>运营：好用的内容编辑、修改和发布工具；待审核的处理工作台；人工推荐配置支持、推荐系统的运作情况；内容运营数据的可视化呈现；</li>
<li>客服：待审核的处理工作台；用户标记管理、过滤系统的运作情况；</li>
<li>过滤系统：系统的搭建和持续优化方案；</li>
<li>推荐系统：系统的搭建和持续优化方案。</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://cm940324.github.io/post-images/1621580833843.png" alt="" loading="lazy"></figure>
<h3 id="2-内容的生产来源">2. 内容的生产(来源)</h3>
<p>CMS内容管理系统，从字面意思就能知道，管理的对象是“内容”，而“内容”的具体类型是什么、“管理”的具体范畴是什么，这些都是要依据具体的业务而定。</p>
<p>得有内容才有管理，没内容谈何管理呢？那问题来了，内容从哪里来呢？来源都有哪些？</p>
<h4 id="21-常见的内容生产模式">2.1 常见的内容生产模式</h4>
<p>介绍一下常见的内容生产模式，有以下三种：</p>
<p><strong>UGC模式：</strong></p>
<ul>
<li>全称：user generated content。即：用户输出内容。</li>
<li>产品代表：小红书。主要通过激励用户生产内容，形成社区氛围。</li>
</ul>
<p><strong>PGC模式：</strong></p>
<ul>
<li>全称：professionally generated content。即：专业输出内容。</li>
<li>产品代表：知乎。主要通过专业人员生产内容，提供给用户消费。</li>
</ul>
<p><strong>OGC模式：</strong></p>
<ul>
<li>
<p>全称：occupationally generated content。即：职业输出内容。</p>
</li>
<li>
<p>产品代表：新闻资讯类。主要通过具有一定知识和专业背景的行业人士生产内容，并领取相应报酬。</p>
</li>
</ul>
<p><strong>三者之间的区别：</strong></p>
<ul>
<li>
<p>UGC与PGC的区别：生产内容的人有无专业知识、资质；</p>
</li>
<li>
<p>PGC与OGC的区别：生产内容的人是否以此为职业，获得对应的报酬。</p>
</li>
</ul>
<p>往往PGC模式的内容生产者，也是产品的用户，还可能是种子用户、忠诚用户、意见领袖。</p>
<p>综上，我们可以将内容的来源分成4种：</p>
<ul>
<li>用户生产（UGC&amp;PGC）</li>
<li>运营生产（OGC）</li>
<li>技术爬取（通过技术手段去爬取内容）</li>
<li>授权使用（以付费的形式购买内容版权）</li>
</ul>
<p>其中：用户生产内容的产品支持，可由用户端的产品设计来满足。</p>
<p>技术爬取和授权使用，在需求明确的前提下，主要是由技术人员来实现和对接。</p>
<p>如果存在与多家平台有版权内容的授权对接工作，那建议可开发统一的内容接入接口。不同的版权内容平台，可能对接的方式有着大大小小的差异，这里可能涉及到一定的开发工作量。作为一名尽职的B端产品经理，本着为公司降本（降低开发成本）提效（提高版本效率）的一贯原则，最理想的状态是把统一的接口文档一发，就能把部分的开发工作量给转移了出去。但现实往往都是很骨感的，如果对方是“爸爸”，愿意把内容的版权给你就已经很难得了，那还是得乖乖自个儿开发接入。</p>
<p>以过来人的经验（踩过坑的那种），这部分的工作不要过分依赖开发，由其独自对接完成，需要加入必要的管理和规划，以免重复低效的工作占用太多的开发资源，或是人员离职变动带来的麻烦。至于价值、重要程度和优先级，需依据自己的项目、产品和团队情况，具体评估。</p>
<p>而内容管理系统（CMS）在生产环节主要服务的对象是负责内容生产的运营小伙伴。</p>
<p>一般情况下，内容运营除了管理官方账号外，可能同时还在运营着多个个人账号，如果运营同事也是依靠用户端来完成内容发布的工作，那就会存在频繁切换登录不同账号的麻烦。而切换登录这个需求对于普通用户可能根本就不存在。</p>
<p>除此之外，内容运营还存在用户需求之上的发布需求，比如可以预设定时发布等等。</p>
<h4 id="22-cms在生产环节的需求点">2.2 CMS在生产环节的需求点</h4>
<p>总结一下，内容管理系统（CMS）在生产环节的需求概要有：</p>
<p><strong>账号关联：</strong></p>
<ul>
<li>
<p>和CMS系统账号关联，支持系统账号和运营账号一对多的关系；</p>
</li>
<li>
<p>使用CMS系统发布内容时候，可选择对应的运营账号；</p>
</li>
<li>
<p>支持运营账号解除绑定或转移，以便应对人员调整或离职的变动。</p>
</li>
</ul>
<p><strong>生产工具：</strong></p>
<ul>
<li>提供便捷、好用的编辑功能；</li>
<li>支持效果预览；</li>
<li>可保存草稿。</li>
</ul>
<p>**素材管理：**如果对素材的复用度较高，可考虑增加素材管理，同时也方便随时随地有台电脑登录系统就能开展工作，避免素材要用起来才发现保存在某台电脑本地的尴尬。</p>
<p>**模板管理：**如果对特定内容的排版呈现有统一的要求，例如“每日推荐”等，只需要替换具体内容和素材即可，则可以增加模板管理，为运营减免重复不必要的排版布局工作。</p>
<p><strong>预设时间发布：</strong></p>
<ul>
<li>内容通常都是提前就会准备好的，尤其是针对一些节日主题或活动营销的内容，会提前思考、撰写，并对更新的节奏做好规划排期（就像产品经理做版本规划一样）。</li>
<li>如果有提供定时发布功能，那负责内容运营的同事就可以集中时间一次性地把准备好的内容提前设置好发布时间，使其更合理的安排工作时间和实施内容计划，提高工作效率。</li>
</ul>
<p>早期的版本，可仅提供基本的、必要的管理、编辑和发布功能，保证内容运营的顺利生产。而更能提高效率的工具和功能，则可与运营部门确认整体的内容工作规划，在不同的时期配合新增上线。</p>
<p>具体的功能设计可参考：微信公众平台、秀米编辑器、365编辑器。</p>
<p>以上，就是对于内容管理系统CMS在内容生产环节的总结与分享。后面，还会有CMS在内容过滤、内容呈现和内容举报环节的文章更新。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[AmazonS3工具类]]></title>
        <id>https://cm940324.github.io/post/amazons3-util/</id>
        <link href="https://cm940324.github.io/post/amazons3-util/">
        </link>
        <updated>2021-05-13T07:00:29.000Z</updated>
        <content type="html"><![CDATA[<pre><code>/**
 * @author chenmo
 * @Date: Created in 2021/5/12 5:05 下午
 * @Utils: Intellij Idea
 * @Description: TODO
 */
@Component
@RequiredArgsConstructor
public class AmazonS3Operator {

    private static final Logger LOGGER = LoggerFactory.getLogger(AmazonS3Operator.class);

    final AmazonS3Configuration amazonS3Configuration;

    //创建链接
    public AmazonS3 createConnection(){
        var credentials = new BasicAWSCredentials(amazonS3Configuration.getAccessKey(), amazonS3Configuration.getSecretKey());
        var conn = new AmazonS3Client(credentials);
        conn.setEndpoint(amazonS3Configuration.getEndPoint());
        var buckets = conn.listBuckets();
        LOGGER.info(&quot;amazonS3 bucket list ==========================================&quot;);
        for (Bucket bucket : buckets) {
            LOGGER.info(&quot;amazonS3 bucket =========&gt;&quot;+bucket.getName() + &quot;\t&quot; +
                    StringUtils.fromDate(bucket.getCreationDate()));
        }
        LOGGER.info(&quot;================================================================&quot;);
        return conn;
    }

    //创建Bucket
    public Bucket createBucket(String name){
        return createConnection().createBucket(name);
    }

    //上传一个文件
    public String uploadFileToBucket(MultipartFile multipartFile){
        var snowflake = new Snowflake(1,1);
        var key = snowflake.nextIdStr();
        FileInputStream fileInputStream = null;
        try {
            fileInputStream = (FileInputStream) multipartFile.getInputStream();
            createConnection().putObject(amazonS3Configuration.getBucket(),key,fileInputStream,new ObjectMetadata());
            LOGGER.info(&quot;上传文件&quot;+key+&quot;：&quot;+multipartFile.getName()+ &quot;到&quot;+amazonS3Configuration.getBucket()+&quot;成功！！！！&quot;);
            return key;
        }catch (FileNotFoundException e){
            LOGGER.info(&quot;上传文件&quot;+key+&quot;：&quot;+multipartFile.getName()+  &quot;到&quot;+amazonS3Configuration.getBucket()+&quot;失败，文件未找到&quot;);
            return null;
        }catch (IOException e){
            e.printStackTrace();
            return null;
        }finally {
            try {
                if(fileInputStream != null){
                    fileInputStream.close();
                }
            }catch (IOException e){
                LOGGER.debug(&quot;inputStream close IOException:&quot; + e.getMessage());
                e.printStackTrace();
            }
        }
    }

    //预览一个文件
    public String reviewFileFromBucket(String key){
        try {
            if(StringUtils.isNullOrEmpty(key)){
                return null;
            }
            var httpRequest = new GeneratePresignedUrlRequest(amazonS3Configuration.getBucket(), key);
            return createConnection().generatePresignedUrl(httpRequest).toString();
        }catch (Exception e){
            e.printStackTrace();
        }
        return null;
    }

}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式的学习]]></title>
        <id>https://cm940324.github.io/post/design-study/</id>
        <link href="https://cm940324.github.io/post/design-study/">
        </link>
        <updated>2021-05-09T09:21:27.000Z</updated>
        <content type="html"><![CDATA[<h3 id="设计模式的目的">设计模式的目的</h3>
<p>编写软件过程中，程序员面临着来自 耦合性，内聚性以及可维护性，可扩展性，重用性，灵活性 等多方面的挑战，设计模式是为了让程序(软件)具有更好的:</p>
<ol>
<li>
<p>代码重用性 (即：相同功能的代码，不用多次编写)</p>
</li>
<li>
<p>可读性 (即：编程规范性, 便于其他程序员的阅读和理解)</p>
</li>
<li>
<p>可扩展性 (即：当需要增加新的功能时，非常的方便，称为可维护)</p>
</li>
<li>
<p>可靠性 (即：当我们增加新的功能后，对原来的功能没有影响)</p>
</li>
<li>
<p>使程序呈现高内聚，低耦合的特性</p>
</li>
</ol>
<pre><code>“懂了设计模式，你就懂了面向对象分析和设计（OOA/D）的精要” ----设计模式包含了面向对象的精髓

“C++老手和 C++新手的区别就是前者手背上有很多伤疤” ----Scott Mayers 在其巨著《Effective C++》
</code></pre>
<h3 id="设计模式七大原则">设计模式七大原则</h3>
<p>设计模式原则，其实就是程序员在编程时，应当遵守的原则，也是各种设计模式的基础(即：设计模式为什么这样设计的依据)</p>
<p><mark>Ø 设计模式常用的七大原则有:</mark></p>
<ol>
<li>
<p>单一职责原则</p>
</li>
<li>
<p>接口隔离原则</p>
</li>
<li>
<p>依赖倒转(倒置)原则</p>
</li>
<li>
<p>里氏替换原则</p>
</li>
<li>
<p>开闭原则</p>
</li>
<li>
<p>迪米特法则</p>
</li>
<li>
<p>合成复用原则</p>
</li>
</ol>
<h4 id="单一职责原则">单一职责原则</h4>
<h5 id="基本介绍">基本介绍</h5>
<p>对类来说的，即一个类应该只负责一项职责。如类 A 负责两个不同职责：职责 1，职责 2。当职责 1 需求变更而改变 A 时，可能造成职责 2 执行错误，所以需要将类 A 的粒度分解为 A1，A2</p>
<h5 id="应用实例">应用实例</h5>
<p><strong>方案一:</strong></p>
<pre><code>// 1. 在方式 1 的 run 方法中，违反了单一职责原则
// 2. 解决的方案非常的简单，根据交通工具运行方法不同，分解成不同类即可
public class SingleResponsibility1{
	public static void main(String[] args){
		Vehicle vehicle = new Vehicle();
		vehicle.run(&quot;摩托车&quot;);
		vehicle.run(&quot;汽车&quot;);
		vehicle.run(&quot;飞机&quot;);
	}
}
class Vehicle {
	public void run(String vehicle) { 
			System.out.println(vehicle + &quot; 在公路上运行....&quot;);
	}
}

</code></pre>
<p><strong>方案二</strong></p>
<pre><code>//方案 2 的分析
//1. 遵守单一职责原则
//2. 但是这样做的改动很大，即将类分解，同时修改客户端
//3. 改进：直接修改 Vehicle 类，改动的代码会比较少=&gt;方案 3
public class SingleResponsibility1{
	public static void main(String[] args){
		RoadVehicle roadVehicle = new RoadVehicle();
		roadVehicle.run(&quot;摩托车&quot;);
		roadVehicle.run(&quot;汽车&quot;);
		AirVehicle airVehicle = new AirVehicle();
		airVehicle.run(&quot;飞机&quot;);
	}
}
class RoadVehicle {
	public void run(String vehicle) { 
		System.out.println(vehicle + &quot;公路运行&quot;);
	}
}


class AirVehicle {
	public void run(String vehicle) { 
		System.out.println(vehicle + &quot;天空运行&quot;);
	}
}

</code></pre>
<p><strong>方案三</strong></p>
<pre><code>//方式 3 的分析
//1. 这种修改方法没有对原来的类做大的修改，只是增加方法
//2. 这里虽然没有在类这个级别上遵守单一职责原则，但是在方法级别上，仍然是遵守单一职责
public class SingleResponsibility3 {
	public static void main(String[] args) {
		Vehicle2 vehicle2	= new Vehicle2();
		vehicle2.run(&quot;汽车&quot;);
		vehicle2.runWater(&quot;轮船&quot;);
		vehicle2.runAir(&quot;飞机&quot;);
	}
}
class Vehicle2 {
	public void run(String vehicle) {
		//处理
		System.out.println(vehicle + &quot; 在公路上运行....&quot;);
	}
	public void runAir(String vehicle) { 
		System.out.println(vehicle + &quot; 在天空上运行....&quot;);
	}
	public void runWater(String vehicle) { 
		System.out.println(vehicle + &quot; 在水中行....&quot;);
	}
}
</code></pre>
<pre><code>单一职责原则注意事项和细节
1)	降低类的复杂度，一个类只负责一项职责。
2)	提高类的可读性，可维护性
3)	降低变更引起的风险
4)	通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则
</code></pre>
<h4 id="接口隔离原则interface-segregation-principle">接口隔离原则(Interface Segregation Principle)</h4>
<h5 id="基本介绍-2">基本介绍</h5>
<ol>
<li>客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上</li>
<li>类 A 通过接口 Interface1 依赖类 B，类 C 通过接口 Interface1 依赖类 D，如果接口 Interface1 对于类 A 和类 C来说不是最小接口，那么类 B 和类 D 必须去实现他们不需要的方法。</li>
</ol>
<pre><code>public class Segregation1 {

public static void main(String[] args) {
// TODO Auto-generated method stub
}

}

//接口
interface Interface1 {
void operation1(); void operation2();
 

void operation3(); void operation4(); void operation5();
}


class B implements Interface1 { public void operation1() {
System.out.println(&quot;B 实现了 operation1&quot;);
}
public void operation2() {
System.out.println(&quot;B 实现了 operation2&quot;);
}
public void operation3() {
System.out.println(&quot;B 实现了 operation3&quot;);
}
public void operation4() {
System.out.println(&quot;B 实现了 operation4&quot;);
}
public void operation5() {
System.out.println(&quot;B 实现了 operation5&quot;);
}
}

class D implements Interface1 { public void operation1() {
System.out.println(&quot;D 实现了 operation1&quot;);
}
public void operation2() {
System.out.println(&quot;D 实现了 operation2&quot;);
}
public void operation3() {
System.out.println(&quot;D 实现了 operation3&quot;);
}
public void operation4() {
System.out.println(&quot;D 实现了  operation4&quot;);
}
public void  operation5()  { System.out.println(&quot;D 实现了  operation5&quot;);
}
}

class A { //A 类通过接口 Interface1 依赖(使用) B 类，但是只会用到 1,2,3 方法
public void depend1(Interface1 i) { i.operation1();
}
public void depend2(Interface1 i) { i.operation2();
}
public void depend3(Interface1 i) { i.operation3();
}
}

class C { //C 类通过接口 Interface1  依赖(使用) D 类，但是只会用到 1,4,5 方法
public void depend1(Interface1 i) { i.operation1();
}
public void depend4(Interface1 i) { i.operation4();
}
public void depend5(Interface1 i) { i.operation5();
}
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PostgreSQL自带全文检索]]></title>
        <id>https://cm940324.github.io/post/postgresql-jiansuo/</id>
        <link href="https://cm940324.github.io/post/postgresql-jiansuo/">
        </link>
        <updated>2021-05-06T08:38:50.000Z</updated>
        <content type="html"><![CDATA[<h3 id="相关文档">相关文档</h3>
<pre><code>文本搜索的函数与操作符中文说明: 
http://www.postgres.cn/docs/9.3.4/functions-textsearch.html
PostgreSQL 文本搜索文档 : 
https://www.postgresql.org/docs/9.4/textsearch-controls.html
</code></pre>
<h3 id="核心函数-关键字">核心函数、关键字</h3>
<p>全文搜索的思想主要分两步：</p>
<ul>
<li>
<p>将文本解析为对应的倒排索引</p>
</li>
<li>
<p>搜索索引来找到对应的文本</p>
</li>
</ul>
<p>要使用 PostgreSQL 的全文搜索, 那么就要了解到底是要用什么关键字和函数来<strong>构建索引</strong>和<strong>搜索</strong>， 这里主要涉及到<strong>一个关键字</strong>和<strong>四个函数</strong><br>
可以看上边的文档了解函数的具体参数</p>
<p><strong>关键字 tsvector:</strong><br>
tsvector 是 PostgreSQL 内置的一种字段类型, 用来保存的是分词后的结果 (文本向量) 它是由 [词，序列， 权重] 三个东西共同组成的， 权重可能会没有</p>
<p><strong>函数:</strong></p>
<ul>
<li>
<p>to_tsvector()</p>
<ul>
<li>分词用, 将文本转为向量。 用它可以将字符串转成上边说的 tsvector , 遗憾的是默认不支持中文分词</li>
</ul>
</li>
<li>
<p>to_tsquery()</p>
<ul>
<li>构建搜索的关键字， 支持各种符号表示条件。 详情查看文档</li>
</ul>
</li>
<li>
<p>setweight()</p>
<ul>
<li>设置关键词权重， 总共四个权重从高到低为 A-B-C-D</li>
</ul>
</li>
<li>
<p>ts_rank ()</p>
<ul>
<li>排序用， 可以根据 to_tsquery 和 tsvector 的匹配度计算</li>
</ul>
<pre><code>//查询表中包含 aaa 并且包含 BBB或CCC任意一个 的记录
  SELECT * FROM table
  WHERE to_tsvector('parser_name', field) @@ to_tsquery('aaa &amp; (bbb | ccc)')
</code></pre>
</li>
</ul>
<p><strong>索引:</strong></p>
<p>建立联合索引</p>
<pre><code>create index document_title_idx on encms.article using gin (to_tsvector('english',&quot;content&quot; || &quot;title&quot;) tsvector_ops)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[全面复盘：狗狗币是如何上涨400倍的？ ]]></title>
        <id>https://cm940324.github.io/post/doge/</id>
        <link href="https://cm940324.github.io/post/doge/">
        </link>
        <updated>2021-05-05T04:17:59.000Z</updated>
        <content type="html"><![CDATA[<pre><code>    ​
 4月20日，狗狗币纪念日。美国知名财经媒体在首页刊登了狗狗币相关报道，标题为《狗狗币交易赶上线上狂潮》，其中提到狗狗币在2021年的回报率超过8100%，是1998年以来标普500涨幅的2倍多，狗狗币市值大约为500亿美元，超过了万豪国际和福特汽车。
</code></pre>
<p>狗狗币2021年1月1日开盘报0.004619美元/枚，2021年4月16日最高报价已触及0.47美元/枚，日内暴涨200%，年内价格暴涨超100倍，仅耗时106天。自2020年3月12日最低价0.001158美元以来，最高涨幅超过了400倍。<br>
　　有观点认为，狗狗币的崛起反映了集体信念的力量以及对更理想形式的加密货币的渴望，预示着去中心化必将大兴其道。但狗狗币大涨400倍的背后，其实是名人的带动、散户的狂欢，以及韭菜的博傻心理，狗狗币的泡沫终将破灭。</p>
<h3 id="doge的前世今生">Doge的前世今生</h3>
<p>​		狗狗币是币圈一个独特的存在。2013年12月，美国IBM软件工程师Billy Markus和澳大利亚Adobe工程师Jackson Palmer共同在比特币代码基础上创造了Dogecoin。</p>
<p>极具讽刺的是，两位工程师当年推出狗狗币的目的却是为了“嘲笑”比特币。2013年，比特币价格极速上涨，从以前的一文不值迅速飙升到了几十美元。</p>
<p>如果说比特币是对传统金融体系的反叛，Dogecoin就是对比特币的反叛，它消解了比特币的一个主要特点——总量固定，不可超发。在Palmer和Marcus对比特币规则的修改下，Dogecoin第一年的发行量就有1000亿个，之后几乎每年都增发5%。目前，Dogecoin总量已经接近1300亿枚，是比特币的6000倍。</p>
<p>为了加大嘲讽，Palmer还顺手买了Dogecion.com以对标比特币的bitcoin.com的官网。Markus则给自己的推特取名为shibetoshi Nakaoto，用来讽刺比特币创始人中本聪（Satoshi Nakamoto）。</p>
<p>在今年2月CNET刊发的一篇采访中，Palmer笑道：“我们认为这是注定消亡的一个大玩笑。”</p>
<p>早在2019年4月，Palmer就清空了自己在Twitter账户上发布的内容，以及YouTube上的视频，消失在网络世界。而狗狗币的市值在诞生后的七年里一直排在200名之后。</p>
<p>进入2021年，狗狗币突然火了，而且是大火特火。数据统计回溯狗狗币价格发现，狗狗币2021年1月1日开盘报0.004619美元/枚，2021年4月16日最高报价已触及0.47美元/枚，日内暴涨200%，年内价格暴涨超100倍，仅耗时106天。自2020年3月12日最低价0.001158美元以来，最高涨幅超过了400倍。</p>
<h3 id="散户和马斯克">散户和马斯克</h3>
<p>​		目前看来，狗狗币的此次“出圈”有两大主要推手：一是社交媒体平台Reddit旗下WSB社区聚集的美国散户；二是特斯拉创始人埃隆马斯克。</p>
<p>今天1月，美股上演史上最大的“散户VS机构”大战，即GME（GameStop）保卫战。</p>
<p>WallStreetBets（简称WSB）散户集体把18美元的游戏零售商股票GME硬是推到了483美元，爆了华尔街一堆做空机构的大量仓位，在全球金融市场掀起轩然大波。</p>
<p>不久之后，WSB对股票市场的狂热蔓延至狗狗币。1月28日，推特用户“WSBChairman”问其75万关注者，“狗狗币曾经达到过1美元吗”，Reddit用户纷纷响应，呼吁大家要像买GME股票一样买Dogecoin，持币不售，目标是“1 Dogecoin=1美元”。随后，狗狗币出现了一个巨大的价格反弹，从0.01美元的低位升至0.087美元的峰值。</p>
<p>​		狗狗币价格狂涨，特斯拉CEO马斯克的“带货”同样功不可没。今年2月4日，马斯克突然发推“Doge”，狗狗币涨幅迅速攀升50%。随后他又连续发布多条与狗狗币有关的推文：“我们不需要成为亿万富翁就能拥有狗狗币，狗狗币才是人民的数字货币。”“我没喝多，也没情绪低落，心里只有狗狗币。”“狗狗币是世界上最有趣的加密货币。”</p>
<p>​		马斯克站台狗狗币，最早可以追溯至2019年4月，狗狗币官方账户在Twitter发起评选狗狗币CEO的投票，马斯克高票当选。随后，马斯克发推文称，狗狗币是他最喜欢的数字货币，并将自己的Twitter账户信息修改为“狗狗币前CEO”。</p>
<p>4月初，马斯克在推特上表示将使用SpaceX把一枚狗狗币带到月球上。消息一出，狗狗币直线拉升，当天大涨15%。</p>
<p>两个星期后，美国最大加密货币交易所Coinbase在纳斯达克交易所直接挂牌上市，成为美国加密货币平台第一股。Coinbase的成功上市带动密货币集体上涨，其中，狗狗币大涨近30%。</p>
<p>​		次日，马斯克发布推文，狗狗币朝着月亮吠叫，并附上了相关图片，狗狗币立马飙升，当日大涨50%。4月16日，狗狗币持续暴涨，24小时内涨幅一度达250%，最高触及0.47美元/枚，总市值一度突破600亿美元。</p>
<p>猛烈涨势之下，越来越多商家表示接受或考虑接受狗狗币支付。NBA球队达拉斯独行侠队从3月4日起开始接受狗狗币付款，球迷可以使用狗狗币购买比赛门票和球队商品。3月7日，该球队老板Mark Cuban发推文称：“达拉斯小牛队已经完成了超过20000个的狗狗币交易，使我们成为世界上最大的狗狗币商家。”4月15日，Mark Cuban再度发推文表示，小牛队将在资产负债表上永久持有狗狗币。目前，使用狗狗币购买球队商品的销售额已超12.2万枚。</p>
<p>​		可以看出的是，狗狗币在美国的社区基础相当牢固。其利用自己超过400倍的涨幅迅速出圈之后，继续获得更多商家支持。</p>
<p>3月30日，美联国际教育集团（METX.US）宣布，公司已启动区块链技术战略计划，并将在平台上为外籍教师引入狗狗币奖励机制。学生可以根据教师的教学表现奖励他们，教师也可以通过执行在公司平台上发布的教学和研究任务来获得狗狗币。此外，学生还可以通过完成学业和在平台上分享知识来获得狗狗币。</p>
<p>​		4月19日，士力架巧克力棒的官方推特账号发布了带有#doge day标签的推文，其中包含以狗狗币为主题的包装图。士力架公司还准备为狗狗币投资人推出限量版士力架巧克力棒，并称这只是一个“很酷的GIF图”。</p>
<p>4月20日，狗狗币迎来了自己的纪念日，利好消息不断。当日，知名在线零售商Newegg宣布，将接受狗狗币作为官方支付方式。Newegg高级品牌经理安德鲁·崔（Andrew Choi）表示：“我们致力于简化客户的购物流程，力求为他们提供最适合他们的购物方式，让他们可以选择最适合他们的付款方式来完成交易。为此，我们很高兴为持有狗狗币的粉丝提供方便的在线购买方式。”</p>
<p>​		美可味巧克力（Milky Way）则在推特上发布一条狗狗币与巧克力棒亲密接触消息，并把加密行业里常说的“To the Moon”改为了“To the Milky Way”。此外，超过13万人签署了Change.org上的一份请愿书，呼吁亚马逊接受狗狗币作为付款方式。</p>
<p>当天，美国饶舌巨星Snoop Dogg与Shiba-Inu（原始Doge表情中的那只狗）在YouTube上发布了一个名为“Snoop Dogg 420 DogeCoin Video”的音乐视频。这位歌手还在推特上艾特了马斯克这位狗狗币的最大推手，祝贺他参加4月20日“Doge Day”。</p>
<h3 id="泡沫终将破灭">泡沫终将破灭</h3>
<p>​		公开数据显示，今年以来，狗狗币的累计涨幅达到了7000%。4月21日，Coin Metrics联合创始人Nic Carter发推文称，在过去一周，有8.72亿枚5年多未移动的狗狗币（相当于2.87亿美元）重新进入流通。</p>
<p>这种数据表明，大户开始高位抛售，割韭菜的故事开始上演。自创历史新高的0.47美金之后，狗狗币价格一路下跌，4月26日约为0.27美金，较历史新高的跌幅高达42.6%。</p>
<p>狗狗币的大起大落引起了多位加密货币行业资深人士的质疑，认为它的泡沫实在太大，过多的被吹捧。他们告诫投资人，不该孤注一掷地押注于狗狗币，担心少数大型持有者控制了狗狗币的大部分供应。</p>
<p>实际上，狗狗币的筹码十分集中，近70%的狗狗币分布在世界各地约100个钱包中，其中最大的一个钱包控制了30%左右的狗狗币。</p>
<p>英国投资应用Freetrade的分析师David Kimberley认为，狗狗币的崛起是证明经济学博傻理论的一个经典例子。人们买狗狗币，不是因为他们认为狗狗币有任何意义或价值，而是因为他们希望其他人会涌入，推高价格，然后他们可以趁机卖出，迅速赚一笔钱。“当每个人都这么做的时候，泡沫最终会破裂，如果你不及时退出，就会被亏本。”</p>
<p>“由于马斯克的努力带货和鲸鱼对市场的操纵，狗狗币的价格已经变得非常高，这是一个泡沫。狗狗币的上涨是不可持续的，它将崩溃，大量散户资金将很快损失。”Cardano创始人Charles Hoskinson认为，在泡沫破裂后，狗狗币将成为监管者和立法者介入加密行业的催化剂，这不是一件好事。“狗狗币没有稳定的开发团队，也没有独创的技术。在必然来临的泡沫破裂之后，国会将展开调查，美国SEC将四处奔走，各种各样的监管机构会到处说：这证明加密货币无法控制自己，我们需要进来救你。”</p>
<p>根据coinmarketcap网站数据，目前全球仍有2109种数字货币在交易所交易，其中相当多的数字货币属于某一个企业所“研发”，它们背后拥有大股东的权力，违背了区块链的“去中心化”理念。</p>
<p>Real Vision创始人兼首席执行官Raoul Pal日前透露了自己持有的加密资产组合，“我现在的资产50%是比特币，30%是以太坊，20%是其他代币，我试图在整个加密领域中保持平衡，因为我真的不知道在这个领域中什么币会赢，什么币不会赢。”关于最近大热的狗狗币，Pal表示：“它会永远持续下去吗？谁知道呢？但是我买了一些狗狗币，因为人群在涌入。”</p>
<p>原标题：全面复盘：狗狗币是如何上涨400倍的？ 来源：链新</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[理解、学习与使用 JAVA 中的 OPTIONAL]]></title>
        <id>https://cm940324.github.io/post/java8-optional/</id>
        <link href="https://cm940324.github.io/post/java8-optional/">
        </link>
        <updated>2021-04-26T06:14:05.000Z</updated>
        <content type="html"><![CDATA[<p>​		从 Java 8 引入的一个很有趣的特性是 <em>Optional</em>  类。Optional 类主要解决的问题是臭名昭著的空指针异常（NullPointerException） —— 每个 Java 程序员都非常了解的异常。</p>
<p>​		本质上，这是一个包含有可选值的包装类，这意味着 Optional 类既可以含有对象也可以为空。Optional 是 Java 实现函数式编程的强劲一步，并且帮助在范式中实现。但是 Optional 的意义显然不止于此。</p>
<pre><code>if (user != null) {
    Address address = user.getAddress();
    if (address != null) {
        Country country = address.getCountry();
        if (country != null) {
            String isocode = country.getIsocode();
            if (isocode != null) {
                isocode = isocode.toUpperCase();
            }
        }
    }
}
</code></pre>
<p>​		你看到了，这很容易就变得冗长，难以维护。</p>
<p>​		为了简化这个过程，我们来看看用 <em>Optional</em> 类是怎么做的。从创建和验证实例，到使用其不同的方法，并与其它返回相同类型的方法相结合，下面是见证 <em>Optional</em>  奇迹的时刻。</p>
<h3 id="创建-optional-实例">创建 <em>Optional</em> 实例</h3>
<p>​		重申一下，这个类型的对象可能包含值，也可能为空。你可以使用同名方法创建一个空的 Optional.</p>
<pre><code>@Test(expected = NoSuchElementException.class)
public void whenCreateEmptyOptional_thenNull() {
    Optional&lt;User&gt; emptyOpt = Optional.empty();
    emptyOpt.get();
}
</code></pre>
<p>​		毫不奇怪，尝试访问 <em>emptyOpt</em> 变量的值会导致 <em>NoSuchElementException</em>。</p>
<p>​		你可以使用 <em>of()</em> 和 ofNullable() 方法创建包含值的 <em>Optional</em>。两个方法的不同之处在于如果你把 <em>null</em> 值作为参数传递进去，<em>of()</em> 方法会抛出 <em>NullPointerException</em>：</p>
<pre><code>@Test(expected = NullPointerException.class)
public void whenCreateOfEmptyOptional_thenNullPointerException() {
    Optional&lt;User&gt; opt = Optional.of(user);
}
</code></pre>
<p>​		你看，我们并没有完全摆脱 <em>NullPointerException</em>。因此，你应该明确对象不为 <em>null</em> 的时候使用 <em>of()</em>。</p>
<p>如果对象即可能是 <em>null</em> 也可能是非 null，你就应该使用 <em>ofNullable()</em> 方法：</p>
<pre><code>Optional&lt;User&gt; opt = Optional.ofNullable(user);
</code></pre>
<h3 id="访问-optional-对象的值">访问 <em>Optional</em> 对象的值</h3>
<p>​		从 <em>Optional</em> 实例中取回实际值对象的方法之一是使用 <em>get()</em> 方法：</p>
<pre><code>@Test
public void whenCreateOfNullableOptional_thenOk() {
    String name = &quot;John&quot;;
    Optional&lt;String&gt; opt = Optional.ofNullable(name);
    assertEquals(&quot;John&quot;, opt.get());
}
</code></pre>
<p>​		不过，你看到了，这个方法会在值为 <em>null</em> 的时候抛出异常。要避免异常，你可以选择首先验证是否有值：</p>
<pre><code>@Test
public void whenCheckIfPresent_thenOk() {
    User user = new User(&quot;john@gmail.com&quot;, &quot;1234&quot;);
    Optional&lt;User&gt; opt = Optional.ofNullable(user);
    assertTrue(opt.isPresent());
    assertEquals(user.getEmail(), opt.get().getEmail());
}
</code></pre>
<p>​		检查是否有值的另一个选择是 <em>ifPresent()</em> 方法。该方法除了执行检查，还接受一个<em>Consumer(消费者</em>) 参数，如果对象不是空的，就对执行传入的 Lambda 表达式：</p>
<pre><code>opt.ifPresent( u -&gt; assertEquals(user.getEmail(), u.getEmail()));
</code></pre>
<p>​		这个例子中，只有 user 用户不为 null 的时候才会执行断言。</p>
<p>​		接下来，我们来看看提供空值的方法。</p>
<h3 id="返回默认值">返回默认值</h3>
<p>​		<em>Optional</em> 类提供了 API 用以返回对象值，或者在对象为空的时候返回默认值。</p>
<p>​		这里你可以使用的第一个方法是 <em>orElse()</em>，它的工作方式非常直接，如果有值则返回该值，否则返回传递给它的参数值：</p>
<pre><code>@Test
public void whenEmptyValue_thenReturnDefault() {
    User user = null;
    User user2 = new User(&quot;anna@gmail.com&quot;, &quot;1234&quot;);
    User result = Optional.ofNullable(user).orElse(user2);

    assertEquals(user2.getEmail(), result.getEmail());
}
</code></pre>
<p>​		这里 <em>user</em> 对象是空的，所以返回了作为默认值的 <em>user2</em>。</p>
<p>​		如果对象的初始值不是 null，那么默认值会被忽略：</p>
<pre><code>@Test
public void whenValueNotNull_thenIgnoreDefault() {
    User user = new User(&quot;john@gmail.com&quot;,&quot;1234&quot;);
    User user2 = new User(&quot;anna@gmail.com&quot;, &quot;1234&quot;);
    User result = Optional.ofNullable(user).orElse(user2);

    assertEquals(&quot;john@gmail.com&quot;, result.getEmail());
}
</code></pre>
<p>​		第二个同类型的 API 是 <em>orElseGet()</em> —— 其行为略有不同。这个方法会在有值的时候返回值，如果没有值，它会执行作为参数传入的 <em>Supplier(供应者)</em> 函数式接口，并将返回其执行结果：</p>
<pre><code>User result = Optional.ofNullable(user).orElseGet( () -&gt; user2);
</code></pre>
<p>​		<em>orElse()</em> 和 <em>orElseGet()</em> 的不同之处</p>
<p>​		乍一看，这两种方法似乎起着同样的作用。然而事实并非如此。我们创建一些示例来突出二者行为上的异同。</p>
<p>我们先来看看对象为空时他们的行为：</p>
<pre><code>@Test
public void givenEmptyValue_whenCompare_thenOk() {
    User user = null
    logger.debug(&quot;Using orElse&quot;);
    User result = Optional.ofNullable(user).orElse(createNewUser());
    logger.debug(&quot;Using orElseGet&quot;);
    User result2 = Optional.ofNullable(user).orElseGet(() -&gt; createNewUser());
}

private User createNewUser() {
    logger.debug(&quot;Creating New User&quot;);
    return new User(&quot;extra@gmail.com&quot;, &quot;1234&quot;);
}
</code></pre>
<p>​		上面的代码中，两种方法都调用了 <em>createNewUser()</em> 方法，这个方法会记录一个消息并返回 <em>User</em> 对象。</p>
<p>代码输出如下：</p>
<pre><code>Using orElse
Creating New User
Using orElseGet
Creating New User
</code></pre>
<p>​		由此可见，当对象为空而返回默认对象时，行为并无差异。</p>
<p>​</p>
<p>​		我们接下来看一个类似的示例，但这里 <em>Optional</em>  不为空：</p>
<pre><code>@Test
public void givenPresentValue_whenCompare_thenOk() {
    User user = new User(&quot;john@gmail.com&quot;, &quot;1234&quot;);
    logger.info(&quot;Using orElse&quot;);
    User result = Optional.ofNullable(user).orElse(createNewUser());
    logger.info(&quot;Using orElseGet&quot;);
    User result2 = Optional.ofNullable(user).orElseGet(() -&gt; createNewUser());
}
</code></pre>
<p>​		这次的输出：</p>
<pre><code>Using orElse
Creating New User
Using orElseGet
</code></pre>
<p>​		这个示例中，两个 <em>Optional</em>  对象都包含非空值，两个方法都会返回对应的非空值。不过，<em>orElse()</em> 方法仍然创建了 <em>User</em> 对象。与之相反，<em>orElseGet()</em> 方法不创建 <em>User</em> 对象。</p>
<p>​		在执行较密集的调用时，比如调用 Web 服务或数据查询，这个差异会对性能产生重大影响。</p>
<h3 id="返回异常">返回异常</h3>
<p>​		除了 <em>orElse()</em> 和 <em>orElseGet()</em> 方法，Optional 还定义了 <em>orElseThrow()</em> API —— 它会在对象为空的时候抛出异常，而不是返回备选的值：</p>
<pre><code>@Test(expected = IllegalArgumentException.class)
public void whenThrowException_thenOk() {
    User result = Optional.ofNullable(user)
      .orElseThrow( () -&gt; new IllegalArgumentException());
}
</code></pre>
<p>​		这里，如果 <em>user</em> 值为 null，会抛出 <em>IllegalArgumentException</em>。</p>
<p>​		这个方法让我们有更丰富的语义，可以决定抛出什么样的异常，而不总是抛出 <em>NullPointerException</em>。</p>
<p>​		现在我们已经很好地理解了如何使用 Optional，我们来看看其它可以对 <em>Optional</em> 值进行转换和过滤的方法。</p>
<h3 id="转换值">转换值</h3>
<p>​		有很多种方法可以转换 <em>Optional</em> 的值。我们从 <em>map()</em> 和 <em>flatMap()</em> 方法开始。</p>
<p>先来看一个使用 <em>map()</em> API 的例子：</p>
<pre><code>@Test
public void whenMap_thenOk() {
    User user = new User(&quot;anna@gmail.com&quot;, &quot;1234&quot;);
    String email = Optional.ofNullable(user)
      .map(u -&gt; u.getEmail()).orElse(&quot;default@gmail.com&quot;);

    assertEquals(email, user.getEmail());
}
</code></pre>
<p>​		<em>map()</em> 对值应用(调用)作为参数的<em>函数</em>，然后将返回的值包装在 <em>Optional</em> 中。这就使对返回值进行链试调用的操作成为可能 —— 这里的下一环就是 <em>orElse()</em>。</p>
<p>​		相比这下，<em>flatMap()</em> 也需要<em>函数</em>作为参数，并对值调用这个函数，然后直接返回结果。</p>
<p>​		下面的操作中，我们给 <em>User</em> 类添加了一个方法，用来返回 <em>Optional</em>：</p>
<pre><code>public class User {    
    private String position;

    public Optional&lt;String&gt; getPosition() {
        return Optional.ofNullable(position);
    }

    //...
}
</code></pre>
<p>​		既然 getter 方法返回 String 值的 <em>Optional</em>，你可以在对 <em>User</em> <em>的 Optional</em> 对象调用 <em>flatMap()</em> 时，用它作为参数。其返回的值是解除包装的 String 值</p>
<pre><code>@Test
public void whenFlatMap_thenOk() {
    User user = new User(&quot;anna@gmail.com&quot;, &quot;1234&quot;);
    user.setPosition(&quot;Developer&quot;);
    String position = Optional.ofNullable(user)
      .flatMap(u -&gt; u.getPosition()).orElse(&quot;default&quot;);

    assertEquals(position, user.getPosition().get());
}
</code></pre>
<p>​		过滤值</p>
<p>​		除了转换值之外，<em>Optional</em> 类也提供了按条件“过滤”值的方法。<em>filter()</em> 接受一个 <em>Predicate</em> 参数，返回测试结果为 true 的值。如果测试结果为 false，会返回一个空的 <em>Optional</em>。</p>
<p>来看一个根据基本的电子邮箱验证来决定接受或拒绝 <em>User</em>*(用户)* 的示例：</p>
<pre><code>@Test
public void whenFilter_thenOk() {
    User user = new User(&quot;anna@gmail.com&quot;, &quot;1234&quot;);
    Optional&lt;User&gt; result = Optional.ofNullable(user)
      .filter(u -&gt; u.getEmail() != null &amp;&amp; u.getEmail().contains(&quot;@&quot;));

    assertTrue(result.isPresent());
}
</code></pre>
<p>​		如果通过过滤器测试，<em>result</em> 对象会包含非空值。</p>
<h3 id="optional-类的链式方法"><em>Optional</em> 类的链式方法</h3>
<p>​		为了更充分的使用 <em>Optional</em>，你可以链接组合其大部分方法，因为它们都返回相同类似的对象。</p>
<p>​		我们使用 <em>Optional</em> 重写最早介绍的示例。</p>
<p>​		首先，重构类，使其 getter 方法返回 <em>Optional</em> 引用</p>
<pre><code>public class User {
    private Address address;

    public Optional&lt;Address&gt; getAddress() {
        return Optional.ofNullable(address);
    }

    // ...
}
public class Address {
    private Country country;

    public Optional&lt;Country&gt; getCountry() {
        return Optional.ofNullable(country);
    }

    // ...
}
</code></pre>
<p>​		现在可以删除 <em>null</em> 检查，替换为 <em>Optional</em> 的方法</p>
<pre><code>@Test
public void whenChaining_thenOk() {
    User user = new User(&quot;anna@gmail.com&quot;, &quot;1234&quot;);

    String result = Optional.ofNullable(user)
      .flatMap(u -&gt; u.getAddress())
      .flatMap(a -&gt; a.getCountry())
      .map(c -&gt; c.getIsocode())
      .orElse(&quot;default&quot;);

    assertEquals(result, &quot;default&quot;);
}
</code></pre>
<p>​		上面的代码可以通过方法引用进一步缩减：</p>
<pre><code>String result = Optional.ofNullable(user)
  .flatMap(User::getAddress)
  .flatMap(Address::getCountry)
  .map(Country::getIsocode)
  .orElse(&quot;default&quot;);
</code></pre>
<p>结果现在的代码看起来比之前采用条件分支的冗长代码简洁多了。</p>
<h3 id="java-9-增强">Java 9 增强</h3>
<p>​		我们介绍了 Java 8 的特性，Java 9 为 Optional 类添加了三个方法：<em>or()</em>、<em>ifPresentOrElse()</em> 和 <em>stream()</em>。</p>
<p>​		<em>or()</em> 方法与 <em>orElse()</em> 和 <em>orElseGet()</em> 类似，它们都在对象为空的时候提供了替代情况。<em>or()</em> 的返回值是由 <em>Supplier</em> 参数产生的另一个 <em>Optional</em> 对象。</p>
<p>​		如果对象包含值，则 Lambda 表达式不会执行：</p>
<pre><code>@Test
public void whenEmptyOptional_thenGetValueFromOr() {
    User result = Optional.ofNullable(user)
      .or( () -&gt; Optional.of(new User(&quot;default&quot;,&quot;1234&quot;))).get();

    assertEquals(result.getEmail(), &quot;default&quot;);
}
</code></pre>
<p>​		上面的示例中，如果 <em>user</em> 变量是 null，它会返回一个 <em>Optional</em>，它所包含的 <em>User</em> 对象，其电子邮件为 “default”。</p>
<p><em>ifPresentOrElse()</em> 方法需要两个参数：一个 <em>Consumer</em> 和一个 <em>Runnable</em>。如果对象包含值，会执行 <em>Consumer</em> 的动作，否则运行 <em>Runnable</em>。</p>
<p>​		如果你想在有值的时候执行某个动作，或者只是跟踪是否定义了某个值，那么这个方法非常有用：</p>
<pre><code>Optional.ofNullable(user).ifPresentOrElse( u -&gt; logger.info(&quot;User is:&quot; + u.getEmail()),
  () -&gt; logger.info(&quot;User not found&quot;));
</code></pre>
<p>​		最后介绍的是新的 <em>stream()</em> 方法，它通过把实例转换为 <em>Stream</em> 对象，让你从广大的 <em>Stream</em> API 中受益。如果没有值，它会得到空的 <em>Stream</em>；有值的情况下，<em>Stream</em> 则会包含单一值。</p>
<p>​		我们来看一个把 <em>Optional</em> 处理成 <em>Stream</em> 的例子：</p>
<pre><code>@Test
public void whenGetStream_thenOk() {
    User user = new User(&quot;john@gmail.com&quot;, &quot;1234&quot;);
    List&lt;String&gt; emails = Optional.ofNullable(user)
      .stream()
      .filter(u -&gt; u.getEmail() != null &amp;&amp; u.getEmail().contains(&quot;@&quot;))
      .map( u -&gt; u.getEmail())
      .collect(Collectors.toList());

    assertTrue(emails.size() == 1);
    assertEquals(emails.get(0), user.getEmail());
}
</code></pre>
<p>​		这里对 <em>Stream</em> 的使用带来了其 <em>filter()、map()</em> 和 <em>collect()</em> 接口，以获取 <em>List</em>。</p>
<h3 id="optional-应该怎样用"><em>Optional</em> 应该怎样用？</h3>
<p>​		在使用 <em>Optional</em> 的时候需要考虑一些事情，以决定什么时候怎样使用它。</p>
<p>​		重要的一点是 <em>Optional</em> 不是 <em>Serializable</em>。因此，它不应该用作类的字段。</p>
<p>​		如果你需要序列化的对象包含 <em>Optional</em> 值，<a href="https://stackify.com/java-xml-jackson/"><em>Jackson</em> 库</a>支持把 <em>Optional</em> 当作普通对象。也就是说，<em>Jackson</em> 会把空对象看作 <em>null</em>，而有值的对象则把其值看作对应域的值。这个功能在 <a href="https://github.com/FasterXML/jackson-modules-java8">jackson-modules-java8</a> 项目中。</p>
<p>​		它在另一种情况下也并不怎么有用，就是在将其类型用作方法或构建方法的参数时。这样做会让代码变得复杂，完全没有必要：</p>
<pre><code>User user = new User(&quot;john@gmail.com&quot;, &quot;1234&quot;, Optional.empty());
</code></pre>
<p>​		使用重载方法来处理非要的参数要容易得多。</p>
<p>​		<em>Optional</em> 主要用作返回类型。在获取到这个类型的实例后，如果它有值，你可以取得这个值，否则可以进行一些替代行为。</p>
<p>​		<em>Optional</em> 类有一个非常有用的用例，就是将其与流或其它返回 <em>Optional</em> 的方法结合，以构建流畅的API。</p>
<p>​		我们来看一个示例，使用 <em>Stream</em> 返回 <em>Optional</em> 对象的 <em>findFirst()</em> 方法：</p>
<pre><code>@Test
public void whenEmptyStream_thenReturnDefaultOptional() {
    List&lt;User&gt; users = new ArrayList&lt;&gt;();
    User user = users.stream().findFirst().orElse(new User(&quot;default&quot;, &quot;1234&quot;));

    assertEquals(user.getEmail(), &quot;default&quot;);
}
</code></pre>
<h3 id="总结">总结</h3>
<p><em>Optional</em> 是 Java 语言的有益补充 —— 它旨在减少代码中的 <em>NullPointerExceptions</em>，虽然还不能完全消除这些异常。</p>
<p>它也是精心设计，自然融入 Java 8 函数式支持的功能。</p>
<p>总的来说，这个简单而强大的类有助于创建简单、可读性更强、比对应程序错误更少的程序。</p>
<p>转自 https://www.cnblogs.com/zhangboyu/p/7580262.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring Data REST 快速构建 restful api 应用]]></title>
        <id>https://cm940324.github.io/post/spring-data-rest/</id>
        <link href="https://cm940324.github.io/post/spring-data-rest/">
        </link>
        <updated>2021-04-22T06:00:24.000Z</updated>
        <content type="html"><![CDATA[<h3 id="什么是spring-data-rest">什么是Spring Data REST</h3>
<blockquote>
<p>​		Spring Data REST是基于Spring Data的repository之上，可以把 repository 自动输出为REST资源，目前支持Spring Data JPA、Spring Data <a href="https://cloud.tencent.com/product/mongodb?from=10680">MongoDB</a>、Spring Data Neo4j、Spring Data GemFire、Spring Data Cassandra的 repository 自动转换成REST服务。注意是自动。简单点说，Spring Data REST把我们需要编写的大量REST模版接口做了自动化实现.</p>
</blockquote>
<h3 id="restful-api">restful api</h3>
<p>​		REST是一种设计风格(与具体的语言无关)，它的URL主体是资源，是个名词。而且也仅支持HTTP协议，规定了使用HTTP Method表达本次要做的动作，类型一般也不超过那四五种。这些动作表达了对资源仅有的几种转化方式。</p>
<p>​		常用的HTTP动词有下面五个（括号里是对应的SQL命令）。</p>
<ul>
<li>GET（SELECT）：从服务器取出资源（一项或多项）</li>
<li>POST（CREATE）：在服务器新建一个资源。</li>
<li>PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。</li>
<li>PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。</li>
<li>DELETE（DELETE）：从服务器删除资源。</li>
<li>HEAD：获取资源的元数据。</li>
<li>OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。</li>
</ul>
<h3 id="实现">实现</h3>
<h4 id="添加依赖">添加依赖</h4>
<pre><code class="language-javascript">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-rest&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h4 id="定义domain">定义domain</h4>
<pre><code class="language-javascript">package com.zyndev.springdatarestdemo.domain;

import lombok.Data;

import javax.persistence.*;
import java.io.Serializable;
import java.util.Date;


@Data
@Entity
@Table(name = &quot;tb_user&quot;)
public class User implements Serializable {

    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;            // 用户id
    private String userName;    // 用户名称
    private String password;    // 用户密码
    private Integer active;     // 是否可用
    private Date lastLoginTime; // 最后登录时间
    private Date createTime;    // 账户创建时间
    private Date updateTime;    // 最后更新时间
}
</code></pre>
<h4 id="定义-repository">定义 Repository</h4>
<pre><code class="language-javascript">package com.zyndev.springdatarestdemo.controller;

import com.zyndev.springdatarestdemo.domain.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.rest.core.annotation.RepositoryRestResource;

@RepositoryRestResource(path=&quot;user&quot;)
public interface UserRepository extends JpaRepository&lt;User, Long&gt; {
}
</code></pre>
<h4 id="配置">配置</h4>
<pre><code class="language-javascript">server:
  port: 8080

spring:
  jpa:
    hibernate:
      ddl-auto: update
</code></pre>
<blockquote>
<p>通过设置 <code>spring.jpa.hibernate.ddl-auto=update</code> 来自动创建表，如果你已经根据domain建好表，可忽略，配置中省略了数据库的配置，请根据情况自行添加</p>
</blockquote>
<h4 id="测试">测试</h4>
<p>启动项目:</p>
<p>​		<strong>1. GET 访问 localhost:8080/user</strong>这里我已经添加了一条数据</p>
<pre><code class="language-javascript">{
    &quot;_embedded&quot;: {
        &quot;users&quot;: [
            {
                &quot;userName&quot;: &quot;abc&quot;,
                &quot;password&quot;: &quot;abc&quot;,
                &quot;active&quot;: 1,
                &quot;lastLoginTime&quot;: null,
                &quot;createTime&quot;: null,
                &quot;updateTime&quot;: null,
                &quot;_links&quot;: {
                    &quot;self&quot;: {
                        &quot;href&quot;: &quot;http://localhost:8080/user/1&quot;
                    },
                    &quot;user&quot;: {
                        &quot;href&quot;: &quot;http://localhost:8080/user/1&quot;
                    }
                }
            }
        ]
    },
    &quot;_links&quot;: {
        &quot;self&quot;: {
            &quot;href&quot;: &quot;http://localhost:8080/user{?page,size,sort}&quot;,
            &quot;templated&quot;: true
        },
        &quot;profile&quot;: {
            &quot;href&quot;: &quot;http://localhost:8080/profile/user&quot;
        }
    },
    &quot;page&quot;: {
        &quot;size&quot;: 20,
        &quot;totalElements&quot;: 1,
        &quot;totalPages&quot;: 1,
        &quot;number&quot;: 0
    }
}
</code></pre>
<p>​		<strong>2. GET 访问 localhost:8080/user/1</strong></p>
<p>​		通过上面可以看出 <code>1</code> 是存在的</p>
<pre><code class="language-javascript">{
    &quot;userName&quot;: &quot;abc&quot;,
    &quot;password&quot;: &quot;abc&quot;,
    &quot;active&quot;: 1,
    &quot;lastLoginTime&quot;: null,
    &quot;createTime&quot;: null,
    &quot;updateTime&quot;: null,
    &quot;_links&quot;: {
        &quot;self&quot;: {
            &quot;href&quot;: &quot;http://localhost:8080/user/1&quot;
        },
        &quot;user&quot;: {
            &quot;href&quot;: &quot;http://localhost:8080/user/1&quot;
        }
    }
}
</code></pre>
<p>​		<strong>3. GET 访问 localhost:8080/user/2</strong></p>
<p>​		因为 <code>2</code> 并不存在，这时返回 <code>404</code></p>
<p>​		<strong>4. POST localhost:8080/user 创建一个资源</strong></p>
<p>​		设置 <code>Content-Type=application/json</code></p>
<p>​		<strong>body:</strong></p>
<pre><code class="language-javascript">{
    &quot;userName&quot;: &quot;abcdfasdfe&quot;,
    &quot;password&quot;: &quot;abc&quot;,
    &quot;active&quot;: 1,
    &quot;lastLoginTime&quot;: null,
    &quot;createTime&quot;: null,
    &quot;updateTime&quot;: null
}
</code></pre>
<p>返回状态码 <code>201</code></p>
<p>返回数据：</p>
<pre><code class="language-javascript">{
    &quot;userName&quot;: &quot;abcdfasdfe&quot;,
    &quot;password&quot;: &quot;abc&quot;,
    &quot;active&quot;: 1,
    &quot;lastLoginTime&quot;: null,
    &quot;createTime&quot;: null,
    &quot;updateTime&quot;: null,
    &quot;_links&quot;: {
        &quot;self&quot;: {
            &quot;href&quot;: &quot;http://localhost:8080/user/4&quot;
        },
        &quot;user&quot;: {
            &quot;href&quot;: &quot;http://localhost:8080/user/4&quot;
        }
    }
}
</code></pre>
<p>​		<strong>5. 再次访问 GET 访问 localhost:8080/user</strong></p>
<p>​		这时可以看出 users 的数量为 2 说明已经创建成功</p>
<pre><code class="language-javascript">{
    &quot;_embedded&quot;: {
        &quot;users&quot;: [
            {
                &quot;userName&quot;: &quot;abc&quot;,
                &quot;password&quot;: &quot;abc&quot;,
                &quot;active&quot;: 1,
                &quot;lastLoginTime&quot;: null,
                &quot;createTime&quot;: null,
                &quot;updateTime&quot;: null,
                &quot;_links&quot;: {
                    &quot;self&quot;: {
                        &quot;href&quot;: &quot;http://localhost:8080/user/1&quot;
                    },
                    &quot;user&quot;: {
                        &quot;href&quot;: &quot;http://localhost:8080/user/1&quot;
                    }
                }
            },
            {
                &quot;userName&quot;: &quot;abcdfasdfe&quot;,
                &quot;password&quot;: &quot;abc&quot;,
                &quot;active&quot;: 1,
                &quot;lastLoginTime&quot;: null,
                &quot;createTime&quot;: null,
                &quot;updateTime&quot;: null,
                &quot;_links&quot;: {
                    &quot;self&quot;: {
                        &quot;href&quot;: &quot;http://localhost:8080/user/4&quot;
                    },
                    &quot;user&quot;: {
                        &quot;href&quot;: &quot;http://localhost:8080/user/4&quot;
                    }
                }
            }
        ]
    },
    &quot;_links&quot;: {
        &quot;self&quot;: {
            &quot;href&quot;: &quot;http://localhost:8080/user{?page,size,sort}&quot;,
            &quot;templated&quot;: true
        },
        &quot;profile&quot;: {
            &quot;href&quot;: &quot;http://localhost:8080/profile/user&quot;
        }
    },
    &quot;page&quot;: {
        &quot;size&quot;: 20,
        &quot;totalElements&quot;: 2,
        &quot;totalPages&quot;: 1,
        &quot;number&quot;: 0
    }
}
</code></pre>
<p>​		<strong>6. delete 访问 localhost:8080/user/1</strong></p>
<p>返回状态码： <code>204</code></p>
<p>再次访问 GET 访问 localhost:8080/user 会发现 users 的数量已经为1，说明已经删除成功</p>
<blockquote>
<p>可以使用 postman 测试，这里为了不贴图，就按上面的写了，希望理解</p>
</blockquote>
<p># 小功能</p>
<p>为了方便查看和测试api,可以集成 <code>hal browser</code></p>
<p>在 pom 文件添加依赖即可</p>
<pre><code class="language-javascript">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;
    &lt;artifactId&gt;spring-data-rest-hal-browser&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>重启项目并访问： <code>http://127.0.0.1:8080/browser/index.html#/</code></p>
]]></content>
    </entry>
</feed>